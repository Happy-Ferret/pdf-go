// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Tue, 10 Oct 2017 18:52:59 MSK.
// By https://git.io/c-for-go. DO NOT EDIT.

package mupdf

/*
#include "mupdf/pdf.h"
#include "mupdf/fitz.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocAllocContextMemory allocates memory for type C.fz_alloc_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAllocContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAllocContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAllocContextValue = unsafe.Sizeof([1]C.fz_alloc_context{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AllocContext) Ref() *C.fz_alloc_context {
	if x == nil {
		return nil
	}
	return x.ref846108bc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AllocContext) Free() {
	if x != nil && x.allocs846108bc != nil {
		x.allocs846108bc.(*cgoAllocMap).Free()
		x.ref846108bc = nil
	}
}

// NewAllocContextRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAllocContextRef(ref unsafe.Pointer) *AllocContext {
	if ref == nil {
		return nil
	}
	obj := new(AllocContext)
	obj.ref846108bc = (*C.fz_alloc_context)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AllocContext) PassRef() (*C.fz_alloc_context, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref846108bc != nil {
		return x.ref846108bc, nil
	}
	mem846108bc := allocAllocContextMemory(1)
	ref846108bc := (*C.fz_alloc_context)(mem846108bc)
	allocs846108bc := new(cgoAllocMap)
	allocs846108bc.Add(mem846108bc)

	var cuser_allocs *cgoAllocMap
	ref846108bc.user, cuser_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.User)), cgoAllocsUnknown
	allocs846108bc.Borrow(cuser_allocs)

	var cmalloc_allocs *cgoAllocMap
	ref846108bc.malloc, cmalloc_allocs = x.Malloc.PassRef()
	allocs846108bc.Borrow(cmalloc_allocs)

	var crealloc_allocs *cgoAllocMap
	ref846108bc.realloc, crealloc_allocs = x.Realloc.PassRef()
	allocs846108bc.Borrow(crealloc_allocs)

	var cfree_allocs *cgoAllocMap
	ref846108bc.free, cfree_allocs = x.Free.PassRef()
	allocs846108bc.Borrow(cfree_allocs)

	x.ref846108bc = ref846108bc
	x.allocs846108bc = allocs846108bc
	return ref846108bc, allocs846108bc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AllocContext) PassValue() (C.fz_alloc_context, *cgoAllocMap) {
	if x.ref846108bc != nil {
		return *x.ref846108bc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AllocContext) Deref() {
	if x.ref846108bc == nil {
		return
	}
	x.User = (unsafe.Pointer)(unsafe.Pointer(x.ref846108bc.user))
	x.Malloc = NewRef(unsafe.Pointer(x.ref846108bc.malloc))
	x.Realloc = NewRef(unsafe.Pointer(x.ref846108bc.realloc))
	x.Free = NewRef(unsafe.Pointer(x.ref846108bc.free))
}

// allocErrorContextMemory allocates memory for type C.fz_error_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocErrorContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfErrorContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfErrorContextValue = unsafe.Sizeof([1]C.fz_error_context{})

type sliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}

// allocErrorStackSlotMemory allocates memory for type C.fz_error_stack_slot in C.
// The caller is responsible for freeing the this memory via C.free.
func allocErrorStackSlotMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfErrorStackSlotValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfErrorStackSlotValue = unsafe.Sizeof([1]C.fz_error_stack_slot{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSErrorStackSlot transforms a sliced Go data structure into plain C format.
func unpackSErrorStackSlot(x []ErrorStackSlot) (unpacked *C.fz_error_stack_slot, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_error_stack_slot) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocErrorStackSlotMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_error_stack_slot)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_error_stack_slot)(unsafe.Pointer(h.Data))
	return
}

// allocA256ErrorStackSlotMemory allocates memory for type [256]C.fz_error_stack_slot in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA256ErrorStackSlotMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA256ErrorStackSlotValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA256ErrorStackSlotValue = unsafe.Sizeof([1][256]C.fz_error_stack_slot{})

// unpackA256ErrorStackSlot transforms a sliced Go data structure into plain C format.
func unpackA256ErrorStackSlot(x [256]ErrorStackSlot) (unpacked [256]C.fz_error_stack_slot, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[256]C.fz_error_stack_slot) {
		go allocs.Free()
	})

	mem0 := allocA256ErrorStackSlotMemory(1)
	allocs.Add(mem0)
	v0 := (*[256]C.fz_error_stack_slot)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[256]C.fz_error_stack_slot)(mem0)
	return
}

// packSErrorStackSlot reads sliced Go data structure out from plain C format.
func packSErrorStackSlot(v []ErrorStackSlot, ptr0 *C.fz_error_stack_slot) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfErrorStackSlotValue]C.fz_error_stack_slot)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewErrorStackSlotRef(unsafe.Pointer(&ptr1))
	}
}

// packA256ErrorStackSlot reads sliced Go data structure out from plain C format.
func packA256ErrorStackSlot(v *[256]ErrorStackSlot, ptr0 *[256]C.fz_error_stack_slot) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewErrorStackSlotRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ErrorContext) Ref() *C.fz_error_context {
	if x == nil {
		return nil
	}
	return x.refe6cae537
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ErrorContext) Free() {
	if x != nil && x.allocse6cae537 != nil {
		x.allocse6cae537.(*cgoAllocMap).Free()
		x.refe6cae537 = nil
	}
}

// NewErrorContextRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewErrorContextRef(ref unsafe.Pointer) *ErrorContext {
	if ref == nil {
		return nil
	}
	obj := new(ErrorContext)
	obj.refe6cae537 = (*C.fz_error_context)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ErrorContext) PassRef() (*C.fz_error_context, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe6cae537 != nil {
		return x.refe6cae537, nil
	}
	meme6cae537 := allocErrorContextMemory(1)
	refe6cae537 := (*C.fz_error_context)(meme6cae537)
	allocse6cae537 := new(cgoAllocMap)
	allocse6cae537.Add(meme6cae537)

	var ctop_allocs *cgoAllocMap
	refe6cae537.top, ctop_allocs = unpackSErrorStackSlot(x.Top)
	allocse6cae537.Borrow(ctop_allocs)

	var cstack_allocs *cgoAllocMap
	refe6cae537.stack, cstack_allocs = unpackA256ErrorStackSlot(x.Stack)
	allocse6cae537.Borrow(cstack_allocs)

	var cerrcode_allocs *cgoAllocMap
	refe6cae537.errcode, cerrcode_allocs = (C.int)(x.Errcode), cgoAllocsUnknown
	allocse6cae537.Borrow(cerrcode_allocs)

	var cmessage_allocs *cgoAllocMap
	refe6cae537.message, cmessage_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Message)), cgoAllocsUnknown
	allocse6cae537.Borrow(cmessage_allocs)

	x.refe6cae537 = refe6cae537
	x.allocse6cae537 = allocse6cae537
	return refe6cae537, allocse6cae537

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ErrorContext) PassValue() (C.fz_error_context, *cgoAllocMap) {
	if x.refe6cae537 != nil {
		return *x.refe6cae537, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ErrorContext) Deref() {
	if x.refe6cae537 == nil {
		return
	}
	packSErrorStackSlot(x.Top, x.refe6cae537.top)
	packA256ErrorStackSlot(&x.Stack, (*[256]C.fz_error_stack_slot)(unsafe.Pointer(&x.refe6cae537.stack)))
	x.Errcode = (int32)(x.refe6cae537.errcode)
	x.Message = *(*[256]byte)(unsafe.Pointer(&x.refe6cae537.message))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ErrorStackSlot) Ref() *C.fz_error_stack_slot {
	if x == nil {
		return nil
	}
	return x.refd443b19a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ErrorStackSlot) Free() {
	if x != nil && x.allocsd443b19a != nil {
		x.allocsd443b19a.(*cgoAllocMap).Free()
		x.refd443b19a = nil
	}
}

// NewErrorStackSlotRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewErrorStackSlotRef(ref unsafe.Pointer) *ErrorStackSlot {
	if ref == nil {
		return nil
	}
	obj := new(ErrorStackSlot)
	obj.refd443b19a = (*C.fz_error_stack_slot)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ErrorStackSlot) PassRef() (*C.fz_error_stack_slot, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd443b19a != nil {
		return x.refd443b19a, nil
	}
	memd443b19a := allocErrorStackSlotMemory(1)
	refd443b19a := (*C.fz_error_stack_slot)(memd443b19a)
	allocsd443b19a := new(cgoAllocMap)
	allocsd443b19a.Add(memd443b19a)

	var ccode_allocs *cgoAllocMap
	refd443b19a.code, ccode_allocs = (C.int)(x.Code), cgoAllocsUnknown
	allocsd443b19a.Borrow(ccode_allocs)

	var cbuffer_allocs *cgoAllocMap
	refd443b19a.buffer, cbuffer_allocs = *(*[37]C.jmp_buf)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsd443b19a.Borrow(cbuffer_allocs)

	x.refd443b19a = refd443b19a
	x.allocsd443b19a = allocsd443b19a
	return refd443b19a, allocsd443b19a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ErrorStackSlot) PassValue() (C.fz_error_stack_slot, *cgoAllocMap) {
	if x.refd443b19a != nil {
		return *x.refd443b19a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ErrorStackSlot) Deref() {
	if x.refd443b19a == nil {
		return
	}
	x.Code = (int32)(x.refd443b19a.code)
	x.Buffer = *(*[37]int32)(unsafe.Pointer(&x.refd443b19a.buffer))
}

// Ref returns a reference to C object as it is.
func (x *IdContext) Ref() *C.fz_id_context {
	if x == nil {
		return nil
	}
	return (*C.fz_id_context)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *IdContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewIdContextRef converts the C object reference into a raw struct reference without wrapping.
func NewIdContextRef(ref unsafe.Pointer) *IdContext {
	return (*IdContext)(ref)
}

// NewIdContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewIdContext() *IdContext {
	return (*IdContext)(allocIdContextMemory(1))
}

// allocIdContextMemory allocates memory for type C.fz_id_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIdContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIdContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfIdContextValue = unsafe.Sizeof([1]C.fz_id_context{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *IdContext) PassRef() *C.fz_id_context {
	if x == nil {
		x = (*IdContext)(allocIdContextMemory(1))
	}
	return (*C.fz_id_context)(unsafe.Pointer(x))
}

// allocWarnContextMemory allocates memory for type C.fz_warn_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocWarnContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfWarnContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfWarnContextValue = unsafe.Sizeof([1]C.fz_warn_context{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *WarnContext) Ref() *C.fz_warn_context {
	if x == nil {
		return nil
	}
	return x.reff5178c16
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *WarnContext) Free() {
	if x != nil && x.allocsf5178c16 != nil {
		x.allocsf5178c16.(*cgoAllocMap).Free()
		x.reff5178c16 = nil
	}
}

// NewWarnContextRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewWarnContextRef(ref unsafe.Pointer) *WarnContext {
	if ref == nil {
		return nil
	}
	obj := new(WarnContext)
	obj.reff5178c16 = (*C.fz_warn_context)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *WarnContext) PassRef() (*C.fz_warn_context, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff5178c16 != nil {
		return x.reff5178c16, nil
	}
	memf5178c16 := allocWarnContextMemory(1)
	reff5178c16 := (*C.fz_warn_context)(memf5178c16)
	allocsf5178c16 := new(cgoAllocMap)
	allocsf5178c16.Add(memf5178c16)

	var cmessage_allocs *cgoAllocMap
	reff5178c16.message, cmessage_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Message)), cgoAllocsUnknown
	allocsf5178c16.Borrow(cmessage_allocs)

	var ccount_allocs *cgoAllocMap
	reff5178c16.count, ccount_allocs = (C.int)(x.Count), cgoAllocsUnknown
	allocsf5178c16.Borrow(ccount_allocs)

	x.reff5178c16 = reff5178c16
	x.allocsf5178c16 = allocsf5178c16
	return reff5178c16, allocsf5178c16

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x WarnContext) PassValue() (C.fz_warn_context, *cgoAllocMap) {
	if x.reff5178c16 != nil {
		return *x.reff5178c16, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *WarnContext) Deref() {
	if x.reff5178c16 == nil {
		return
	}
	x.Message = *(*[256]byte)(unsafe.Pointer(&x.reff5178c16.message))
	x.Count = (int32)(x.reff5178c16.count)
}

// Ref returns a reference to C object as it is.
func (x *FontContext) Ref() *C.fz_font_context {
	if x == nil {
		return nil
	}
	return (*C.fz_font_context)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FontContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFontContextRef converts the C object reference into a raw struct reference without wrapping.
func NewFontContextRef(ref unsafe.Pointer) *FontContext {
	return (*FontContext)(ref)
}

// NewFontContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFontContext() *FontContext {
	return (*FontContext)(allocFontContextMemory(1))
}

// allocFontContextMemory allocates memory for type C.fz_font_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFontContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFontContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFontContextValue = unsafe.Sizeof([1]C.fz_font_context{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FontContext) PassRef() *C.fz_font_context {
	if x == nil {
		x = (*FontContext)(allocFontContextMemory(1))
	}
	return (*C.fz_font_context)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *ColorspaceContext) Ref() *C.fz_colorspace_context {
	if x == nil {
		return nil
	}
	return (*C.fz_colorspace_context)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ColorspaceContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewColorspaceContextRef converts the C object reference into a raw struct reference without wrapping.
func NewColorspaceContextRef(ref unsafe.Pointer) *ColorspaceContext {
	return (*ColorspaceContext)(ref)
}

// NewColorspaceContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewColorspaceContext() *ColorspaceContext {
	return (*ColorspaceContext)(allocColorspaceContextMemory(1))
}

// allocColorspaceContextMemory allocates memory for type C.fz_colorspace_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocColorspaceContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfColorspaceContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfColorspaceContextValue = unsafe.Sizeof([1]C.fz_colorspace_context{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ColorspaceContext) PassRef() *C.fz_colorspace_context {
	if x == nil {
		x = (*ColorspaceContext)(allocColorspaceContextMemory(1))
	}
	return (*C.fz_colorspace_context)(unsafe.Pointer(x))
}

// allocCmmEngineMemory allocates memory for type C.fz_cmm_engine in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCmmEngineMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCmmEngineValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCmmEngineValue = unsafe.Sizeof([1]C.fz_cmm_engine{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CmmEngine) Ref() *C.fz_cmm_engine {
	if x == nil {
		return nil
	}
	return x.refd4bc4dec
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CmmEngine) Free() {
	if x != nil && x.allocsd4bc4dec != nil {
		x.allocsd4bc4dec.(*cgoAllocMap).Free()
		x.refd4bc4dec = nil
	}
}

// NewCmmEngineRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCmmEngineRef(ref unsafe.Pointer) *CmmEngine {
	if ref == nil {
		return nil
	}
	obj := new(CmmEngine)
	obj.refd4bc4dec = (*C.fz_cmm_engine)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CmmEngine) PassRef() (*C.fz_cmm_engine, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd4bc4dec != nil {
		return x.refd4bc4dec, nil
	}
	memd4bc4dec := allocCmmEngineMemory(1)
	refd4bc4dec := (*C.fz_cmm_engine)(memd4bc4dec)
	allocsd4bc4dec := new(cgoAllocMap)
	allocsd4bc4dec.Add(memd4bc4dec)

	var cnew_instance_allocs *cgoAllocMap
	refd4bc4dec.new_instance, cnew_instance_allocs = x.NewInstance.PassRef()
	allocsd4bc4dec.Borrow(cnew_instance_allocs)

	var cdrop_instance_allocs *cgoAllocMap
	refd4bc4dec.drop_instance, cdrop_instance_allocs = x.DropInstance.PassRef()
	allocsd4bc4dec.Borrow(cdrop_instance_allocs)

	var ctransform_pixmap_allocs *cgoAllocMap
	refd4bc4dec.transform_pixmap, ctransform_pixmap_allocs = x.TransformPixmap.PassRef()
	allocsd4bc4dec.Borrow(ctransform_pixmap_allocs)

	var ctransform_color_allocs *cgoAllocMap
	refd4bc4dec.transform_color, ctransform_color_allocs = x.TransformColor.PassRef()
	allocsd4bc4dec.Borrow(ctransform_color_allocs)

	var cinit_link_allocs *cgoAllocMap
	refd4bc4dec.init_link, cinit_link_allocs = x.InitLink.PassRef()
	allocsd4bc4dec.Borrow(cinit_link_allocs)

	var cfin_link_allocs *cgoAllocMap
	refd4bc4dec.fin_link, cfin_link_allocs = x.FinLink.PassRef()
	allocsd4bc4dec.Borrow(cfin_link_allocs)

	var cinit_profile_allocs *cgoAllocMap
	refd4bc4dec.init_profile, cinit_profile_allocs = x.InitProfile.PassRef()
	allocsd4bc4dec.Borrow(cinit_profile_allocs)

	var cfin_profile_allocs *cgoAllocMap
	refd4bc4dec.fin_profile, cfin_profile_allocs = x.FinProfile.PassRef()
	allocsd4bc4dec.Borrow(cfin_profile_allocs)

	var cavoid_white_fix_flag_allocs *cgoAllocMap
	refd4bc4dec.avoid_white_fix_flag, cavoid_white_fix_flag_allocs = (C.int)(x.AvoidWhiteFixFlag), cgoAllocsUnknown
	allocsd4bc4dec.Borrow(cavoid_white_fix_flag_allocs)

	x.refd4bc4dec = refd4bc4dec
	x.allocsd4bc4dec = allocsd4bc4dec
	return refd4bc4dec, allocsd4bc4dec

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CmmEngine) PassValue() (C.fz_cmm_engine, *cgoAllocMap) {
	if x.refd4bc4dec != nil {
		return *x.refd4bc4dec, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CmmEngine) Deref() {
	if x.refd4bc4dec == nil {
		return
	}
	x.NewInstance = NewCmmNewInstanceFnRef(unsafe.Pointer(x.refd4bc4dec.new_instance))
	x.DropInstance = NewCmmDropInstanceFnRef(unsafe.Pointer(x.refd4bc4dec.drop_instance))
	x.TransformPixmap = NewCmmTransformPixmapFnRef(unsafe.Pointer(x.refd4bc4dec.transform_pixmap))
	x.TransformColor = NewCmmTransformColorFnRef(unsafe.Pointer(x.refd4bc4dec.transform_color))
	x.InitLink = NewCmmInitLinkFnRef(unsafe.Pointer(x.refd4bc4dec.init_link))
	x.FinLink = NewCmmFinLinkFnRef(unsafe.Pointer(x.refd4bc4dec.fin_link))
	x.InitProfile = NewCmmInitProfileFnRef(unsafe.Pointer(x.refd4bc4dec.init_profile))
	x.FinProfile = NewCmmFinProfileFnRef(unsafe.Pointer(x.refd4bc4dec.fin_profile))
	x.AvoidWhiteFixFlag = (int32)(x.refd4bc4dec.avoid_white_fix_flag)
}

// Ref returns a reference to C object as it is.
func (x *CmmInstance) Ref() *C.fz_cmm_instance {
	if x == nil {
		return nil
	}
	return (*C.fz_cmm_instance)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CmmInstance) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCmmInstanceRef converts the C object reference into a raw struct reference without wrapping.
func NewCmmInstanceRef(ref unsafe.Pointer) *CmmInstance {
	return (*CmmInstance)(ref)
}

// NewCmmInstance allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCmmInstance() *CmmInstance {
	return (*CmmInstance)(allocCmmInstanceMemory(1))
}

// allocCmmInstanceMemory allocates memory for type C.fz_cmm_instance in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCmmInstanceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCmmInstanceValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCmmInstanceValue = unsafe.Sizeof([1]C.fz_cmm_instance{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CmmInstance) PassRef() *C.fz_cmm_instance {
	if x == nil {
		x = (*CmmInstance)(allocCmmInstanceMemory(1))
	}
	return (*C.fz_cmm_instance)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *AaContext) Ref() *C.fz_aa_context {
	if x == nil {
		return nil
	}
	return (*C.fz_aa_context)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *AaContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewAaContextRef converts the C object reference into a raw struct reference without wrapping.
func NewAaContextRef(ref unsafe.Pointer) *AaContext {
	return (*AaContext)(ref)
}

// NewAaContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewAaContext() *AaContext {
	return (*AaContext)(allocAaContextMemory(1))
}

// allocAaContextMemory allocates memory for type C.fz_aa_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAaContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAaContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAaContextValue = unsafe.Sizeof([1]C.fz_aa_context{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *AaContext) PassRef() *C.fz_aa_context {
	if x == nil {
		x = (*AaContext)(allocAaContextMemory(1))
	}
	return (*C.fz_aa_context)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *StyleContext) Ref() *C.fz_style_context {
	if x == nil {
		return nil
	}
	return (*C.fz_style_context)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *StyleContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewStyleContextRef converts the C object reference into a raw struct reference without wrapping.
func NewStyleContextRef(ref unsafe.Pointer) *StyleContext {
	return (*StyleContext)(ref)
}

// NewStyleContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewStyleContext() *StyleContext {
	return (*StyleContext)(allocStyleContextMemory(1))
}

// allocStyleContextMemory allocates memory for type C.fz_style_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStyleContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStyleContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStyleContextValue = unsafe.Sizeof([1]C.fz_style_context{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *StyleContext) PassRef() *C.fz_style_context {
	if x == nil {
		x = (*StyleContext)(allocStyleContextMemory(1))
	}
	return (*C.fz_style_context)(unsafe.Pointer(x))
}

// allocLocksContextMemory allocates memory for type C.fz_locks_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLocksContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLocksContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfLocksContextValue = unsafe.Sizeof([1]C.fz_locks_context{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *LocksContext) Ref() *C.fz_locks_context {
	if x == nil {
		return nil
	}
	return x.ref8200acff
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *LocksContext) Free() {
	if x != nil && x.allocs8200acff != nil {
		x.allocs8200acff.(*cgoAllocMap).Free()
		x.ref8200acff = nil
	}
}

// NewLocksContextRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewLocksContextRef(ref unsafe.Pointer) *LocksContext {
	if ref == nil {
		return nil
	}
	obj := new(LocksContext)
	obj.ref8200acff = (*C.fz_locks_context)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *LocksContext) PassRef() (*C.fz_locks_context, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8200acff != nil {
		return x.ref8200acff, nil
	}
	mem8200acff := allocLocksContextMemory(1)
	ref8200acff := (*C.fz_locks_context)(mem8200acff)
	allocs8200acff := new(cgoAllocMap)
	allocs8200acff.Add(mem8200acff)

	var cuser_allocs *cgoAllocMap
	ref8200acff.user, cuser_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.User)), cgoAllocsUnknown
	allocs8200acff.Borrow(cuser_allocs)

	var clock_allocs *cgoAllocMap
	ref8200acff.lock, clock_allocs = x.Lock.PassRef()
	allocs8200acff.Borrow(clock_allocs)

	var cunlock_allocs *cgoAllocMap
	ref8200acff.unlock, cunlock_allocs = x.Unlock.PassRef()
	allocs8200acff.Borrow(cunlock_allocs)

	x.ref8200acff = ref8200acff
	x.allocs8200acff = allocs8200acff
	return ref8200acff, allocs8200acff

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x LocksContext) PassValue() (C.fz_locks_context, *cgoAllocMap) {
	if x.ref8200acff != nil {
		return *x.ref8200acff, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *LocksContext) Deref() {
	if x.ref8200acff == nil {
		return
	}
	x.User = (unsafe.Pointer)(unsafe.Pointer(x.ref8200acff.user))
	x.Lock = NewRef(unsafe.Pointer(x.ref8200acff.lock))
	x.Unlock = NewRef(unsafe.Pointer(x.ref8200acff.unlock))
}

// Ref returns a reference to C object as it is.
func (x *TuningContext) Ref() *C.fz_tuning_context {
	if x == nil {
		return nil
	}
	return (*C.fz_tuning_context)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TuningContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTuningContextRef converts the C object reference into a raw struct reference without wrapping.
func NewTuningContextRef(ref unsafe.Pointer) *TuningContext {
	return (*TuningContext)(ref)
}

// NewTuningContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTuningContext() *TuningContext {
	return (*TuningContext)(allocTuningContextMemory(1))
}

// allocTuningContextMemory allocates memory for type C.fz_tuning_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTuningContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTuningContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTuningContextValue = unsafe.Sizeof([1]C.fz_tuning_context{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TuningContext) PassRef() *C.fz_tuning_context {
	if x == nil {
		x = (*TuningContext)(allocTuningContextMemory(1))
	}
	return (*C.fz_tuning_context)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Store) Ref() *C.fz_store {
	if x == nil {
		return nil
	}
	return (*C.fz_store)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Store) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewStoreRef converts the C object reference into a raw struct reference without wrapping.
func NewStoreRef(ref unsafe.Pointer) *Store {
	return (*Store)(ref)
}

// NewStore allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewStore() *Store {
	return (*Store)(allocStoreMemory(1))
}

// allocStoreMemory allocates memory for type C.fz_store in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStoreMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStoreValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStoreValue = unsafe.Sizeof([1]C.fz_store{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Store) PassRef() *C.fz_store {
	if x == nil {
		x = (*Store)(allocStoreMemory(1))
	}
	return (*C.fz_store)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *GlyphCache) Ref() *C.fz_glyph_cache {
	if x == nil {
		return nil
	}
	return (*C.fz_glyph_cache)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *GlyphCache) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewGlyphCacheRef converts the C object reference into a raw struct reference without wrapping.
func NewGlyphCacheRef(ref unsafe.Pointer) *GlyphCache {
	return (*GlyphCache)(ref)
}

// NewGlyphCache allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewGlyphCache() *GlyphCache {
	return (*GlyphCache)(allocGlyphCacheMemory(1))
}

// allocGlyphCacheMemory allocates memory for type C.fz_glyph_cache in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGlyphCacheMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGlyphCacheValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfGlyphCacheValue = unsafe.Sizeof([1]C.fz_glyph_cache{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *GlyphCache) PassRef() *C.fz_glyph_cache {
	if x == nil {
		x = (*GlyphCache)(allocGlyphCacheMemory(1))
	}
	return (*C.fz_glyph_cache)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *DocumentHandlerContext) Ref() *C.fz_document_handler_context {
	if x == nil {
		return nil
	}
	return (*C.fz_document_handler_context)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DocumentHandlerContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDocumentHandlerContextRef converts the C object reference into a raw struct reference without wrapping.
func NewDocumentHandlerContextRef(ref unsafe.Pointer) *DocumentHandlerContext {
	return (*DocumentHandlerContext)(ref)
}

// NewDocumentHandlerContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDocumentHandlerContext() *DocumentHandlerContext {
	return (*DocumentHandlerContext)(allocDocumentHandlerContextMemory(1))
}

// allocDocumentHandlerContextMemory allocates memory for type C.fz_document_handler_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDocumentHandlerContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDocumentHandlerContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDocumentHandlerContextValue = unsafe.Sizeof([1]C.fz_document_handler_context{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DocumentHandlerContext) PassRef() *C.fz_document_handler_context {
	if x == nil {
		x = (*DocumentHandlerContext)(allocDocumentHandlerContextMemory(1))
	}
	return (*C.fz_document_handler_context)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *OutputContext) Ref() *C.fz_output_context {
	if x == nil {
		return nil
	}
	return (*C.fz_output_context)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *OutputContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewOutputContextRef converts the C object reference into a raw struct reference without wrapping.
func NewOutputContextRef(ref unsafe.Pointer) *OutputContext {
	return (*OutputContext)(ref)
}

// NewOutputContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewOutputContext() *OutputContext {
	return (*OutputContext)(allocOutputContextMemory(1))
}

// allocOutputContextMemory allocates memory for type C.fz_output_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocOutputContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfOutputContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfOutputContextValue = unsafe.Sizeof([1]C.fz_output_context{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *OutputContext) PassRef() *C.fz_output_context {
	if x == nil {
		x = (*OutputContext)(allocOutputContextMemory(1))
	}
	return (*C.fz_output_context)(unsafe.Pointer(x))
}

// allocContextMemory allocates memory for type C.fz_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfContextValue = unsafe.Sizeof([1]C.fz_context{})

// unpackSAllocContext transforms a sliced Go data structure into plain C format.
func unpackSAllocContext(x []AllocContext) (unpacked *C.fz_alloc_context, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_alloc_context) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocAllocContextMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_alloc_context)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_alloc_context)(unsafe.Pointer(h.Data))
	return
}

// unpackSLocksContext transforms a sliced Go data structure into plain C format.
func unpackSLocksContext(x []LocksContext) (unpacked *C.fz_locks_context, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_locks_context) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocLocksContextMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_locks_context)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_locks_context)(unsafe.Pointer(h.Data))
	return
}

// unpackSErrorContext transforms a sliced Go data structure into plain C format.
func unpackSErrorContext(x []ErrorContext) (unpacked *C.fz_error_context, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_error_context) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocErrorContextMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_error_context)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_error_context)(unsafe.Pointer(h.Data))
	return
}

// unpackSWarnContext transforms a sliced Go data structure into plain C format.
func unpackSWarnContext(x []WarnContext) (unpacked *C.fz_warn_context, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_warn_context) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocWarnContextMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_warn_context)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_warn_context)(unsafe.Pointer(h.Data))
	return
}

// packSAllocContext reads sliced Go data structure out from plain C format.
func packSAllocContext(v []AllocContext, ptr0 *C.fz_alloc_context) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAllocContextValue]C.fz_alloc_context)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAllocContextRef(unsafe.Pointer(&ptr1))
	}
}

// packSLocksContext reads sliced Go data structure out from plain C format.
func packSLocksContext(v []LocksContext, ptr0 *C.fz_locks_context) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfLocksContextValue]C.fz_locks_context)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewLocksContextRef(unsafe.Pointer(&ptr1))
	}
}

// packSErrorContext reads sliced Go data structure out from plain C format.
func packSErrorContext(v []ErrorContext, ptr0 *C.fz_error_context) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfErrorContextValue]C.fz_error_context)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewErrorContextRef(unsafe.Pointer(&ptr1))
	}
}

// packSWarnContext reads sliced Go data structure out from plain C format.
func packSWarnContext(v []WarnContext, ptr0 *C.fz_warn_context) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfWarnContextValue]C.fz_warn_context)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewWarnContextRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Context) Ref() *C.fz_context {
	if x == nil {
		return nil
	}
	return x.refa9c9ee60
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Context) Free() {
	if x != nil && x.allocsa9c9ee60 != nil {
		x.allocsa9c9ee60.(*cgoAllocMap).Free()
		x.refa9c9ee60 = nil
	}
}

// NewContextRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewContextRef(ref unsafe.Pointer) *Context {
	if ref == nil {
		return nil
	}
	obj := new(Context)
	obj.refa9c9ee60 = (*C.fz_context)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Context) PassRef() (*C.fz_context, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa9c9ee60 != nil {
		return x.refa9c9ee60, nil
	}
	mema9c9ee60 := allocContextMemory(1)
	refa9c9ee60 := (*C.fz_context)(mema9c9ee60)
	allocsa9c9ee60 := new(cgoAllocMap)
	allocsa9c9ee60.Add(mema9c9ee60)

	var cuser_allocs *cgoAllocMap
	refa9c9ee60.user, cuser_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.User)), cgoAllocsUnknown
	allocsa9c9ee60.Borrow(cuser_allocs)

	var calloc_allocs *cgoAllocMap
	refa9c9ee60.alloc, calloc_allocs = unpackSAllocContext(x.Alloc)
	allocsa9c9ee60.Borrow(calloc_allocs)

	var clocks_allocs *cgoAllocMap
	refa9c9ee60.locks, clocks_allocs = unpackSLocksContext(x.Locks)
	allocsa9c9ee60.Borrow(clocks_allocs)

	var cid_allocs *cgoAllocMap
	refa9c9ee60.id, cid_allocs = (*C.fz_id_context)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Id)).Data)), cgoAllocsUnknown
	allocsa9c9ee60.Borrow(cid_allocs)

	var cerror_allocs *cgoAllocMap
	refa9c9ee60.error, cerror_allocs = unpackSErrorContext(x.Error)
	allocsa9c9ee60.Borrow(cerror_allocs)

	var cwarn_allocs *cgoAllocMap
	refa9c9ee60.warn, cwarn_allocs = unpackSWarnContext(x.Warn)
	allocsa9c9ee60.Borrow(cwarn_allocs)

	var cfont_allocs *cgoAllocMap
	refa9c9ee60.font, cfont_allocs = (*C.fz_font_context)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Font)).Data)), cgoAllocsUnknown
	allocsa9c9ee60.Borrow(cfont_allocs)

	var ccolorspace_allocs *cgoAllocMap
	refa9c9ee60.colorspace, ccolorspace_allocs = (*C.fz_colorspace_context)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Colorspace)).Data)), cgoAllocsUnknown
	allocsa9c9ee60.Borrow(ccolorspace_allocs)

	var ccmm_instance_allocs *cgoAllocMap
	refa9c9ee60.cmm_instance, ccmm_instance_allocs = (*C.fz_cmm_instance)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.CmmInstance)).Data)), cgoAllocsUnknown
	allocsa9c9ee60.Borrow(ccmm_instance_allocs)

	var caa_allocs *cgoAllocMap
	refa9c9ee60.aa, caa_allocs = (*C.fz_aa_context)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Aa)).Data)), cgoAllocsUnknown
	allocsa9c9ee60.Borrow(caa_allocs)

	var cstyle_allocs *cgoAllocMap
	refa9c9ee60.style, cstyle_allocs = (*C.fz_style_context)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Style)).Data)), cgoAllocsUnknown
	allocsa9c9ee60.Borrow(cstyle_allocs)

	var cstore_allocs *cgoAllocMap
	refa9c9ee60.store, cstore_allocs = (*C.fz_store)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Store)).Data)), cgoAllocsUnknown
	allocsa9c9ee60.Borrow(cstore_allocs)

	var cglyph_cache_allocs *cgoAllocMap
	refa9c9ee60.glyph_cache, cglyph_cache_allocs = (*C.fz_glyph_cache)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.GlyphCache)).Data)), cgoAllocsUnknown
	allocsa9c9ee60.Borrow(cglyph_cache_allocs)

	var ctuning_allocs *cgoAllocMap
	refa9c9ee60.tuning, ctuning_allocs = (*C.fz_tuning_context)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Tuning)).Data)), cgoAllocsUnknown
	allocsa9c9ee60.Borrow(ctuning_allocs)

	var chandler_allocs *cgoAllocMap
	refa9c9ee60.handler, chandler_allocs = (*C.fz_document_handler_context)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Handler)).Data)), cgoAllocsUnknown
	allocsa9c9ee60.Borrow(chandler_allocs)

	var coutput_allocs *cgoAllocMap
	refa9c9ee60.output, coutput_allocs = (*C.fz_output_context)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Output)).Data)), cgoAllocsUnknown
	allocsa9c9ee60.Borrow(coutput_allocs)

	x.refa9c9ee60 = refa9c9ee60
	x.allocsa9c9ee60 = allocsa9c9ee60
	return refa9c9ee60, allocsa9c9ee60

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Context) PassValue() (C.fz_context, *cgoAllocMap) {
	if x.refa9c9ee60 != nil {
		return *x.refa9c9ee60, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Context) Deref() {
	if x.refa9c9ee60 == nil {
		return
	}
	x.User = (unsafe.Pointer)(unsafe.Pointer(x.refa9c9ee60.user))
	packSAllocContext(x.Alloc, x.refa9c9ee60.alloc)
	packSLocksContext(x.Locks, x.refa9c9ee60.locks)
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.Id))
	hxfc4425b.Data = uintptr(unsafe.Pointer(x.refa9c9ee60.id))
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

	packSErrorContext(x.Error, x.refa9c9ee60.error)
	packSWarnContext(x.Warn, x.refa9c9ee60.warn)
	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.Font))
	hxf95e7c8.Data = uintptr(unsafe.Pointer(x.refa9c9ee60.font))
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ?

	hxff2234b := (*sliceHeader)(unsafe.Pointer(&x.Colorspace))
	hxff2234b.Data = uintptr(unsafe.Pointer(x.refa9c9ee60.colorspace))
	hxff2234b.Cap = 0x7fffffff
	// hxff2234b.Len = ?

	hxff73280 := (*sliceHeader)(unsafe.Pointer(&x.CmmInstance))
	hxff73280.Data = uintptr(unsafe.Pointer(x.refa9c9ee60.cmm_instance))
	hxff73280.Cap = 0x7fffffff
	// hxff73280.Len = ?

	hxfa9955c := (*sliceHeader)(unsafe.Pointer(&x.Aa))
	hxfa9955c.Data = uintptr(unsafe.Pointer(x.refa9c9ee60.aa))
	hxfa9955c.Cap = 0x7fffffff
	// hxfa9955c.Len = ?

	hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&x.Style))
	hxfa3f05c.Data = uintptr(unsafe.Pointer(x.refa9c9ee60.style))
	hxfa3f05c.Cap = 0x7fffffff
	// hxfa3f05c.Len = ?

	hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&x.Store))
	hxf0d18b7.Data = uintptr(unsafe.Pointer(x.refa9c9ee60.store))
	hxf0d18b7.Cap = 0x7fffffff
	// hxf0d18b7.Len = ?

	hxf2fab0d := (*sliceHeader)(unsafe.Pointer(&x.GlyphCache))
	hxf2fab0d.Data = uintptr(unsafe.Pointer(x.refa9c9ee60.glyph_cache))
	hxf2fab0d.Cap = 0x7fffffff
	// hxf2fab0d.Len = ?

	hxf69fe70 := (*sliceHeader)(unsafe.Pointer(&x.Tuning))
	hxf69fe70.Data = uintptr(unsafe.Pointer(x.refa9c9ee60.tuning))
	hxf69fe70.Cap = 0x7fffffff
	// hxf69fe70.Len = ?

	hxf65bf54 := (*sliceHeader)(unsafe.Pointer(&x.Handler))
	hxf65bf54.Data = uintptr(unsafe.Pointer(x.refa9c9ee60.handler))
	hxf65bf54.Cap = 0x7fffffff
	// hxf65bf54.Len = ?

	hxf3b8dbd := (*sliceHeader)(unsafe.Pointer(&x.Output))
	hxf3b8dbd.Data = uintptr(unsafe.Pointer(x.refa9c9ee60.output))
	hxf3b8dbd.Cap = 0x7fffffff
	// hxf3b8dbd.Len = ?

}

// packSIrect reads sliced Go data structure out from plain C format.
func packSIrect(v []Irect, ptr0 *C.fz_irect) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfIrectValue]C.fz_irect)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewIrectRef(unsafe.Pointer(&ptr1))
	}
}

func (x TuneImageDecodeFn) PassRef() (ref *C.fz_tune_image_decode_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tuneImageDecodeFn4232B35AFunc == nil {
		tuneImageDecodeFn4232B35AFunc = x
	}
	return (*C.fz_tune_image_decode_fn)(C.fz_tune_image_decode_fn_4232b35a), nil
}

func NewTuneImageDecodeFnRef(ref unsafe.Pointer) *TuneImageDecodeFn {
	return (*TuneImageDecodeFn)(ref)
}

//export tuneImageDecodeFn4232B35A
func tuneImageDecodeFn4232B35A(carg unsafe.Pointer, cw C.int, ch C.int, cl2factor C.int, csubarea *C.fz_irect) {
	if tuneImageDecodeFn4232B35AFunc != nil {
		arg4232b35a := (unsafe.Pointer)(unsafe.Pointer(carg))
		w4232b35a := (int32)(cw)
		h4232b35a := (int32)(ch)
		l2factor4232b35a := (int32)(cl2factor)
		var subarea4232b35a []Irect
		packSIrect(subarea4232b35a, csubarea)
		tuneImageDecodeFn4232B35AFunc(arg4232b35a, w4232b35a, h4232b35a, l2factor4232b35a, subarea4232b35a)
		return
	}
	panic("callback func has not been set (race?)")
}

var tuneImageDecodeFn4232B35AFunc TuneImageDecodeFn

func (x TuneImageScaleFn) PassRef() (ref *C.fz_tune_image_scale_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tuneImageScaleFn1989219Func == nil {
		tuneImageScaleFn1989219Func = x
	}
	return (*C.fz_tune_image_scale_fn)(C.fz_tune_image_scale_fn_1989219), nil
}

func NewTuneImageScaleFnRef(ref unsafe.Pointer) *TuneImageScaleFn {
	return (*TuneImageScaleFn)(ref)
}

//export tuneImageScaleFn1989219
func tuneImageScaleFn1989219(carg unsafe.Pointer, cdstW C.int, cdstH C.int, csrcW C.int, csrcH C.int) C.int {
	if tuneImageScaleFn1989219Func != nil {
		arg1989219 := (unsafe.Pointer)(unsafe.Pointer(carg))
		dstW1989219 := (int32)(cdstW)
		dstH1989219 := (int32)(cdstH)
		srcW1989219 := (int32)(csrcW)
		srcH1989219 := (int32)(csrcH)
		ret1989219 := tuneImageScaleFn1989219Func(arg1989219, dstW1989219, dstH1989219, srcW1989219, srcH1989219)
		ret, _ := (C.int)(ret1989219), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tuneImageScaleFn1989219Func TuneImageScaleFn

// allocPointMemory allocates memory for type C.fz_point in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPointMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPointValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPointValue = unsafe.Sizeof([1]C.fz_point{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Point) Ref() *C.fz_point {
	if x == nil {
		return nil
	}
	return x.refb7e1472b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Point) Free() {
	if x != nil && x.allocsb7e1472b != nil {
		x.allocsb7e1472b.(*cgoAllocMap).Free()
		x.refb7e1472b = nil
	}
}

// NewPointRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPointRef(ref unsafe.Pointer) *Point {
	if ref == nil {
		return nil
	}
	obj := new(Point)
	obj.refb7e1472b = (*C.fz_point)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Point) PassRef() (*C.fz_point, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb7e1472b != nil {
		return x.refb7e1472b, nil
	}
	memb7e1472b := allocPointMemory(1)
	refb7e1472b := (*C.fz_point)(memb7e1472b)
	allocsb7e1472b := new(cgoAllocMap)
	allocsb7e1472b.Add(memb7e1472b)

	var cx_allocs *cgoAllocMap
	refb7e1472b.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocsb7e1472b.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refb7e1472b.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocsb7e1472b.Borrow(cy_allocs)

	x.refb7e1472b = refb7e1472b
	x.allocsb7e1472b = allocsb7e1472b
	return refb7e1472b, allocsb7e1472b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Point) PassValue() (C.fz_point, *cgoAllocMap) {
	if x.refb7e1472b != nil {
		return *x.refb7e1472b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Point) Deref() {
	if x.refb7e1472b == nil {
		return
	}
	x.X = (float32)(x.refb7e1472b.x)
	x.Y = (float32)(x.refb7e1472b.y)
}

// allocRectMemory allocates memory for type C.fz_rect in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRectValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRectValue = unsafe.Sizeof([1]C.fz_rect{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Rect) Ref() *C.fz_rect {
	if x == nil {
		return nil
	}
	return x.reff3623c81
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Rect) Free() {
	if x != nil && x.allocsf3623c81 != nil {
		x.allocsf3623c81.(*cgoAllocMap).Free()
		x.reff3623c81 = nil
	}
}

// NewRectRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRectRef(ref unsafe.Pointer) *Rect {
	if ref == nil {
		return nil
	}
	obj := new(Rect)
	obj.reff3623c81 = (*C.fz_rect)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Rect) PassRef() (*C.fz_rect, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff3623c81 != nil {
		return x.reff3623c81, nil
	}
	memf3623c81 := allocRectMemory(1)
	reff3623c81 := (*C.fz_rect)(memf3623c81)
	allocsf3623c81 := new(cgoAllocMap)
	allocsf3623c81.Add(memf3623c81)

	var cx0_allocs *cgoAllocMap
	reff3623c81.x0, cx0_allocs = (C.float)(x.X0), cgoAllocsUnknown
	allocsf3623c81.Borrow(cx0_allocs)

	var cy0_allocs *cgoAllocMap
	reff3623c81.y0, cy0_allocs = (C.float)(x.Y0), cgoAllocsUnknown
	allocsf3623c81.Borrow(cy0_allocs)

	var cx1_allocs *cgoAllocMap
	reff3623c81.x1, cx1_allocs = (C.float)(x.X1), cgoAllocsUnknown
	allocsf3623c81.Borrow(cx1_allocs)

	var cy1_allocs *cgoAllocMap
	reff3623c81.y1, cy1_allocs = (C.float)(x.Y1), cgoAllocsUnknown
	allocsf3623c81.Borrow(cy1_allocs)

	x.reff3623c81 = reff3623c81
	x.allocsf3623c81 = allocsf3623c81
	return reff3623c81, allocsf3623c81

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Rect) PassValue() (C.fz_rect, *cgoAllocMap) {
	if x.reff3623c81 != nil {
		return *x.reff3623c81, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Rect) Deref() {
	if x.reff3623c81 == nil {
		return
	}
	x.X0 = (float32)(x.reff3623c81.x0)
	x.Y0 = (float32)(x.reff3623c81.y0)
	x.X1 = (float32)(x.reff3623c81.x1)
	x.Y1 = (float32)(x.reff3623c81.y1)
}

// allocIrectMemory allocates memory for type C.fz_irect in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIrectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIrectValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfIrectValue = unsafe.Sizeof([1]C.fz_irect{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Irect) Ref() *C.fz_irect {
	if x == nil {
		return nil
	}
	return x.refc4d6bab3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Irect) Free() {
	if x != nil && x.allocsc4d6bab3 != nil {
		x.allocsc4d6bab3.(*cgoAllocMap).Free()
		x.refc4d6bab3 = nil
	}
}

// NewIrectRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewIrectRef(ref unsafe.Pointer) *Irect {
	if ref == nil {
		return nil
	}
	obj := new(Irect)
	obj.refc4d6bab3 = (*C.fz_irect)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Irect) PassRef() (*C.fz_irect, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc4d6bab3 != nil {
		return x.refc4d6bab3, nil
	}
	memc4d6bab3 := allocIrectMemory(1)
	refc4d6bab3 := (*C.fz_irect)(memc4d6bab3)
	allocsc4d6bab3 := new(cgoAllocMap)
	allocsc4d6bab3.Add(memc4d6bab3)

	var cx0_allocs *cgoAllocMap
	refc4d6bab3.x0, cx0_allocs = (C.int)(x.X0), cgoAllocsUnknown
	allocsc4d6bab3.Borrow(cx0_allocs)

	var cy0_allocs *cgoAllocMap
	refc4d6bab3.y0, cy0_allocs = (C.int)(x.Y0), cgoAllocsUnknown
	allocsc4d6bab3.Borrow(cy0_allocs)

	var cx1_allocs *cgoAllocMap
	refc4d6bab3.x1, cx1_allocs = (C.int)(x.X1), cgoAllocsUnknown
	allocsc4d6bab3.Borrow(cx1_allocs)

	var cy1_allocs *cgoAllocMap
	refc4d6bab3.y1, cy1_allocs = (C.int)(x.Y1), cgoAllocsUnknown
	allocsc4d6bab3.Borrow(cy1_allocs)

	x.refc4d6bab3 = refc4d6bab3
	x.allocsc4d6bab3 = allocsc4d6bab3
	return refc4d6bab3, allocsc4d6bab3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Irect) PassValue() (C.fz_irect, *cgoAllocMap) {
	if x.refc4d6bab3 != nil {
		return *x.refc4d6bab3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Irect) Deref() {
	if x.refc4d6bab3 == nil {
		return
	}
	x.X0 = (int32)(x.refc4d6bab3.x0)
	x.Y0 = (int32)(x.refc4d6bab3.y0)
	x.X1 = (int32)(x.refc4d6bab3.x1)
	x.Y1 = (int32)(x.refc4d6bab3.y1)
}

// allocMatrixMemory allocates memory for type C.fz_matrix in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMatrixMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMatrixValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMatrixValue = unsafe.Sizeof([1]C.fz_matrix{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Matrix) Ref() *C.fz_matrix {
	if x == nil {
		return nil
	}
	return x.ref688c18ea
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Matrix) Free() {
	if x != nil && x.allocs688c18ea != nil {
		x.allocs688c18ea.(*cgoAllocMap).Free()
		x.ref688c18ea = nil
	}
}

// NewMatrixRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMatrixRef(ref unsafe.Pointer) *Matrix {
	if ref == nil {
		return nil
	}
	obj := new(Matrix)
	obj.ref688c18ea = (*C.fz_matrix)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Matrix) PassRef() (*C.fz_matrix, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref688c18ea != nil {
		return x.ref688c18ea, nil
	}
	mem688c18ea := allocMatrixMemory(1)
	ref688c18ea := (*C.fz_matrix)(mem688c18ea)
	allocs688c18ea := new(cgoAllocMap)
	allocs688c18ea.Add(mem688c18ea)

	var ca_allocs *cgoAllocMap
	ref688c18ea.a, ca_allocs = (C.float)(x.A), cgoAllocsUnknown
	allocs688c18ea.Borrow(ca_allocs)

	var cb_allocs *cgoAllocMap
	ref688c18ea.b, cb_allocs = (C.float)(x.B), cgoAllocsUnknown
	allocs688c18ea.Borrow(cb_allocs)

	var cc_allocs *cgoAllocMap
	ref688c18ea.c, cc_allocs = (C.float)(x.C), cgoAllocsUnknown
	allocs688c18ea.Borrow(cc_allocs)

	var cd_allocs *cgoAllocMap
	ref688c18ea.d, cd_allocs = (C.float)(x.D), cgoAllocsUnknown
	allocs688c18ea.Borrow(cd_allocs)

	var ce_allocs *cgoAllocMap
	ref688c18ea.e, ce_allocs = (C.float)(x.E), cgoAllocsUnknown
	allocs688c18ea.Borrow(ce_allocs)

	var cf_allocs *cgoAllocMap
	ref688c18ea.f, cf_allocs = (C.float)(x.F), cgoAllocsUnknown
	allocs688c18ea.Borrow(cf_allocs)

	x.ref688c18ea = ref688c18ea
	x.allocs688c18ea = allocs688c18ea
	return ref688c18ea, allocs688c18ea

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Matrix) PassValue() (C.fz_matrix, *cgoAllocMap) {
	if x.ref688c18ea != nil {
		return *x.ref688c18ea, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Matrix) Deref() {
	if x.ref688c18ea == nil {
		return
	}
	x.A = (float32)(x.ref688c18ea.a)
	x.B = (float32)(x.ref688c18ea.b)
	x.C = (float32)(x.ref688c18ea.c)
	x.D = (float32)(x.ref688c18ea.d)
	x.E = (float32)(x.ref688c18ea.e)
	x.F = (float32)(x.ref688c18ea.f)
}

// allocMd5Memory allocates memory for type C.fz_md5 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMd5Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMd5Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMd5Value = unsafe.Sizeof([1]C.fz_md5{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Md5) Ref() *C.fz_md5 {
	if x == nil {
		return nil
	}
	return x.ref584e988d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Md5) Free() {
	if x != nil && x.allocs584e988d != nil {
		x.allocs584e988d.(*cgoAllocMap).Free()
		x.ref584e988d = nil
	}
}

// NewMd5Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMd5Ref(ref unsafe.Pointer) *Md5 {
	if ref == nil {
		return nil
	}
	obj := new(Md5)
	obj.ref584e988d = (*C.fz_md5)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Md5) PassRef() (*C.fz_md5, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref584e988d != nil {
		return x.ref584e988d, nil
	}
	mem584e988d := allocMd5Memory(1)
	ref584e988d := (*C.fz_md5)(mem584e988d)
	allocs584e988d := new(cgoAllocMap)
	allocs584e988d.Add(mem584e988d)

	var cstate_allocs *cgoAllocMap
	ref584e988d.state, cstate_allocs = *(*[4]C.uint)(unsafe.Pointer(&x.State)), cgoAllocsUnknown
	allocs584e988d.Borrow(cstate_allocs)

	var ccount_allocs *cgoAllocMap
	ref584e988d.count, ccount_allocs = *(*[2]C.uint)(unsafe.Pointer(&x.Count)), cgoAllocsUnknown
	allocs584e988d.Borrow(ccount_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref584e988d.buffer, cbuffer_allocs = *(*[64]C.uchar)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs584e988d.Borrow(cbuffer_allocs)

	x.ref584e988d = ref584e988d
	x.allocs584e988d = allocs584e988d
	return ref584e988d, allocs584e988d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Md5) PassValue() (C.fz_md5, *cgoAllocMap) {
	if x.ref584e988d != nil {
		return *x.ref584e988d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Md5) Deref() {
	if x.ref584e988d == nil {
		return
	}
	x.State = *(*[4]uint32)(unsafe.Pointer(&x.ref584e988d.state))
	x.Count = *(*[2]uint32)(unsafe.Pointer(&x.ref584e988d.count))
	x.Buffer = *(*[64]byte)(unsafe.Pointer(&x.ref584e988d.buffer))
}

// allocSha256Memory allocates memory for type C.fz_sha256 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSha256Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSha256Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSha256Value = unsafe.Sizeof([1]C.fz_sha256{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Sha256) Ref() *C.fz_sha256 {
	if x == nil {
		return nil
	}
	return x.refcc774dd2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Sha256) Free() {
	if x != nil && x.allocscc774dd2 != nil {
		x.allocscc774dd2.(*cgoAllocMap).Free()
		x.refcc774dd2 = nil
	}
}

// NewSha256Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSha256Ref(ref unsafe.Pointer) *Sha256 {
	if ref == nil {
		return nil
	}
	obj := new(Sha256)
	obj.refcc774dd2 = (*C.fz_sha256)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Sha256) PassRef() (*C.fz_sha256, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcc774dd2 != nil {
		return x.refcc774dd2, nil
	}
	memcc774dd2 := allocSha256Memory(1)
	refcc774dd2 := (*C.fz_sha256)(memcc774dd2)
	allocscc774dd2 := new(cgoAllocMap)
	allocscc774dd2.Add(memcc774dd2)

	var cstate_allocs *cgoAllocMap
	refcc774dd2.state, cstate_allocs = *(*[8]C.uint)(unsafe.Pointer(&x.State)), cgoAllocsUnknown
	allocscc774dd2.Borrow(cstate_allocs)

	var ccount_allocs *cgoAllocMap
	refcc774dd2.count, ccount_allocs = *(*[2]C.uint)(unsafe.Pointer(&x.Count)), cgoAllocsUnknown
	allocscc774dd2.Borrow(ccount_allocs)

	x.refcc774dd2 = refcc774dd2
	x.allocscc774dd2 = allocscc774dd2
	return refcc774dd2, allocscc774dd2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Sha256) PassValue() (C.fz_sha256, *cgoAllocMap) {
	if x.refcc774dd2 != nil {
		return *x.refcc774dd2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Sha256) Deref() {
	if x.refcc774dd2 == nil {
		return
	}
	x.State = *(*[8]uint32)(unsafe.Pointer(&x.refcc774dd2.state))
	x.Count = *(*[2]uint32)(unsafe.Pointer(&x.refcc774dd2.count))
}

// allocSha512Memory allocates memory for type C.fz_sha512 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSha512Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSha512Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSha512Value = unsafe.Sizeof([1]C.fz_sha512{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Sha512) Ref() *C.fz_sha512 {
	if x == nil {
		return nil
	}
	return x.refaa395a4a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Sha512) Free() {
	if x != nil && x.allocsaa395a4a != nil {
		x.allocsaa395a4a.(*cgoAllocMap).Free()
		x.refaa395a4a = nil
	}
}

// NewSha512Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSha512Ref(ref unsafe.Pointer) *Sha512 {
	if ref == nil {
		return nil
	}
	obj := new(Sha512)
	obj.refaa395a4a = (*C.fz_sha512)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Sha512) PassRef() (*C.fz_sha512, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaa395a4a != nil {
		return x.refaa395a4a, nil
	}
	memaa395a4a := allocSha512Memory(1)
	refaa395a4a := (*C.fz_sha512)(memaa395a4a)
	allocsaa395a4a := new(cgoAllocMap)
	allocsaa395a4a.Add(memaa395a4a)

	var cstate_allocs *cgoAllocMap
	refaa395a4a.state, cstate_allocs = *(*[8]C.uint64_t)(unsafe.Pointer(&x.State)), cgoAllocsUnknown
	allocsaa395a4a.Borrow(cstate_allocs)

	var ccount_allocs *cgoAllocMap
	refaa395a4a.count, ccount_allocs = *(*[2]C.uint)(unsafe.Pointer(&x.Count)), cgoAllocsUnknown
	allocsaa395a4a.Borrow(ccount_allocs)

	x.refaa395a4a = refaa395a4a
	x.allocsaa395a4a = allocsaa395a4a
	return refaa395a4a, allocsaa395a4a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Sha512) PassValue() (C.fz_sha512, *cgoAllocMap) {
	if x.refaa395a4a != nil {
		return *x.refaa395a4a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Sha512) Deref() {
	if x.refaa395a4a == nil {
		return
	}
	x.State = *(*[8]uint64)(unsafe.Pointer(&x.refaa395a4a.state))
	x.Count = *(*[2]uint32)(unsafe.Pointer(&x.refaa395a4a.count))
}

// allocSha384Memory allocates memory for type C.fz_sha384 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSha384Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSha384Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSha384Value = unsafe.Sizeof([1]C.fz_sha384{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Sha384) Ref() *C.fz_sha384 {
	if x == nil {
		return nil
	}
	return x.ref96153884
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Sha384) Free() {
	if x != nil && x.allocs96153884 != nil {
		x.allocs96153884.(*cgoAllocMap).Free()
		x.ref96153884 = nil
	}
}

// NewSha384Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSha384Ref(ref unsafe.Pointer) *Sha384 {
	if ref == nil {
		return nil
	}
	obj := new(Sha384)
	obj.ref96153884 = (*C.fz_sha384)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Sha384) PassRef() (*C.fz_sha384, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref96153884 != nil {
		return x.ref96153884, nil
	}
	mem96153884 := allocSha384Memory(1)
	ref96153884 := (*C.fz_sha384)(mem96153884)
	allocs96153884 := new(cgoAllocMap)
	allocs96153884.Add(mem96153884)

	var cstate_allocs *cgoAllocMap
	ref96153884.state, cstate_allocs = *(*[8]C.uint64_t)(unsafe.Pointer(&x.State)), cgoAllocsUnknown
	allocs96153884.Borrow(cstate_allocs)

	var ccount_allocs *cgoAllocMap
	ref96153884.count, ccount_allocs = *(*[2]C.uint)(unsafe.Pointer(&x.Count)), cgoAllocsUnknown
	allocs96153884.Borrow(ccount_allocs)

	x.ref96153884 = ref96153884
	x.allocs96153884 = allocs96153884
	return ref96153884, allocs96153884

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Sha384) PassValue() (C.fz_sha384, *cgoAllocMap) {
	if x.ref96153884 != nil {
		return *x.ref96153884, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Sha384) Deref() {
	if x.ref96153884 == nil {
		return
	}
	x.State = *(*[8]uint64)(unsafe.Pointer(&x.ref96153884.state))
	x.Count = *(*[2]uint32)(unsafe.Pointer(&x.ref96153884.count))
}

// allocArc4Memory allocates memory for type C.fz_arc4 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocArc4Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfArc4Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfArc4Value = unsafe.Sizeof([1]C.fz_arc4{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Arc4) Ref() *C.fz_arc4 {
	if x == nil {
		return nil
	}
	return x.refde7b3095
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Arc4) Free() {
	if x != nil && x.allocsde7b3095 != nil {
		x.allocsde7b3095.(*cgoAllocMap).Free()
		x.refde7b3095 = nil
	}
}

// NewArc4Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewArc4Ref(ref unsafe.Pointer) *Arc4 {
	if ref == nil {
		return nil
	}
	obj := new(Arc4)
	obj.refde7b3095 = (*C.fz_arc4)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Arc4) PassRef() (*C.fz_arc4, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refde7b3095 != nil {
		return x.refde7b3095, nil
	}
	memde7b3095 := allocArc4Memory(1)
	refde7b3095 := (*C.fz_arc4)(memde7b3095)
	allocsde7b3095 := new(cgoAllocMap)
	allocsde7b3095.Add(memde7b3095)

	var cx_allocs *cgoAllocMap
	refde7b3095.x, cx_allocs = (C.uint)(x.X), cgoAllocsUnknown
	allocsde7b3095.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refde7b3095.y, cy_allocs = (C.uint)(x.Y), cgoAllocsUnknown
	allocsde7b3095.Borrow(cy_allocs)

	var cstate_allocs *cgoAllocMap
	refde7b3095.state, cstate_allocs = *(*[256]C.uchar)(unsafe.Pointer(&x.State)), cgoAllocsUnknown
	allocsde7b3095.Borrow(cstate_allocs)

	x.refde7b3095 = refde7b3095
	x.allocsde7b3095 = allocsde7b3095
	return refde7b3095, allocsde7b3095

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Arc4) PassValue() (C.fz_arc4, *cgoAllocMap) {
	if x.refde7b3095 != nil {
		return *x.refde7b3095, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Arc4) Deref() {
	if x.refde7b3095 == nil {
		return
	}
	x.X = (uint32)(x.refde7b3095.x)
	x.Y = (uint32)(x.refde7b3095.y)
	x.State = *(*[256]byte)(unsafe.Pointer(&x.refde7b3095.state))
}

// allocAesMemory allocates memory for type C.fz_aes in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAesValue = unsafe.Sizeof([1]C.fz_aes{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Aes) Ref() *C.fz_aes {
	if x == nil {
		return nil
	}
	return x.refd7f0b40d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Aes) Free() {
	if x != nil && x.allocsd7f0b40d != nil {
		x.allocsd7f0b40d.(*cgoAllocMap).Free()
		x.refd7f0b40d = nil
	}
}

// NewAesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAesRef(ref unsafe.Pointer) *Aes {
	if ref == nil {
		return nil
	}
	obj := new(Aes)
	obj.refd7f0b40d = (*C.fz_aes)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Aes) PassRef() (*C.fz_aes, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd7f0b40d != nil {
		return x.refd7f0b40d, nil
	}
	memd7f0b40d := allocAesMemory(1)
	refd7f0b40d := (*C.fz_aes)(memd7f0b40d)
	allocsd7f0b40d := new(cgoAllocMap)
	allocsd7f0b40d.Add(memd7f0b40d)

	var cnr_allocs *cgoAllocMap
	refd7f0b40d.nr, cnr_allocs = (C.int)(x.Nr), cgoAllocsUnknown
	allocsd7f0b40d.Borrow(cnr_allocs)

	var crk_allocs *cgoAllocMap
	refd7f0b40d.rk, crk_allocs = (*C.ulong)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Rk)).Data)), cgoAllocsUnknown
	allocsd7f0b40d.Borrow(crk_allocs)

	var cbuf_allocs *cgoAllocMap
	refd7f0b40d.buf, cbuf_allocs = *(*[68]C.ulong)(unsafe.Pointer(&x.Buf)), cgoAllocsUnknown
	allocsd7f0b40d.Borrow(cbuf_allocs)

	x.refd7f0b40d = refd7f0b40d
	x.allocsd7f0b40d = allocsd7f0b40d
	return refd7f0b40d, allocsd7f0b40d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Aes) PassValue() (C.fz_aes, *cgoAllocMap) {
	if x.refd7f0b40d != nil {
		return *x.refd7f0b40d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Aes) Deref() {
	if x.refd7f0b40d == nil {
		return
	}
	x.Nr = (int32)(x.refd7f0b40d.nr)
	hxf7a6dff := (*sliceHeader)(unsafe.Pointer(&x.Rk))
	hxf7a6dff.Data = uintptr(unsafe.Pointer(x.refd7f0b40d.rk))
	hxf7a6dff.Cap = 0x7fffffff
	// hxf7a6dff.Len = ?

	x.Buf = *(*[68]uint)(unsafe.Pointer(&x.refd7f0b40d.buf))
}

// Ref returns a reference to C object as it is.
func (x *HashTable) Ref() *C.fz_hash_table {
	if x == nil {
		return nil
	}
	return (*C.fz_hash_table)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *HashTable) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewHashTableRef converts the C object reference into a raw struct reference without wrapping.
func NewHashTableRef(ref unsafe.Pointer) *HashTable {
	return (*HashTable)(ref)
}

// NewHashTable allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewHashTable() *HashTable {
	return (*HashTable)(allocHashTableMemory(1))
}

// allocHashTableMemory allocates memory for type C.fz_hash_table in C.
// The caller is responsible for freeing the this memory via C.free.
func allocHashTableMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfHashTableValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfHashTableValue = unsafe.Sizeof([1]C.fz_hash_table{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *HashTable) PassRef() *C.fz_hash_table {
	if x == nil {
		x = (*HashTable)(allocHashTableMemory(1))
	}
	return (*C.fz_hash_table)(unsafe.Pointer(x))
}

// packSContext reads sliced Go data structure out from plain C format.
func packSContext(v []Context, ptr0 *C.fz_context) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfContextValue]C.fz_context)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewContextRef(unsafe.Pointer(&ptr1))
	}
}

func (x HashTableDropFn) PassRef() (ref *C.fz_hash_table_drop_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if hashTableDropFn7865AC47Func == nil {
		hashTableDropFn7865AC47Func = x
	}
	return (*C.fz_hash_table_drop_fn)(C.fz_hash_table_drop_fn_7865ac47), nil
}

func NewHashTableDropFnRef(ref unsafe.Pointer) *HashTableDropFn {
	return (*HashTableDropFn)(ref)
}

//export hashTableDropFn7865AC47
func hashTableDropFn7865AC47(cctx *C.fz_context, cval unsafe.Pointer) {
	if hashTableDropFn7865AC47Func != nil {
		var ctx7865ac47 []Context
		packSContext(ctx7865ac47, cctx)
		val7865ac47 := (unsafe.Pointer)(unsafe.Pointer(cval))
		hashTableDropFn7865AC47Func(ctx7865ac47, val7865ac47)
		return
	}
	panic("callback func has not been set (race?)")
}

var hashTableDropFn7865AC47Func HashTableDropFn

func (x HashTableForEachFn) PassRef() (ref *C.fz_hash_table_for_each_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if hashTableForEachFnAF0D233FFunc == nil {
		hashTableForEachFnAF0D233FFunc = x
	}
	return (*C.fz_hash_table_for_each_fn)(C.fz_hash_table_for_each_fn_af0d233f), nil
}

func NewHashTableForEachFnRef(ref unsafe.Pointer) *HashTableForEachFn {
	return (*HashTableForEachFn)(ref)
}

//export hashTableForEachFnAF0D233F
func hashTableForEachFnAF0D233F(cctx *C.fz_context, cstate unsafe.Pointer, ckey unsafe.Pointer, ckeylen C.int, cval unsafe.Pointer) {
	if hashTableForEachFnAF0D233FFunc != nil {
		var ctxaf0d233f []Context
		packSContext(ctxaf0d233f, cctx)
		stateaf0d233f := (unsafe.Pointer)(unsafe.Pointer(cstate))
		keyaf0d233f := (unsafe.Pointer)(unsafe.Pointer(ckey))
		keylenaf0d233f := (int32)(ckeylen)
		valaf0d233f := (unsafe.Pointer)(unsafe.Pointer(cval))
		hashTableForEachFnAF0D233FFunc(ctxaf0d233f, stateaf0d233f, keyaf0d233f, keylenaf0d233f, valaf0d233f)
		return
	}
	panic("callback func has not been set (race?)")
}

var hashTableForEachFnAF0D233FFunc HashTableForEachFn

// allocOutputMemory allocates memory for type C.fz_output in C.
// The caller is responsible for freeing the this memory via C.free.
func allocOutputMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfOutputValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfOutputValue = unsafe.Sizeof([1]C.fz_output{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Output) Ref() *C.fz_output {
	if x == nil {
		return nil
	}
	return x.ref5c614dbb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Output) Free() {
	if x != nil && x.allocs5c614dbb != nil {
		x.allocs5c614dbb.(*cgoAllocMap).Free()
		x.ref5c614dbb = nil
	}
}

// NewOutputRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewOutputRef(ref unsafe.Pointer) *Output {
	if ref == nil {
		return nil
	}
	obj := new(Output)
	obj.ref5c614dbb = (*C.fz_output)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Output) PassRef() (*C.fz_output, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5c614dbb != nil {
		return x.ref5c614dbb, nil
	}
	mem5c614dbb := allocOutputMemory(1)
	ref5c614dbb := (*C.fz_output)(mem5c614dbb)
	allocs5c614dbb := new(cgoAllocMap)
	allocs5c614dbb.Add(mem5c614dbb)

	var cstate_allocs *cgoAllocMap
	ref5c614dbb.state, cstate_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.State)), cgoAllocsUnknown
	allocs5c614dbb.Borrow(cstate_allocs)

	var cwrite_allocs *cgoAllocMap
	ref5c614dbb.write, cwrite_allocs = x.Write.PassRef()
	allocs5c614dbb.Borrow(cwrite_allocs)

	var cseek_allocs *cgoAllocMap
	ref5c614dbb.seek, cseek_allocs = x.Seek.PassRef()
	allocs5c614dbb.Borrow(cseek_allocs)

	var ctell_allocs *cgoAllocMap
	ref5c614dbb.tell, ctell_allocs = x.Tell.PassRef()
	allocs5c614dbb.Borrow(ctell_allocs)

	var cclose_allocs *cgoAllocMap
	ref5c614dbb.close, cclose_allocs = x.Close.PassRef()
	allocs5c614dbb.Borrow(cclose_allocs)

	x.ref5c614dbb = ref5c614dbb
	x.allocs5c614dbb = allocs5c614dbb
	return ref5c614dbb, allocs5c614dbb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Output) PassValue() (C.fz_output, *cgoAllocMap) {
	if x.ref5c614dbb != nil {
		return *x.ref5c614dbb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Output) Deref() {
	if x.ref5c614dbb == nil {
		return
	}
	x.State = (unsafe.Pointer)(unsafe.Pointer(x.ref5c614dbb.state))
	x.Write = NewOutputWriteFnRef(unsafe.Pointer(x.ref5c614dbb.write))
	x.Seek = NewOutputSeekFnRef(unsafe.Pointer(x.ref5c614dbb.seek))
	x.Tell = NewOutputTellFnRef(unsafe.Pointer(x.ref5c614dbb.tell))
	x.Close = NewOutputCloseFnRef(unsafe.Pointer(x.ref5c614dbb.close))
}

func (x OutputWriteFn) PassRef() (ref *C.fz_output_write_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if outputWriteFn69B8337CFunc == nil {
		outputWriteFn69B8337CFunc = x
	}
	return (*C.fz_output_write_fn)(C.fz_output_write_fn_69b8337c), nil
}

func NewOutputWriteFnRef(ref unsafe.Pointer) *OutputWriteFn {
	return (*OutputWriteFn)(ref)
}

//export outputWriteFn69B8337C
func outputWriteFn69B8337C(cctx *C.fz_context, cstate unsafe.Pointer, cdata unsafe.Pointer, cn C.size_t) {
	if outputWriteFn69B8337CFunc != nil {
		var ctx69b8337c []Context
		packSContext(ctx69b8337c, cctx)
		state69b8337c := (unsafe.Pointer)(unsafe.Pointer(cstate))
		data69b8337c := (unsafe.Pointer)(unsafe.Pointer(cdata))
		n69b8337c := (uint)(cn)
		outputWriteFn69B8337CFunc(ctx69b8337c, state69b8337c, data69b8337c, n69b8337c)
		return
	}
	panic("callback func has not been set (race?)")
}

var outputWriteFn69B8337CFunc OutputWriteFn

func (x OutputSeekFn) PassRef() (ref *C.fz_output_seek_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if outputSeekFnBF2E2BEDFunc == nil {
		outputSeekFnBF2E2BEDFunc = x
	}
	return (*C.fz_output_seek_fn)(C.fz_output_seek_fn_bf2e2bed), nil
}

func NewOutputSeekFnRef(ref unsafe.Pointer) *OutputSeekFn {
	return (*OutputSeekFn)(ref)
}

//export outputSeekFnBF2E2BED
func outputSeekFnBF2E2BED(cctx *C.fz_context, cstate unsafe.Pointer, coffset C.fz_off_t, cwhence C.int) {
	if outputSeekFnBF2E2BEDFunc != nil {
		var ctxbf2e2bed []Context
		packSContext(ctxbf2e2bed, cctx)
		statebf2e2bed := (unsafe.Pointer)(unsafe.Pointer(cstate))
		offsetbf2e2bed := (Off)(coffset)
		whencebf2e2bed := (int32)(cwhence)
		outputSeekFnBF2E2BEDFunc(ctxbf2e2bed, statebf2e2bed, offsetbf2e2bed, whencebf2e2bed)
		return
	}
	panic("callback func has not been set (race?)")
}

var outputSeekFnBF2E2BEDFunc OutputSeekFn

func (x OutputTellFn) PassRef() (ref *C.fz_output_tell_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if outputTellFnEA4E4FABFunc == nil {
		outputTellFnEA4E4FABFunc = x
	}
	return (*C.fz_output_tell_fn)(C.fz_output_tell_fn_ea4e4fab), nil
}

func NewOutputTellFnRef(ref unsafe.Pointer) *OutputTellFn {
	return (*OutputTellFn)(ref)
}

//export outputTellFnEA4E4FAB
func outputTellFnEA4E4FAB(cctx *C.fz_context, cstate unsafe.Pointer) C.fz_off_t {
	if outputTellFnEA4E4FABFunc != nil {
		var ctxea4e4fab []Context
		packSContext(ctxea4e4fab, cctx)
		stateea4e4fab := (unsafe.Pointer)(unsafe.Pointer(cstate))
		retea4e4fab := outputTellFnEA4E4FABFunc(ctxea4e4fab, stateea4e4fab)
		ret, _ := (C.fz_off_t)(retea4e4fab), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var outputTellFnEA4E4FABFunc OutputTellFn

func (x OutputCloseFn) PassRef() (ref *C.fz_output_close_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if outputCloseFnC2D1D433Func == nil {
		outputCloseFnC2D1D433Func = x
	}
	return (*C.fz_output_close_fn)(C.fz_output_close_fn_c2d1d433), nil
}

func NewOutputCloseFnRef(ref unsafe.Pointer) *OutputCloseFn {
	return (*OutputCloseFn)(ref)
}

//export outputCloseFnC2D1D433
func outputCloseFnC2D1D433(cctx *C.fz_context, cstate unsafe.Pointer) {
	if outputCloseFnC2D1D433Func != nil {
		var ctxc2d1d433 []Context
		packSContext(ctxc2d1d433, cctx)
		statec2d1d433 := (unsafe.Pointer)(unsafe.Pointer(cstate))
		outputCloseFnC2D1D433Func(ctxc2d1d433, statec2d1d433)
		return
	}
	panic("callback func has not been set (race?)")
}

var outputCloseFnC2D1D433Func OutputCloseFn

// Ref returns a reference to C object as it is.
func (x *Buffer) Ref() *C.fz_buffer {
	if x == nil {
		return nil
	}
	return (*C.fz_buffer)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Buffer) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewBufferRef converts the C object reference into a raw struct reference without wrapping.
func NewBufferRef(ref unsafe.Pointer) *Buffer {
	return (*Buffer)(ref)
}

// NewBuffer allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewBuffer() *Buffer {
	return (*Buffer)(allocBufferMemory(1))
}

// allocBufferMemory allocates memory for type C.fz_buffer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBufferValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBufferValue = unsafe.Sizeof([1]C.fz_buffer{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Buffer) PassRef() *C.fz_buffer {
	if x == nil {
		x = (*Buffer)(allocBufferMemory(1))
	}
	return (*C.fz_buffer)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Pool) Ref() *C.fz_pool {
	if x == nil {
		return nil
	}
	return (*C.fz_pool)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Pool) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPoolRef converts the C object reference into a raw struct reference without wrapping.
func NewPoolRef(ref unsafe.Pointer) *Pool {
	return (*Pool)(ref)
}

// NewPool allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPool() *Pool {
	return (*Pool)(allocPoolMemory(1))
}

// allocPoolMemory allocates memory for type C.fz_pool in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPoolMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPoolValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPoolValue = unsafe.Sizeof([1]C.fz_pool{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Pool) PassRef() *C.fz_pool {
	if x == nil {
		x = (*Pool)(allocPoolMemory(1))
	}
	return (*C.fz_pool)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tree) Ref() *C.fz_tree {
	if x == nil {
		return nil
	}
	return (*C.fz_tree)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tree) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTreeRef converts the C object reference into a raw struct reference without wrapping.
func NewTreeRef(ref unsafe.Pointer) *Tree {
	return (*Tree)(ref)
}

// NewTree allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTree() *Tree {
	return (*Tree)(allocTreeMemory(1))
}

// allocTreeMemory allocates memory for type C.fz_tree in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTreeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTreeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTreeValue = unsafe.Sizeof([1]C.fz_tree{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tree) PassRef() *C.fz_tree {
	if x == nil {
		x = (*Tree)(allocTreeMemory(1))
	}
	return (*C.fz_tree)(unsafe.Pointer(x))
}

func (x BidiFragmentFn) PassRef() (ref *C.fz_bidi_fragment_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if bidiFragmentFnF6D4B809Func == nil {
		bidiFragmentFnF6D4B809Func = x
	}
	return (*C.fz_bidi_fragment_fn)(C.fz_bidi_fragment_fn_f6d4b809), nil
}

func NewBidiFragmentFnRef(ref unsafe.Pointer) *BidiFragmentFn {
	return (*BidiFragmentFn)(ref)
}

//export bidiFragmentFnF6D4B809
func bidiFragmentFnF6D4B809(cfragment *C.uint32_t, cfragmentlen C.size_t, cbidilevel C.int, cscript C.int, carg unsafe.Pointer) {
	if bidiFragmentFnF6D4B809Func != nil {
		var fragmentf6d4b809 []uint32
		hxfe48d67 := (*sliceHeader)(unsafe.Pointer(&fragmentf6d4b809))
		hxfe48d67.Data = uintptr(unsafe.Pointer(cfragment))
		hxfe48d67.Cap = 0x7fffffff
		// hxfe48d67.Len = ?

		fragmentlenf6d4b809 := (uint)(cfragmentlen)
		bidilevelf6d4b809 := (int32)(cbidilevel)
		scriptf6d4b809 := (int32)(cscript)
		argf6d4b809 := (unsafe.Pointer)(unsafe.Pointer(carg))
		bidiFragmentFnF6D4B809Func(fragmentf6d4b809, fragmentlenf6d4b809, bidilevelf6d4b809, scriptf6d4b809, argf6d4b809)
		return
	}
	panic("callback func has not been set (race?)")
}

var bidiFragmentFnF6D4B809Func BidiFragmentFn

// Ref returns a reference to C object as it is.
func (x *Xml) Ref() *C.fz_xml {
	if x == nil {
		return nil
	}
	return (*C.fz_xml)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Xml) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewXmlRef converts the C object reference into a raw struct reference without wrapping.
func NewXmlRef(ref unsafe.Pointer) *Xml {
	return (*Xml)(ref)
}

// NewXml allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewXml() *Xml {
	return (*Xml)(allocXmlMemory(1))
}

// allocXmlMemory allocates memory for type C.fz_xml in C.
// The caller is responsible for freeing the this memory via C.free.
func allocXmlMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfXmlValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfXmlValue = unsafe.Sizeof([1]C.fz_xml{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Xml) PassRef() *C.fz_xml {
	if x == nil {
		x = (*Xml)(allocXmlMemory(1))
	}
	return (*C.fz_xml)(unsafe.Pointer(x))
}

// allocStreamMemory allocates memory for type C.fz_stream in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStreamMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStreamValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStreamValue = unsafe.Sizeof([1]C.fz_stream{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Stream) Ref() *C.fz_stream {
	if x == nil {
		return nil
	}
	return x.ref6056e739
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Stream) Free() {
	if x != nil && x.allocs6056e739 != nil {
		x.allocs6056e739.(*cgoAllocMap).Free()
		x.ref6056e739 = nil
	}
}

// NewStreamRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStreamRef(ref unsafe.Pointer) *Stream {
	if ref == nil {
		return nil
	}
	obj := new(Stream)
	obj.ref6056e739 = (*C.fz_stream)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Stream) PassRef() (*C.fz_stream, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6056e739 != nil {
		return x.ref6056e739, nil
	}
	mem6056e739 := allocStreamMemory(1)
	ref6056e739 := (*C.fz_stream)(mem6056e739)
	allocs6056e739 := new(cgoAllocMap)
	allocs6056e739.Add(mem6056e739)

	var crefs_allocs *cgoAllocMap
	ref6056e739.refs, crefs_allocs = (C.int)(x.Refs), cgoAllocsUnknown
	allocs6056e739.Borrow(crefs_allocs)

	var cerror_allocs *cgoAllocMap
	ref6056e739.error, cerror_allocs = (C.int)(x.Error), cgoAllocsUnknown
	allocs6056e739.Borrow(cerror_allocs)

	var ceof_allocs *cgoAllocMap
	ref6056e739.eof, ceof_allocs = (C.int)(x.Eof), cgoAllocsUnknown
	allocs6056e739.Borrow(ceof_allocs)

	var cpos_allocs *cgoAllocMap
	ref6056e739.pos, cpos_allocs = (C.fz_off_t)(x.Pos), cgoAllocsUnknown
	allocs6056e739.Borrow(cpos_allocs)

	var cavail_allocs *cgoAllocMap
	ref6056e739.avail, cavail_allocs = (C.int)(x.Avail), cgoAllocsUnknown
	allocs6056e739.Borrow(cavail_allocs)

	var cbits_allocs *cgoAllocMap
	ref6056e739.bits, cbits_allocs = (C.int)(x.Bits), cgoAllocsUnknown
	allocs6056e739.Borrow(cbits_allocs)

	var crp_allocs *cgoAllocMap
	ref6056e739.rp, crp_allocs = (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Rp)).Data)), cgoAllocsUnknown
	allocs6056e739.Borrow(crp_allocs)

	var cwp_allocs *cgoAllocMap
	ref6056e739.wp, cwp_allocs = (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Wp)).Data)), cgoAllocsUnknown
	allocs6056e739.Borrow(cwp_allocs)

	var cstate_allocs *cgoAllocMap
	ref6056e739.state, cstate_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.State)), cgoAllocsUnknown
	allocs6056e739.Borrow(cstate_allocs)

	var cnext_allocs *cgoAllocMap
	ref6056e739.next, cnext_allocs = x.Next.PassRef()
	allocs6056e739.Borrow(cnext_allocs)

	var cclose_allocs *cgoAllocMap
	ref6056e739.close, cclose_allocs = x.Close.PassRef()
	allocs6056e739.Borrow(cclose_allocs)

	var cseek_allocs *cgoAllocMap
	ref6056e739.seek, cseek_allocs = x.Seek.PassRef()
	allocs6056e739.Borrow(cseek_allocs)

	var cmeta_allocs *cgoAllocMap
	ref6056e739.meta, cmeta_allocs = x.Meta.PassRef()
	allocs6056e739.Borrow(cmeta_allocs)

	x.ref6056e739 = ref6056e739
	x.allocs6056e739 = allocs6056e739
	return ref6056e739, allocs6056e739

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Stream) PassValue() (C.fz_stream, *cgoAllocMap) {
	if x.ref6056e739 != nil {
		return *x.ref6056e739, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Stream) Deref() {
	if x.ref6056e739 == nil {
		return
	}
	x.Refs = (int32)(x.ref6056e739.refs)
	x.Error = (int32)(x.ref6056e739.error)
	x.Eof = (int32)(x.ref6056e739.eof)
	x.Pos = (Off)(x.ref6056e739.pos)
	x.Avail = (int32)(x.ref6056e739.avail)
	x.Bits = (int32)(x.ref6056e739.bits)
	hxf4171bf := (*sliceHeader)(unsafe.Pointer(&x.Rp))
	hxf4171bf.Data = uintptr(unsafe.Pointer(x.ref6056e739.rp))
	hxf4171bf.Cap = 0x7fffffff
	// hxf4171bf.Len = ?

	hxf058b18 := (*sliceHeader)(unsafe.Pointer(&x.Wp))
	hxf058b18.Data = uintptr(unsafe.Pointer(x.ref6056e739.wp))
	hxf058b18.Cap = 0x7fffffff
	// hxf058b18.Len = ?

	x.State = (unsafe.Pointer)(unsafe.Pointer(x.ref6056e739.state))
	x.Next = NewStreamNextFnRef(unsafe.Pointer(x.ref6056e739.next))
	x.Close = NewStreamCloseFnRef(unsafe.Pointer(x.ref6056e739.close))
	x.Seek = NewStreamSeekFnRef(unsafe.Pointer(x.ref6056e739.seek))
	x.Meta = NewStreamMetaFnRef(unsafe.Pointer(x.ref6056e739.meta))
}

// packSStream reads sliced Go data structure out from plain C format.
func packSStream(v []Stream, ptr0 *C.fz_stream) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStreamValue]C.fz_stream)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewStreamRef(unsafe.Pointer(&ptr1))
	}
}

func (x StreamNextFn) PassRef() (ref *C.fz_stream_next_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if streamNextFnA646AE0CFunc == nil {
		streamNextFnA646AE0CFunc = x
	}
	return (*C.fz_stream_next_fn)(C.fz_stream_next_fn_a646ae0c), nil
}

func NewStreamNextFnRef(ref unsafe.Pointer) *StreamNextFn {
	return (*StreamNextFn)(ref)
}

//export streamNextFnA646AE0C
func streamNextFnA646AE0C(cctx *C.fz_context, cstm *C.fz_stream, cmax C.size_t) C.int {
	if streamNextFnA646AE0CFunc != nil {
		var ctxa646ae0c []Context
		packSContext(ctxa646ae0c, cctx)
		var stma646ae0c []Stream
		packSStream(stma646ae0c, cstm)
		maxa646ae0c := (uint)(cmax)
		reta646ae0c := streamNextFnA646AE0CFunc(ctxa646ae0c, stma646ae0c, maxa646ae0c)
		ret, _ := (C.int)(reta646ae0c), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var streamNextFnA646AE0CFunc StreamNextFn

func (x StreamCloseFn) PassRef() (ref *C.fz_stream_close_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if streamCloseFnAF835BB4Func == nil {
		streamCloseFnAF835BB4Func = x
	}
	return (*C.fz_stream_close_fn)(C.fz_stream_close_fn_af835bb4), nil
}

func NewStreamCloseFnRef(ref unsafe.Pointer) *StreamCloseFn {
	return (*StreamCloseFn)(ref)
}

//export streamCloseFnAF835BB4
func streamCloseFnAF835BB4(cctx *C.fz_context, cstate unsafe.Pointer) {
	if streamCloseFnAF835BB4Func != nil {
		var ctxaf835bb4 []Context
		packSContext(ctxaf835bb4, cctx)
		stateaf835bb4 := (unsafe.Pointer)(unsafe.Pointer(cstate))
		streamCloseFnAF835BB4Func(ctxaf835bb4, stateaf835bb4)
		return
	}
	panic("callback func has not been set (race?)")
}

var streamCloseFnAF835BB4Func StreamCloseFn

func (x StreamSeekFn) PassRef() (ref *C.fz_stream_seek_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if streamSeekFn304547F8Func == nil {
		streamSeekFn304547F8Func = x
	}
	return (*C.fz_stream_seek_fn)(C.fz_stream_seek_fn_304547f8), nil
}

func NewStreamSeekFnRef(ref unsafe.Pointer) *StreamSeekFn {
	return (*StreamSeekFn)(ref)
}

//export streamSeekFn304547F8
func streamSeekFn304547F8(cctx *C.fz_context, cstm *C.fz_stream, coffset C.fz_off_t, cwhence C.int) {
	if streamSeekFn304547F8Func != nil {
		var ctx304547f8 []Context
		packSContext(ctx304547f8, cctx)
		var stm304547f8 []Stream
		packSStream(stm304547f8, cstm)
		offset304547f8 := (Off)(coffset)
		whence304547f8 := (int32)(cwhence)
		streamSeekFn304547F8Func(ctx304547f8, stm304547f8, offset304547f8, whence304547f8)
		return
	}
	panic("callback func has not been set (race?)")
}

var streamSeekFn304547F8Func StreamSeekFn

func (x StreamMetaFn) PassRef() (ref *C.fz_stream_meta_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if streamMetaFn3599FE3DFunc == nil {
		streamMetaFn3599FE3DFunc = x
	}
	return (*C.fz_stream_meta_fn)(C.fz_stream_meta_fn_3599fe3d), nil
}

func NewStreamMetaFnRef(ref unsafe.Pointer) *StreamMetaFn {
	return (*StreamMetaFn)(ref)
}

//export streamMetaFn3599FE3D
func streamMetaFn3599FE3D(cctx *C.fz_context, cstm *C.fz_stream, ckey C.int, csize C.int, cptr unsafe.Pointer) C.int {
	if streamMetaFn3599FE3DFunc != nil {
		var ctx3599fe3d []Context
		packSContext(ctx3599fe3d, cctx)
		var stm3599fe3d []Stream
		packSStream(stm3599fe3d, cstm)
		key3599fe3d := (int32)(ckey)
		size3599fe3d := (int32)(csize)
		ptr3599fe3d := (unsafe.Pointer)(unsafe.Pointer(cptr))
		ret3599fe3d := streamMetaFn3599FE3DFunc(ctx3599fe3d, stm3599fe3d, key3599fe3d, size3599fe3d, ptr3599fe3d)
		ret, _ := (C.int)(ret3599fe3d), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var streamMetaFn3599FE3DFunc StreamMetaFn

// allocCompressionParamsMemory allocates memory for type C.fz_compression_params in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCompressionParamsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCompressionParamsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCompressionParamsValue = unsafe.Sizeof([1]C.fz_compression_params{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CompressionParams) Ref() *C.fz_compression_params {
	if x == nil {
		return nil
	}
	return x.ref737eea0e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CompressionParams) Free() {
	if x != nil && x.allocs737eea0e != nil {
		x.allocs737eea0e.(*cgoAllocMap).Free()
		x.ref737eea0e = nil
	}
}

// NewCompressionParamsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCompressionParamsRef(ref unsafe.Pointer) *CompressionParams {
	if ref == nil {
		return nil
	}
	obj := new(CompressionParams)
	obj.ref737eea0e = (*C.fz_compression_params)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CompressionParams) PassRef() (*C.fz_compression_params, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref737eea0e != nil {
		return x.ref737eea0e, nil
	}
	mem737eea0e := allocCompressionParamsMemory(1)
	ref737eea0e := (*C.fz_compression_params)(mem737eea0e)
	allocs737eea0e := new(cgoAllocMap)
	allocs737eea0e.Add(mem737eea0e)

	var c_type_allocs *cgoAllocMap
	ref737eea0e._type, c_type_allocs = (C.int)(x.Type), cgoAllocsUnknown
	allocs737eea0e.Borrow(c_type_allocs)

	x.ref737eea0e = ref737eea0e
	x.allocs737eea0e = allocs737eea0e
	return ref737eea0e, allocs737eea0e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CompressionParams) PassValue() (C.fz_compression_params, *cgoAllocMap) {
	if x.ref737eea0e != nil {
		return *x.ref737eea0e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CompressionParams) Deref() {
	if x.ref737eea0e == nil {
		return
	}
	x.Type = (int32)(x.ref737eea0e._type)
}

// allocCompressedBufferMemory allocates memory for type C.fz_compressed_buffer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCompressedBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCompressedBufferValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCompressedBufferValue = unsafe.Sizeof([1]C.fz_compressed_buffer{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CompressedBuffer) Ref() *C.fz_compressed_buffer {
	if x == nil {
		return nil
	}
	return x.ref744dc91
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CompressedBuffer) Free() {
	if x != nil && x.allocs744dc91 != nil {
		x.allocs744dc91.(*cgoAllocMap).Free()
		x.ref744dc91 = nil
	}
}

// NewCompressedBufferRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCompressedBufferRef(ref unsafe.Pointer) *CompressedBuffer {
	if ref == nil {
		return nil
	}
	obj := new(CompressedBuffer)
	obj.ref744dc91 = (*C.fz_compressed_buffer)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CompressedBuffer) PassRef() (*C.fz_compressed_buffer, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref744dc91 != nil {
		return x.ref744dc91, nil
	}
	mem744dc91 := allocCompressedBufferMemory(1)
	ref744dc91 := (*C.fz_compressed_buffer)(mem744dc91)
	allocs744dc91 := new(cgoAllocMap)
	allocs744dc91.Add(mem744dc91)

	var cparams_allocs *cgoAllocMap
	ref744dc91.params, cparams_allocs = x.Params.PassValue()
	allocs744dc91.Borrow(cparams_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref744dc91.buffer, cbuffer_allocs = (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Buffer)).Data)), cgoAllocsUnknown
	allocs744dc91.Borrow(cbuffer_allocs)

	x.ref744dc91 = ref744dc91
	x.allocs744dc91 = allocs744dc91
	return ref744dc91, allocs744dc91

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CompressedBuffer) PassValue() (C.fz_compressed_buffer, *cgoAllocMap) {
	if x.ref744dc91 != nil {
		return *x.ref744dc91, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CompressedBuffer) Deref() {
	if x.ref744dc91 == nil {
		return
	}
	x.Params = *NewCompressionParamsRef(unsafe.Pointer(&x.ref744dc91.params))
	hxff6bc57 := (*sliceHeader)(unsafe.Pointer(&x.Buffer))
	hxff6bc57.Data = uintptr(unsafe.Pointer(x.ref744dc91.buffer))
	hxff6bc57.Cap = 0x7fffffff
	// hxff6bc57.Len = ?

}

// Ref returns a reference to C object as it is.
func (x *Jbig2Globals) Ref() *C.fz_jbig2_globals {
	if x == nil {
		return nil
	}
	return (*C.fz_jbig2_globals)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Jbig2Globals) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewJbig2GlobalsRef converts the C object reference into a raw struct reference without wrapping.
func NewJbig2GlobalsRef(ref unsafe.Pointer) *Jbig2Globals {
	return (*Jbig2Globals)(ref)
}

// NewJbig2Globals allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewJbig2Globals() *Jbig2Globals {
	return (*Jbig2Globals)(allocJbig2GlobalsMemory(1))
}

// allocJbig2GlobalsMemory allocates memory for type C.fz_jbig2_globals in C.
// The caller is responsible for freeing the this memory via C.free.
func allocJbig2GlobalsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfJbig2GlobalsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfJbig2GlobalsValue = unsafe.Sizeof([1]C.fz_jbig2_globals{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Jbig2Globals) PassRef() *C.fz_jbig2_globals {
	if x == nil {
		x = (*Jbig2Globals)(allocJbig2GlobalsMemory(1))
	}
	return (*C.fz_jbig2_globals)(unsafe.Pointer(x))
}

// allocStorableMemory allocates memory for type C.fz_storable in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStorableMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStorableValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStorableValue = unsafe.Sizeof([1]C.fz_storable{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Storable) Ref() *C.fz_storable {
	if x == nil {
		return nil
	}
	return x.refe377245e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Storable) Free() {
	if x != nil && x.allocse377245e != nil {
		x.allocse377245e.(*cgoAllocMap).Free()
		x.refe377245e = nil
	}
}

// NewStorableRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStorableRef(ref unsafe.Pointer) *Storable {
	if ref == nil {
		return nil
	}
	obj := new(Storable)
	obj.refe377245e = (*C.fz_storable)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Storable) PassRef() (*C.fz_storable, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe377245e != nil {
		return x.refe377245e, nil
	}
	meme377245e := allocStorableMemory(1)
	refe377245e := (*C.fz_storable)(meme377245e)
	allocse377245e := new(cgoAllocMap)
	allocse377245e.Add(meme377245e)

	var crefs_allocs *cgoAllocMap
	refe377245e.refs, crefs_allocs = (C.int)(x.Refs), cgoAllocsUnknown
	allocse377245e.Borrow(crefs_allocs)

	var cdrop_allocs *cgoAllocMap
	refe377245e.drop, cdrop_allocs = x.Drop.PassRef()
	allocse377245e.Borrow(cdrop_allocs)

	x.refe377245e = refe377245e
	x.allocse377245e = allocse377245e
	return refe377245e, allocse377245e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Storable) PassValue() (C.fz_storable, *cgoAllocMap) {
	if x.refe377245e != nil {
		return *x.refe377245e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Storable) Deref() {
	if x.refe377245e == nil {
		return
	}
	x.Refs = (int32)(x.refe377245e.refs)
	x.Drop = NewStoreDropFnRef(unsafe.Pointer(x.refe377245e.drop))
}

// allocKeyStorableMemory allocates memory for type C.fz_key_storable in C.
// The caller is responsible for freeing the this memory via C.free.
func allocKeyStorableMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfKeyStorableValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfKeyStorableValue = unsafe.Sizeof([1]C.fz_key_storable{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *KeyStorable) Ref() *C.fz_key_storable {
	if x == nil {
		return nil
	}
	return x.ref25099da
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *KeyStorable) Free() {
	if x != nil && x.allocs25099da != nil {
		x.allocs25099da.(*cgoAllocMap).Free()
		x.ref25099da = nil
	}
}

// NewKeyStorableRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewKeyStorableRef(ref unsafe.Pointer) *KeyStorable {
	if ref == nil {
		return nil
	}
	obj := new(KeyStorable)
	obj.ref25099da = (*C.fz_key_storable)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *KeyStorable) PassRef() (*C.fz_key_storable, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref25099da != nil {
		return x.ref25099da, nil
	}
	mem25099da := allocKeyStorableMemory(1)
	ref25099da := (*C.fz_key_storable)(mem25099da)
	allocs25099da := new(cgoAllocMap)
	allocs25099da.Add(mem25099da)

	var cstorable_allocs *cgoAllocMap
	ref25099da.storable, cstorable_allocs = x.Storable.PassValue()
	allocs25099da.Borrow(cstorable_allocs)

	var cstore_key_refs_allocs *cgoAllocMap
	ref25099da.store_key_refs, cstore_key_refs_allocs = (C.short)(x.StoreKeyRefs), cgoAllocsUnknown
	allocs25099da.Borrow(cstore_key_refs_allocs)

	x.ref25099da = ref25099da
	x.allocs25099da = allocs25099da
	return ref25099da, allocs25099da

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x KeyStorable) PassValue() (C.fz_key_storable, *cgoAllocMap) {
	if x.ref25099da != nil {
		return *x.ref25099da, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *KeyStorable) Deref() {
	if x.ref25099da == nil {
		return
	}
	x.Storable = *NewStorableRef(unsafe.Pointer(&x.ref25099da.storable))
	x.StoreKeyRefs = (int16)(x.ref25099da.store_key_refs)
}

// packSStorable reads sliced Go data structure out from plain C format.
func packSStorable(v []Storable, ptr0 *C.fz_storable) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStorableValue]C.fz_storable)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewStorableRef(unsafe.Pointer(&ptr1))
	}
}

func (x StoreDropFn) PassRef() (ref *C.fz_store_drop_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if storeDropFnAAB4A233Func == nil {
		storeDropFnAAB4A233Func = x
	}
	return (*C.fz_store_drop_fn)(C.fz_store_drop_fn_aab4a233), nil
}

func NewStoreDropFnRef(ref unsafe.Pointer) *StoreDropFn {
	return (*StoreDropFn)(ref)
}

//export storeDropFnAAB4A233
func storeDropFnAAB4A233(carg0 *C.fz_context, carg1 *C.fz_storable) {
	if storeDropFnAAB4A233Func != nil {
		var arg0aab4a233 []Context
		packSContext(arg0aab4a233, carg0)
		var arg1aab4a233 []Storable
		packSStorable(arg1aab4a233, carg1)
		storeDropFnAAB4A233Func(arg0aab4a233, arg1aab4a233)
		return
	}
	panic("callback func has not been set (race?)")
}

var storeDropFnAAB4A233Func StoreDropFn

// allocStoreHashMemory allocates memory for type C.fz_store_hash in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStoreHashMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStoreHashValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStoreHashValue = unsafe.Sizeof([1]C.fz_store_hash{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StoreHash) Ref() *C.fz_store_hash {
	if x == nil {
		return nil
	}
	return x.ref54d2a776
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StoreHash) Free() {
	if x != nil && x.allocs54d2a776 != nil {
		x.allocs54d2a776.(*cgoAllocMap).Free()
		x.ref54d2a776 = nil
	}
}

// NewStoreHashRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStoreHashRef(ref unsafe.Pointer) *StoreHash {
	if ref == nil {
		return nil
	}
	obj := new(StoreHash)
	obj.ref54d2a776 = (*C.fz_store_hash)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StoreHash) PassRef() (*C.fz_store_hash, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref54d2a776 != nil {
		return x.ref54d2a776, nil
	}
	mem54d2a776 := allocStoreHashMemory(1)
	ref54d2a776 := (*C.fz_store_hash)(mem54d2a776)
	allocs54d2a776 := new(cgoAllocMap)
	allocs54d2a776.Add(mem54d2a776)

	var cdrop_allocs *cgoAllocMap
	ref54d2a776.drop, cdrop_allocs = x.Drop.PassRef()
	allocs54d2a776.Borrow(cdrop_allocs)

	x.ref54d2a776 = ref54d2a776
	x.allocs54d2a776 = allocs54d2a776
	return ref54d2a776, allocs54d2a776

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StoreHash) PassValue() (C.fz_store_hash, *cgoAllocMap) {
	if x.ref54d2a776 != nil {
		return *x.ref54d2a776, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StoreHash) Deref() {
	if x.ref54d2a776 == nil {
		return
	}
	x.Drop = NewStoreDropFnRef(unsafe.Pointer(x.ref54d2a776.drop))
}

// allocStoreTypeMemory allocates memory for type C.fz_store_type in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStoreTypeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStoreTypeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStoreTypeValue = unsafe.Sizeof([1]C.fz_store_type{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StoreType) Ref() *C.fz_store_type {
	if x == nil {
		return nil
	}
	return x.ref9b492e7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StoreType) Free() {
	if x != nil && x.allocs9b492e7 != nil {
		x.allocs9b492e7.(*cgoAllocMap).Free()
		x.ref9b492e7 = nil
	}
}

// NewStoreTypeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStoreTypeRef(ref unsafe.Pointer) *StoreType {
	if ref == nil {
		return nil
	}
	obj := new(StoreType)
	obj.ref9b492e7 = (*C.fz_store_type)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StoreType) PassRef() (*C.fz_store_type, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9b492e7 != nil {
		return x.ref9b492e7, nil
	}
	mem9b492e7 := allocStoreTypeMemory(1)
	ref9b492e7 := (*C.fz_store_type)(mem9b492e7)
	allocs9b492e7 := new(cgoAllocMap)
	allocs9b492e7.Add(mem9b492e7)

	var cmake_hash_key_allocs *cgoAllocMap
	ref9b492e7.make_hash_key, cmake_hash_key_allocs = x.MakeHashKey.PassRef()
	allocs9b492e7.Borrow(cmake_hash_key_allocs)

	var ckeep_key_allocs *cgoAllocMap
	ref9b492e7.keep_key, ckeep_key_allocs = x.KeepKey.PassRef()
	allocs9b492e7.Borrow(ckeep_key_allocs)

	var cdrop_key_allocs *cgoAllocMap
	ref9b492e7.drop_key, cdrop_key_allocs = x.DropKey.PassRef()
	allocs9b492e7.Borrow(cdrop_key_allocs)

	var ccmp_key_allocs *cgoAllocMap
	ref9b492e7.cmp_key, ccmp_key_allocs = x.CmpKey.PassRef()
	allocs9b492e7.Borrow(ccmp_key_allocs)

	var cformat_key_allocs *cgoAllocMap
	ref9b492e7.format_key, cformat_key_allocs = x.FormatKey.PassRef()
	allocs9b492e7.Borrow(cformat_key_allocs)

	var cneeds_reap_allocs *cgoAllocMap
	ref9b492e7.needs_reap, cneeds_reap_allocs = x.NeedsReap.PassRef()
	allocs9b492e7.Borrow(cneeds_reap_allocs)

	x.ref9b492e7 = ref9b492e7
	x.allocs9b492e7 = allocs9b492e7
	return ref9b492e7, allocs9b492e7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StoreType) PassValue() (C.fz_store_type, *cgoAllocMap) {
	if x.ref9b492e7 != nil {
		return *x.ref9b492e7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StoreType) Deref() {
	if x.ref9b492e7 == nil {
		return
	}
	x.MakeHashKey = NewRef(unsafe.Pointer(x.ref9b492e7.make_hash_key))
	x.KeepKey = NewRef(unsafe.Pointer(x.ref9b492e7.keep_key))
	x.DropKey = NewRef(unsafe.Pointer(x.ref9b492e7.drop_key))
	x.CmpKey = NewRef(unsafe.Pointer(x.ref9b492e7.cmp_key))
	x.FormatKey = NewRef(unsafe.Pointer(x.ref9b492e7.format_key))
	x.NeedsReap = NewRef(unsafe.Pointer(x.ref9b492e7.needs_reap))
}

func (x StoreFilterFn) PassRef() (ref *C.fz_store_filter_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if storeFilterFnA0DA2DF9Func == nil {
		storeFilterFnA0DA2DF9Func = x
	}
	return (*C.fz_store_filter_fn)(C.fz_store_filter_fn_a0da2df9), nil
}

func NewStoreFilterFnRef(ref unsafe.Pointer) *StoreFilterFn {
	return (*StoreFilterFn)(ref)
}

//export storeFilterFnA0DA2DF9
func storeFilterFnA0DA2DF9(cctx *C.fz_context, carg unsafe.Pointer, ckey unsafe.Pointer) C.int {
	if storeFilterFnA0DA2DF9Func != nil {
		var ctxa0da2df9 []Context
		packSContext(ctxa0da2df9, cctx)
		arga0da2df9 := (unsafe.Pointer)(unsafe.Pointer(carg))
		keya0da2df9 := (unsafe.Pointer)(unsafe.Pointer(ckey))
		reta0da2df9 := storeFilterFnA0DA2DF9Func(ctxa0da2df9, arga0da2df9, keya0da2df9)
		ret, _ := (C.int)(reta0da2df9), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var storeFilterFnA0DA2DF9Func StoreFilterFn

// allocArchiveMemory allocates memory for type C.fz_archive in C.
// The caller is responsible for freeing the this memory via C.free.
func allocArchiveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfArchiveValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfArchiveValue = unsafe.Sizeof([1]C.fz_archive{})

// unpackSStream transforms a sliced Go data structure into plain C format.
func unpackSStream(x []Stream) (unpacked *C.fz_stream, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_stream) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStreamMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_stream)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_stream)(unsafe.Pointer(h.Data))
	return
}

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(unsafe.Pointer(h.Data)), cgoAllocsUnknown
}

type stringHeader struct {
	Data uintptr
	Len  int
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = uintptr(unsafe.Pointer(p))
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - h.Data)
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(unsafe.Pointer(h.Data)), C.int(h.Len))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Archive) Ref() *C.fz_archive {
	if x == nil {
		return nil
	}
	return x.ref9e683682
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Archive) Free() {
	if x != nil && x.allocs9e683682 != nil {
		x.allocs9e683682.(*cgoAllocMap).Free()
		x.ref9e683682 = nil
	}
}

// NewArchiveRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewArchiveRef(ref unsafe.Pointer) *Archive {
	if ref == nil {
		return nil
	}
	obj := new(Archive)
	obj.ref9e683682 = (*C.fz_archive)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Archive) PassRef() (*C.fz_archive, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9e683682 != nil {
		return x.ref9e683682, nil
	}
	mem9e683682 := allocArchiveMemory(1)
	ref9e683682 := (*C.fz_archive)(mem9e683682)
	allocs9e683682 := new(cgoAllocMap)
	allocs9e683682.Add(mem9e683682)

	var cfile_allocs *cgoAllocMap
	ref9e683682.file, cfile_allocs = unpackSStream(x.File)
	allocs9e683682.Borrow(cfile_allocs)

	var cformat_allocs *cgoAllocMap
	ref9e683682.format, cformat_allocs = unpackPCharString(x.Format)
	allocs9e683682.Borrow(cformat_allocs)

	var cdrop_archive_allocs *cgoAllocMap
	ref9e683682.drop_archive, cdrop_archive_allocs = x.DropArchive.PassRef()
	allocs9e683682.Borrow(cdrop_archive_allocs)

	var ccount_entries_allocs *cgoAllocMap
	ref9e683682.count_entries, ccount_entries_allocs = x.CountEntries.PassRef()
	allocs9e683682.Borrow(ccount_entries_allocs)

	var clist_entry_allocs *cgoAllocMap
	ref9e683682.list_entry, clist_entry_allocs = x.ListEntry.PassRef()
	allocs9e683682.Borrow(clist_entry_allocs)

	var chas_entry_allocs *cgoAllocMap
	ref9e683682.has_entry, chas_entry_allocs = x.HasEntry.PassRef()
	allocs9e683682.Borrow(chas_entry_allocs)

	var cread_entry_allocs *cgoAllocMap
	ref9e683682.read_entry, cread_entry_allocs = x.ReadEntry.PassRef()
	allocs9e683682.Borrow(cread_entry_allocs)

	var copen_entry_allocs *cgoAllocMap
	ref9e683682.open_entry, copen_entry_allocs = x.OpenEntry.PassRef()
	allocs9e683682.Borrow(copen_entry_allocs)

	x.ref9e683682 = ref9e683682
	x.allocs9e683682 = allocs9e683682
	return ref9e683682, allocs9e683682

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Archive) PassValue() (C.fz_archive, *cgoAllocMap) {
	if x.ref9e683682 != nil {
		return *x.ref9e683682, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Archive) Deref() {
	if x.ref9e683682 == nil {
		return
	}
	packSStream(x.File, x.ref9e683682.file)
	x.Format = packPCharString(x.ref9e683682.format)
	x.DropArchive = NewRef(unsafe.Pointer(x.ref9e683682.drop_archive))
	x.CountEntries = NewRef(unsafe.Pointer(x.ref9e683682.count_entries))
	x.ListEntry = NewRef(unsafe.Pointer(x.ref9e683682.list_entry))
	x.HasEntry = NewRef(unsafe.Pointer(x.ref9e683682.has_entry))
	x.ReadEntry = NewBufferRef(unsafe.Pointer(x.ref9e683682.read_entry))
	x.OpenEntry = NewStreamRef(unsafe.Pointer(x.ref9e683682.open_entry))
}

// Ref returns a reference to C object as it is.
func (x *ZipWriter) Ref() *C.fz_zip_writer {
	if x == nil {
		return nil
	}
	return (*C.fz_zip_writer)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ZipWriter) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewZipWriterRef converts the C object reference into a raw struct reference without wrapping.
func NewZipWriterRef(ref unsafe.Pointer) *ZipWriter {
	return (*ZipWriter)(ref)
}

// NewZipWriter allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewZipWriter() *ZipWriter {
	return (*ZipWriter)(allocZipWriterMemory(1))
}

// allocZipWriterMemory allocates memory for type C.fz_zip_writer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocZipWriterMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfZipWriterValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfZipWriterValue = unsafe.Sizeof([1]C.fz_zip_writer{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ZipWriter) PassRef() *C.fz_zip_writer {
	if x == nil {
		x = (*ZipWriter)(allocZipWriterMemory(1))
	}
	return (*C.fz_zip_writer)(unsafe.Pointer(x))
}

// allocColorParamsMemory allocates memory for type C.fz_color_params in C.
// The caller is responsible for freeing the this memory via C.free.
func allocColorParamsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfColorParamsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfColorParamsValue = unsafe.Sizeof([1]C.fz_color_params{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ColorParams) Ref() *C.fz_color_params {
	if x == nil {
		return nil
	}
	return x.ref70b0cf02
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ColorParams) Free() {
	if x != nil && x.allocs70b0cf02 != nil {
		x.allocs70b0cf02.(*cgoAllocMap).Free()
		x.ref70b0cf02 = nil
	}
}

// NewColorParamsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewColorParamsRef(ref unsafe.Pointer) *ColorParams {
	if ref == nil {
		return nil
	}
	obj := new(ColorParams)
	obj.ref70b0cf02 = (*C.fz_color_params)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ColorParams) PassRef() (*C.fz_color_params, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref70b0cf02 != nil {
		return x.ref70b0cf02, nil
	}
	mem70b0cf02 := allocColorParamsMemory(1)
	ref70b0cf02 := (*C.fz_color_params)(mem70b0cf02)
	allocs70b0cf02 := new(cgoAllocMap)
	allocs70b0cf02.Add(mem70b0cf02)

	var cri_allocs *cgoAllocMap
	ref70b0cf02.ri, cri_allocs = (C.uint8_t)(x.Ri), cgoAllocsUnknown
	allocs70b0cf02.Borrow(cri_allocs)

	var cbp_allocs *cgoAllocMap
	ref70b0cf02.bp, cbp_allocs = (C.uint8_t)(x.Bp), cgoAllocsUnknown
	allocs70b0cf02.Borrow(cbp_allocs)

	var cop_allocs *cgoAllocMap
	ref70b0cf02.op, cop_allocs = (C.uint8_t)(x.Op), cgoAllocsUnknown
	allocs70b0cf02.Borrow(cop_allocs)

	var copm_allocs *cgoAllocMap
	ref70b0cf02.opm, copm_allocs = (C.uint8_t)(x.Opm), cgoAllocsUnknown
	allocs70b0cf02.Borrow(copm_allocs)

	x.ref70b0cf02 = ref70b0cf02
	x.allocs70b0cf02 = allocs70b0cf02
	return ref70b0cf02, allocs70b0cf02

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ColorParams) PassValue() (C.fz_color_params, *cgoAllocMap) {
	if x.ref70b0cf02 != nil {
		return *x.ref70b0cf02, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ColorParams) Deref() {
	if x.ref70b0cf02 == nil {
		return
	}
	x.Ri = (byte)(x.ref70b0cf02.ri)
	x.Bp = (byte)(x.ref70b0cf02.bp)
	x.Op = (byte)(x.ref70b0cf02.op)
	x.Opm = (byte)(x.ref70b0cf02.opm)
}

// Ref returns a reference to C object as it is.
func (x *Colorspace) Ref() *C.fz_colorspace {
	if x == nil {
		return nil
	}
	return (*C.fz_colorspace)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Colorspace) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewColorspaceRef converts the C object reference into a raw struct reference without wrapping.
func NewColorspaceRef(ref unsafe.Pointer) *Colorspace {
	return (*Colorspace)(ref)
}

// NewColorspace allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewColorspace() *Colorspace {
	return (*Colorspace)(allocColorspaceMemory(1))
}

// allocColorspaceMemory allocates memory for type C.fz_colorspace in C.
// The caller is responsible for freeing the this memory via C.free.
func allocColorspaceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfColorspaceValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfColorspaceValue = unsafe.Sizeof([1]C.fz_colorspace{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Colorspace) PassRef() *C.fz_colorspace {
	if x == nil {
		x = (*Colorspace)(allocColorspaceMemory(1))
	}
	return (*C.fz_colorspace)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Iccprofile) Ref() *C.fz_iccprofile {
	if x == nil {
		return nil
	}
	return (*C.fz_iccprofile)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Iccprofile) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewIccprofileRef converts the C object reference into a raw struct reference without wrapping.
func NewIccprofileRef(ref unsafe.Pointer) *Iccprofile {
	return (*Iccprofile)(ref)
}

// NewIccprofile allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewIccprofile() *Iccprofile {
	return (*Iccprofile)(allocIccprofileMemory(1))
}

// allocIccprofileMemory allocates memory for type C.fz_iccprofile in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIccprofileMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIccprofileValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfIccprofileValue = unsafe.Sizeof([1]C.fz_iccprofile{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Iccprofile) PassRef() *C.fz_iccprofile {
	if x == nil {
		x = (*Iccprofile)(allocIccprofileMemory(1))
	}
	return (*C.fz_iccprofile)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Icclink) Ref() *C.fz_icclink {
	if x == nil {
		return nil
	}
	return (*C.fz_icclink)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Icclink) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewIcclinkRef converts the C object reference into a raw struct reference without wrapping.
func NewIcclinkRef(ref unsafe.Pointer) *Icclink {
	return (*Icclink)(ref)
}

// NewIcclink allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewIcclink() *Icclink {
	return (*Icclink)(allocIcclinkMemory(1))
}

// allocIcclinkMemory allocates memory for type C.fz_icclink in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIcclinkMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIcclinkValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfIcclinkValue = unsafe.Sizeof([1]C.fz_icclink{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Icclink) PassRef() *C.fz_icclink {
	if x == nil {
		x = (*Icclink)(allocIcclinkMemory(1))
	}
	return (*C.fz_icclink)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *DefaultColorspaces) Ref() *C.fz_default_colorspaces {
	if x == nil {
		return nil
	}
	return (*C.fz_default_colorspaces)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DefaultColorspaces) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDefaultColorspacesRef converts the C object reference into a raw struct reference without wrapping.
func NewDefaultColorspacesRef(ref unsafe.Pointer) *DefaultColorspaces {
	return (*DefaultColorspaces)(ref)
}

// NewDefaultColorspaces allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDefaultColorspaces() *DefaultColorspaces {
	return (*DefaultColorspaces)(allocDefaultColorspacesMemory(1))
}

// allocDefaultColorspacesMemory allocates memory for type C.fz_default_colorspaces in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDefaultColorspacesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDefaultColorspacesValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDefaultColorspacesValue = unsafe.Sizeof([1]C.fz_default_colorspaces{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DefaultColorspaces) PassRef() *C.fz_default_colorspaces {
	if x == nil {
		x = (*DefaultColorspaces)(allocDefaultColorspacesMemory(1))
	}
	return (*C.fz_default_colorspaces)(unsafe.Pointer(x))
}

func (x ColorspaceConvertFn) PassRef() (ref *C.fz_colorspace_convert_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if colorspaceConvertFnC5345EE1Func == nil {
		colorspaceConvertFnC5345EE1Func = x
	}
	return (*C.fz_colorspace_convert_fn)(C.fz_colorspace_convert_fn_c5345ee1), nil
}

func NewColorspaceConvertFnRef(ref unsafe.Pointer) *ColorspaceConvertFn {
	return (*ColorspaceConvertFn)(ref)
}

//export colorspaceConvertFnC5345EE1
func colorspaceConvertFnC5345EE1(cctx *C.fz_context, ccs *C.fz_colorspace, csrc *C.float, cdst *C.float) {
	if colorspaceConvertFnC5345EE1Func != nil {
		var ctxc5345ee1 []Context
		packSContext(ctxc5345ee1, cctx)
		var csc5345ee1 []Colorspace
		hxf5fa529 := (*sliceHeader)(unsafe.Pointer(&csc5345ee1))
		hxf5fa529.Data = uintptr(unsafe.Pointer(ccs))
		hxf5fa529.Cap = 0x7fffffff
		// hxf5fa529.Len = ?

		var srcc5345ee1 []float32
		hxf21690b := (*sliceHeader)(unsafe.Pointer(&srcc5345ee1))
		hxf21690b.Data = uintptr(unsafe.Pointer(csrc))
		hxf21690b.Cap = 0x7fffffff
		// hxf21690b.Len = ?

		var dstc5345ee1 []float32
		hxf1231c9 := (*sliceHeader)(unsafe.Pointer(&dstc5345ee1))
		hxf1231c9.Data = uintptr(unsafe.Pointer(cdst))
		hxf1231c9.Cap = 0x7fffffff
		// hxf1231c9.Len = ?

		colorspaceConvertFnC5345EE1Func(ctxc5345ee1, csc5345ee1, srcc5345ee1, dstc5345ee1)
		return
	}
	panic("callback func has not been set (race?)")
}

var colorspaceConvertFnC5345EE1Func ColorspaceConvertFn

func (x ColorspaceDestructFn) PassRef() (ref *C.fz_colorspace_destruct_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if colorspaceDestructFn779FC731Func == nil {
		colorspaceDestructFn779FC731Func = x
	}
	return (*C.fz_colorspace_destruct_fn)(C.fz_colorspace_destruct_fn_779fc731), nil
}

func NewColorspaceDestructFnRef(ref unsafe.Pointer) *ColorspaceDestructFn {
	return (*ColorspaceDestructFn)(ref)
}

//export colorspaceDestructFn779FC731
func colorspaceDestructFn779FC731(cctx *C.fz_context, ccs *C.fz_colorspace) {
	if colorspaceDestructFn779FC731Func != nil {
		var ctx779fc731 []Context
		packSContext(ctx779fc731, cctx)
		var cs779fc731 []Colorspace
		hxf04b15b := (*sliceHeader)(unsafe.Pointer(&cs779fc731))
		hxf04b15b.Data = uintptr(unsafe.Pointer(ccs))
		hxf04b15b.Cap = 0x7fffffff
		// hxf04b15b.Len = ?

		colorspaceDestructFn779FC731Func(ctx779fc731, cs779fc731)
		return
	}
	panic("callback func has not been set (race?)")
}

var colorspaceDestructFn779FC731Func ColorspaceDestructFn

func (x ColorspaceBaseFn) PassRef() (ref *C.fz_colorspace_base_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if colorspaceBaseFnEBA67BE4Func == nil {
		colorspaceBaseFnEBA67BE4Func = x
	}
	return (*C.fz_colorspace_base_fn)(C.fz_colorspace_base_fn_eba67be4), nil
}

func NewColorspaceBaseFnRef(ref unsafe.Pointer) *ColorspaceBaseFn {
	return (*ColorspaceBaseFn)(ref)
}

//export colorspaceBaseFnEBA67BE4
func colorspaceBaseFnEBA67BE4(ccs *C.fz_colorspace) *C.fz_colorspace {
	if colorspaceBaseFnEBA67BE4Func != nil {
		var cseba67be4 []Colorspace
		hxf2f888b := (*sliceHeader)(unsafe.Pointer(&cseba67be4))
		hxf2f888b.Data = uintptr(unsafe.Pointer(ccs))
		hxf2f888b.Cap = 0x7fffffff
		// hxf2f888b.Len = ?

		reteba67be4 := colorspaceBaseFnEBA67BE4Func(cseba67be4)
		ret, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&reteba67be4)).Data)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var colorspaceBaseFnEBA67BE4Func ColorspaceBaseFn

func (x ColorspaceClampFn) PassRef() (ref *C.fz_colorspace_clamp_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if colorspaceClampFn17A541B8Func == nil {
		colorspaceClampFn17A541B8Func = x
	}
	return (*C.fz_colorspace_clamp_fn)(C.fz_colorspace_clamp_fn_17a541b8), nil
}

func NewColorspaceClampFnRef(ref unsafe.Pointer) *ColorspaceClampFn {
	return (*ColorspaceClampFn)(ref)
}

//export colorspaceClampFn17A541B8
func colorspaceClampFn17A541B8(ccs *C.fz_colorspace, csrc *C.float, cdst *C.float) {
	if colorspaceClampFn17A541B8Func != nil {
		var cs17a541b8 []Colorspace
		hxf5d1de2 := (*sliceHeader)(unsafe.Pointer(&cs17a541b8))
		hxf5d1de2.Data = uintptr(unsafe.Pointer(ccs))
		hxf5d1de2.Cap = 0x7fffffff
		// hxf5d1de2.Len = ?

		var src17a541b8 []float32
		hxfe53d34 := (*sliceHeader)(unsafe.Pointer(&src17a541b8))
		hxfe53d34.Data = uintptr(unsafe.Pointer(csrc))
		hxfe53d34.Cap = 0x7fffffff
		// hxfe53d34.Len = ?

		var dst17a541b8 []float32
		hxf547023 := (*sliceHeader)(unsafe.Pointer(&dst17a541b8))
		hxf547023.Data = uintptr(unsafe.Pointer(cdst))
		hxf547023.Cap = 0x7fffffff
		// hxf547023.Len = ?

		colorspaceClampFn17A541B8Func(cs17a541b8, src17a541b8, dst17a541b8)
		return
	}
	panic("callback func has not been set (race?)")
}

var colorspaceClampFn17A541B8Func ColorspaceClampFn

// allocColorConverterMemory allocates memory for type C.fz_color_converter in C.
// The caller is responsible for freeing the this memory via C.free.
func allocColorConverterMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfColorConverterValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfColorConverterValue = unsafe.Sizeof([1]C.fz_color_converter{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ColorConverter) Ref() *C.fz_color_converter {
	if x == nil {
		return nil
	}
	return x.ref3819bec4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ColorConverter) Free() {
	if x != nil && x.allocs3819bec4 != nil {
		x.allocs3819bec4.(*cgoAllocMap).Free()
		x.ref3819bec4 = nil
	}
}

// NewColorConverterRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewColorConverterRef(ref unsafe.Pointer) *ColorConverter {
	if ref == nil {
		return nil
	}
	obj := new(ColorConverter)
	obj.ref3819bec4 = (*C.fz_color_converter)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ColorConverter) PassRef() (*C.fz_color_converter, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3819bec4 != nil {
		return x.ref3819bec4, nil
	}
	mem3819bec4 := allocColorConverterMemory(1)
	ref3819bec4 := (*C.fz_color_converter)(mem3819bec4)
	allocs3819bec4 := new(cgoAllocMap)
	allocs3819bec4.Add(mem3819bec4)

	var cconvert_allocs *cgoAllocMap
	ref3819bec4.convert, cconvert_allocs = x.Convert.PassRef()
	allocs3819bec4.Borrow(cconvert_allocs)

	var cds_allocs *cgoAllocMap
	ref3819bec4.ds, cds_allocs = (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Ds)).Data)), cgoAllocsUnknown
	allocs3819bec4.Borrow(cds_allocs)

	var css_allocs *cgoAllocMap
	ref3819bec4.ss, css_allocs = (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Ss)).Data)), cgoAllocsUnknown
	allocs3819bec4.Borrow(css_allocs)

	var cis_allocs *cgoAllocMap
	ref3819bec4.is, cis_allocs = (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Is)).Data)), cgoAllocsUnknown
	allocs3819bec4.Borrow(cis_allocs)

	var copaque_allocs *cgoAllocMap
	ref3819bec4.opaque, copaque_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Opaque)), cgoAllocsUnknown
	allocs3819bec4.Borrow(copaque_allocs)

	var clink_allocs *cgoAllocMap
	ref3819bec4.link, clink_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Link)), cgoAllocsUnknown
	allocs3819bec4.Borrow(clink_allocs)

	var cn_allocs *cgoAllocMap
	ref3819bec4.n, cn_allocs = (C.int)(x.N), cgoAllocsUnknown
	allocs3819bec4.Borrow(cn_allocs)

	x.ref3819bec4 = ref3819bec4
	x.allocs3819bec4 = allocs3819bec4
	return ref3819bec4, allocs3819bec4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ColorConverter) PassValue() (C.fz_color_converter, *cgoAllocMap) {
	if x.ref3819bec4 != nil {
		return *x.ref3819bec4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ColorConverter) Deref() {
	if x.ref3819bec4 == nil {
		return
	}
	x.Convert = NewRef(unsafe.Pointer(x.ref3819bec4.convert))
	hxf5ebb88 := (*sliceHeader)(unsafe.Pointer(&x.Ds))
	hxf5ebb88.Data = uintptr(unsafe.Pointer(x.ref3819bec4.ds))
	hxf5ebb88.Cap = 0x7fffffff
	// hxf5ebb88.Len = ?

	hxff20e84 := (*sliceHeader)(unsafe.Pointer(&x.Ss))
	hxff20e84.Data = uintptr(unsafe.Pointer(x.ref3819bec4.ss))
	hxff20e84.Cap = 0x7fffffff
	// hxff20e84.Len = ?

	hxfa26a4d := (*sliceHeader)(unsafe.Pointer(&x.Is))
	hxfa26a4d.Data = uintptr(unsafe.Pointer(x.ref3819bec4.is))
	hxfa26a4d.Cap = 0x7fffffff
	// hxfa26a4d.Len = ?

	x.Opaque = (unsafe.Pointer)(unsafe.Pointer(x.ref3819bec4.opaque))
	x.Link = (unsafe.Pointer)(unsafe.Pointer(x.ref3819bec4.link))
	x.N = (int32)(x.ref3819bec4.n)
}

// allocCalColorspaceMemory allocates memory for type C.fz_cal_colorspace in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCalColorspaceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCalColorspaceValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCalColorspaceValue = unsafe.Sizeof([1]C.fz_cal_colorspace{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CalColorspace) Ref() *C.fz_cal_colorspace {
	if x == nil {
		return nil
	}
	return x.refe3377c70
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CalColorspace) Free() {
	if x != nil && x.allocse3377c70 != nil {
		x.allocse3377c70.(*cgoAllocMap).Free()
		x.refe3377c70 = nil
	}
}

// NewCalColorspaceRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCalColorspaceRef(ref unsafe.Pointer) *CalColorspace {
	if ref == nil {
		return nil
	}
	obj := new(CalColorspace)
	obj.refe3377c70 = (*C.fz_cal_colorspace)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CalColorspace) PassRef() (*C.fz_cal_colorspace, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe3377c70 != nil {
		return x.refe3377c70, nil
	}
	meme3377c70 := allocCalColorspaceMemory(1)
	refe3377c70 := (*C.fz_cal_colorspace)(meme3377c70)
	allocse3377c70 := new(cgoAllocMap)
	allocse3377c70.Add(meme3377c70)

	var cwp_allocs *cgoAllocMap
	refe3377c70.wp, cwp_allocs = *(*[3]C.float)(unsafe.Pointer(&x.Wp)), cgoAllocsUnknown
	allocse3377c70.Borrow(cwp_allocs)

	var cbp_allocs *cgoAllocMap
	refe3377c70.bp, cbp_allocs = *(*[3]C.float)(unsafe.Pointer(&x.Bp)), cgoAllocsUnknown
	allocse3377c70.Borrow(cbp_allocs)

	var cgamma_allocs *cgoAllocMap
	refe3377c70.gamma, cgamma_allocs = *(*[3]C.float)(unsafe.Pointer(&x.Gamma)), cgoAllocsUnknown
	allocse3377c70.Borrow(cgamma_allocs)

	var cmatrix_allocs *cgoAllocMap
	refe3377c70.matrix, cmatrix_allocs = *(*[9]C.float)(unsafe.Pointer(&x.Matrix)), cgoAllocsUnknown
	allocse3377c70.Borrow(cmatrix_allocs)

	var cn_allocs *cgoAllocMap
	refe3377c70.n, cn_allocs = (C.int)(x.N), cgoAllocsUnknown
	allocse3377c70.Borrow(cn_allocs)

	var cprofile_allocs *cgoAllocMap
	refe3377c70.profile, cprofile_allocs = (*C.fz_iccprofile)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Profile)).Data)), cgoAllocsUnknown
	allocse3377c70.Borrow(cprofile_allocs)

	x.refe3377c70 = refe3377c70
	x.allocse3377c70 = allocse3377c70
	return refe3377c70, allocse3377c70

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CalColorspace) PassValue() (C.fz_cal_colorspace, *cgoAllocMap) {
	if x.refe3377c70 != nil {
		return *x.refe3377c70, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CalColorspace) Deref() {
	if x.refe3377c70 == nil {
		return
	}
	x.Wp = *(*[3]float32)(unsafe.Pointer(&x.refe3377c70.wp))
	x.Bp = *(*[3]float32)(unsafe.Pointer(&x.refe3377c70.bp))
	x.Gamma = *(*[3]float32)(unsafe.Pointer(&x.refe3377c70.gamma))
	x.Matrix = *(*[9]float32)(unsafe.Pointer(&x.refe3377c70.matrix))
	x.N = (int32)(x.refe3377c70.n)
	hxfe48098 := (*sliceHeader)(unsafe.Pointer(&x.Profile))
	hxfe48098.Data = uintptr(unsafe.Pointer(x.refe3377c70.profile))
	hxfe48098.Cap = 0x7fffffff
	// hxfe48098.Len = ?

}

// allocPixmapMemory allocates memory for type C.fz_pixmap in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPixmapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPixmapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPixmapValue = unsafe.Sizeof([1]C.fz_pixmap{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Pixmap) Ref() *C.fz_pixmap {
	if x == nil {
		return nil
	}
	return x.ref7c1a1ba1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Pixmap) Free() {
	if x != nil && x.allocs7c1a1ba1 != nil {
		x.allocs7c1a1ba1.(*cgoAllocMap).Free()
		x.ref7c1a1ba1 = nil
	}
}

// NewPixmapRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPixmapRef(ref unsafe.Pointer) *Pixmap {
	if ref == nil {
		return nil
	}
	obj := new(Pixmap)
	obj.ref7c1a1ba1 = (*C.fz_pixmap)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Pixmap) PassRef() (*C.fz_pixmap, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7c1a1ba1 != nil {
		return x.ref7c1a1ba1, nil
	}
	mem7c1a1ba1 := allocPixmapMemory(1)
	ref7c1a1ba1 := (*C.fz_pixmap)(mem7c1a1ba1)
	allocs7c1a1ba1 := new(cgoAllocMap)
	allocs7c1a1ba1.Add(mem7c1a1ba1)

	var cstorable_allocs *cgoAllocMap
	ref7c1a1ba1.storable, cstorable_allocs = x.Storable.PassValue()
	allocs7c1a1ba1.Borrow(cstorable_allocs)

	var cx_allocs *cgoAllocMap
	ref7c1a1ba1.x, cx_allocs = (C.int)(x.X), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref7c1a1ba1.y, cy_allocs = (C.int)(x.Y), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(cy_allocs)

	var cw_allocs *cgoAllocMap
	ref7c1a1ba1.w, cw_allocs = (C.int)(x.W), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	ref7c1a1ba1.h, ch_allocs = (C.int)(x.H), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(ch_allocs)

	var cn_allocs *cgoAllocMap
	ref7c1a1ba1.n, cn_allocs = (C.uchar)(x.N), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(cn_allocs)

	var cs_allocs *cgoAllocMap
	ref7c1a1ba1.s, cs_allocs = (C.uchar)(x.S), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(cs_allocs)

	var calpha_allocs *cgoAllocMap
	ref7c1a1ba1.alpha, calpha_allocs = (C.uchar)(x.Alpha), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(calpha_allocs)

	var cflags_allocs *cgoAllocMap
	ref7c1a1ba1.flags, cflags_allocs = (C.uchar)(x.Flags), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(cflags_allocs)

	var cstride_allocs *cgoAllocMap
	ref7c1a1ba1.stride, cstride_allocs = (C.ptrdiff_t)(x.Stride), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(cstride_allocs)

	var cseps_allocs *cgoAllocMap
	ref7c1a1ba1.seps, cseps_allocs = (*C.fz_separations)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Seps)).Data)), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(cseps_allocs)

	var cxres_allocs *cgoAllocMap
	ref7c1a1ba1.xres, cxres_allocs = (C.int)(x.Xres), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(cxres_allocs)

	var cyres_allocs *cgoAllocMap
	ref7c1a1ba1.yres, cyres_allocs = (C.int)(x.Yres), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(cyres_allocs)

	var ccolorspace_allocs *cgoAllocMap
	ref7c1a1ba1.colorspace, ccolorspace_allocs = (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Colorspace)).Data)), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(ccolorspace_allocs)

	var csamples_allocs *cgoAllocMap
	ref7c1a1ba1.samples, csamples_allocs = (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Samples)).Data)), cgoAllocsUnknown
	allocs7c1a1ba1.Borrow(csamples_allocs)

	x.ref7c1a1ba1 = ref7c1a1ba1
	x.allocs7c1a1ba1 = allocs7c1a1ba1
	return ref7c1a1ba1, allocs7c1a1ba1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Pixmap) PassValue() (C.fz_pixmap, *cgoAllocMap) {
	if x.ref7c1a1ba1 != nil {
		return *x.ref7c1a1ba1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Pixmap) Deref() {
	if x.ref7c1a1ba1 == nil {
		return
	}
	x.Storable = *NewStorableRef(unsafe.Pointer(&x.ref7c1a1ba1.storable))
	x.X = (int32)(x.ref7c1a1ba1.x)
	x.Y = (int32)(x.ref7c1a1ba1.y)
	x.W = (int32)(x.ref7c1a1ba1.w)
	x.H = (int32)(x.ref7c1a1ba1.h)
	x.N = (byte)(x.ref7c1a1ba1.n)
	x.S = (byte)(x.ref7c1a1ba1.s)
	x.Alpha = (byte)(x.ref7c1a1ba1.alpha)
	x.Flags = (byte)(x.ref7c1a1ba1.flags)
	x.Stride = (int32)(x.ref7c1a1ba1.stride)
	hxffe3496 := (*sliceHeader)(unsafe.Pointer(&x.Seps))
	hxffe3496.Data = uintptr(unsafe.Pointer(x.ref7c1a1ba1.seps))
	hxffe3496.Cap = 0x7fffffff
	// hxffe3496.Len = ?

	x.Xres = (int32)(x.ref7c1a1ba1.xres)
	x.Yres = (int32)(x.ref7c1a1ba1.yres)
	hxf5d48a6 := (*sliceHeader)(unsafe.Pointer(&x.Colorspace))
	hxf5d48a6.Data = uintptr(unsafe.Pointer(x.ref7c1a1ba1.colorspace))
	hxf5d48a6.Cap = 0x7fffffff
	// hxf5d48a6.Len = ?

	hxf685469 := (*sliceHeader)(unsafe.Pointer(&x.Samples))
	hxf685469.Data = uintptr(unsafe.Pointer(x.ref7c1a1ba1.samples))
	hxf685469.Cap = 0x7fffffff
	// hxf685469.Len = ?

}

// Ref returns a reference to C object as it is.
func (x *ScaleCache) Ref() *C.fz_scale_cache {
	if x == nil {
		return nil
	}
	return (*C.fz_scale_cache)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ScaleCache) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewScaleCacheRef converts the C object reference into a raw struct reference without wrapping.
func NewScaleCacheRef(ref unsafe.Pointer) *ScaleCache {
	return (*ScaleCache)(ref)
}

// NewScaleCache allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewScaleCache() *ScaleCache {
	return (*ScaleCache)(allocScaleCacheMemory(1))
}

// allocScaleCacheMemory allocates memory for type C.fz_scale_cache in C.
// The caller is responsible for freeing the this memory via C.free.
func allocScaleCacheMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfScaleCacheValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfScaleCacheValue = unsafe.Sizeof([1]C.fz_scale_cache{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ScaleCache) PassRef() *C.fz_scale_cache {
	if x == nil {
		x = (*ScaleCache)(allocScaleCacheMemory(1))
	}
	return (*C.fz_scale_cache)(unsafe.Pointer(x))
}

// packSPixmap reads sliced Go data structure out from plain C format.
func packSPixmap(v []Pixmap, ptr0 *C.fz_pixmap) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPixmapValue]C.fz_pixmap)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPixmapRef(unsafe.Pointer(&ptr1))
	}
}

// packSColorParams reads sliced Go data structure out from plain C format.
func packSColorParams(v []ColorParams, ptr0 *C.fz_color_params) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfColorParamsValue]C.fz_color_params)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewColorParamsRef(unsafe.Pointer(&ptr1))
	}
}

func (x PixmapConverter) PassRef() (ref *C.fz_pixmap_converter, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pixmapConverterA63960AFunc == nil {
		pixmapConverterA63960AFunc = x
	}
	return (*C.fz_pixmap_converter)(C.fz_pixmap_converter_a63960a), nil
}

func NewPixmapConverterRef(ref unsafe.Pointer) *PixmapConverter {
	return (*PixmapConverter)(ref)
}

//export pixmapConverterA63960A
func pixmapConverterA63960A(cctx *C.fz_context, cdp *C.fz_pixmap, csp *C.fz_pixmap, cprf *C.fz_colorspace, cdefaultCs *C.fz_default_colorspaces, ccolorParams *C.fz_color_params, ccopySpots C.int) {
	if pixmapConverterA63960AFunc != nil {
		var ctxa63960a []Context
		packSContext(ctxa63960a, cctx)
		var dpa63960a []Pixmap
		packSPixmap(dpa63960a, cdp)
		var spa63960a []Pixmap
		packSPixmap(spa63960a, csp)
		var prfa63960a []Colorspace
		hxf03a9a7 := (*sliceHeader)(unsafe.Pointer(&prfa63960a))
		hxf03a9a7.Data = uintptr(unsafe.Pointer(cprf))
		hxf03a9a7.Cap = 0x7fffffff
		// hxf03a9a7.Len = ?

		var defaultCsa63960a []DefaultColorspaces
		hxff24242 := (*sliceHeader)(unsafe.Pointer(&defaultCsa63960a))
		hxff24242.Data = uintptr(unsafe.Pointer(cdefaultCs))
		hxff24242.Cap = 0x7fffffff
		// hxff24242.Len = ?

		var colorParamsa63960a []ColorParams
		packSColorParams(colorParamsa63960a, ccolorParams)
		copySpotsa63960a := (int32)(ccopySpots)
		pixmapConverterA63960AFunc(ctxa63960a, dpa63960a, spa63960a, prfa63960a, defaultCsa63960a, colorParamsa63960a, copySpotsa63960a)
		return
	}
	panic("callback func has not been set (race?)")
}

var pixmapConverterA63960AFunc PixmapConverter

// Ref returns a reference to C object as it is.
func (x *Separations) Ref() *C.fz_separations {
	if x == nil {
		return nil
	}
	return (*C.fz_separations)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Separations) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewSeparationsRef converts the C object reference into a raw struct reference without wrapping.
func NewSeparationsRef(ref unsafe.Pointer) *Separations {
	return (*Separations)(ref)
}

// NewSeparations allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewSeparations() *Separations {
	return (*Separations)(allocSeparationsMemory(1))
}

// allocSeparationsMemory allocates memory for type C.fz_separations in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSeparationsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSeparationsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSeparationsValue = unsafe.Sizeof([1]C.fz_separations{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Separations) PassRef() *C.fz_separations {
	if x == nil {
		x = (*Separations)(allocSeparationsMemory(1))
	}
	return (*C.fz_separations)(unsafe.Pointer(x))
}

// allocGlyphMemory allocates memory for type C.fz_glyph in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGlyphMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGlyphValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfGlyphValue = unsafe.Sizeof([1]C.fz_glyph{})

// unpackSPixmap transforms a sliced Go data structure into plain C format.
func unpackSPixmap(x []Pixmap) (unpacked *C.fz_pixmap, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_pixmap) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPixmapMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_pixmap)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_pixmap)(unsafe.Pointer(h.Data))
	return
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Glyph) Ref() *C.fz_glyph {
	if x == nil {
		return nil
	}
	return x.refabf263b7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Glyph) Free() {
	if x != nil && x.allocsabf263b7 != nil {
		x.allocsabf263b7.(*cgoAllocMap).Free()
		x.refabf263b7 = nil
	}
}

// NewGlyphRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGlyphRef(ref unsafe.Pointer) *Glyph {
	if ref == nil {
		return nil
	}
	obj := new(Glyph)
	obj.refabf263b7 = (*C.fz_glyph)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Glyph) PassRef() (*C.fz_glyph, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refabf263b7 != nil {
		return x.refabf263b7, nil
	}
	memabf263b7 := allocGlyphMemory(1)
	refabf263b7 := (*C.fz_glyph)(memabf263b7)
	allocsabf263b7 := new(cgoAllocMap)
	allocsabf263b7.Add(memabf263b7)

	var cstorable_allocs *cgoAllocMap
	refabf263b7.storable, cstorable_allocs = x.Storable.PassValue()
	allocsabf263b7.Borrow(cstorable_allocs)

	var cx_allocs *cgoAllocMap
	refabf263b7.x, cx_allocs = (C.int)(x.X), cgoAllocsUnknown
	allocsabf263b7.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refabf263b7.y, cy_allocs = (C.int)(x.Y), cgoAllocsUnknown
	allocsabf263b7.Borrow(cy_allocs)

	var cw_allocs *cgoAllocMap
	refabf263b7.w, cw_allocs = (C.int)(x.W), cgoAllocsUnknown
	allocsabf263b7.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	refabf263b7.h, ch_allocs = (C.int)(x.H), cgoAllocsUnknown
	allocsabf263b7.Borrow(ch_allocs)

	var cpixmap_allocs *cgoAllocMap
	refabf263b7.pixmap, cpixmap_allocs = unpackSPixmap(x.Pixmap)
	allocsabf263b7.Borrow(cpixmap_allocs)

	var csize_allocs *cgoAllocMap
	refabf263b7.size, csize_allocs = (C.size_t)(x.Size), cgoAllocsUnknown
	allocsabf263b7.Borrow(csize_allocs)

	var cdata_allocs *cgoAllocMap
	refabf263b7.data, cdata_allocs = *(*[1]C.uchar)(unsafe.Pointer(&x.Data)), cgoAllocsUnknown
	allocsabf263b7.Borrow(cdata_allocs)

	x.refabf263b7 = refabf263b7
	x.allocsabf263b7 = allocsabf263b7
	return refabf263b7, allocsabf263b7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Glyph) PassValue() (C.fz_glyph, *cgoAllocMap) {
	if x.refabf263b7 != nil {
		return *x.refabf263b7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Glyph) Deref() {
	if x.refabf263b7 == nil {
		return
	}
	x.Storable = *NewStorableRef(unsafe.Pointer(&x.refabf263b7.storable))
	x.X = (int32)(x.refabf263b7.x)
	x.Y = (int32)(x.refabf263b7.y)
	x.W = (int32)(x.refabf263b7.w)
	x.H = (int32)(x.refabf263b7.h)
	packSPixmap(x.Pixmap, x.refabf263b7.pixmap)
	x.Size = (uint)(x.refabf263b7.size)
	x.Data = *(*[1]byte)(unsafe.Pointer(&x.refabf263b7.data))
}

// allocBitmapMemory allocates memory for type C.fz_bitmap in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBitmapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBitmapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBitmapValue = unsafe.Sizeof([1]C.fz_bitmap{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Bitmap) Ref() *C.fz_bitmap {
	if x == nil {
		return nil
	}
	return x.ref78d20789
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Bitmap) Free() {
	if x != nil && x.allocs78d20789 != nil {
		x.allocs78d20789.(*cgoAllocMap).Free()
		x.ref78d20789 = nil
	}
}

// NewBitmapRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBitmapRef(ref unsafe.Pointer) *Bitmap {
	if ref == nil {
		return nil
	}
	obj := new(Bitmap)
	obj.ref78d20789 = (*C.fz_bitmap)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Bitmap) PassRef() (*C.fz_bitmap, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref78d20789 != nil {
		return x.ref78d20789, nil
	}
	mem78d20789 := allocBitmapMemory(1)
	ref78d20789 := (*C.fz_bitmap)(mem78d20789)
	allocs78d20789 := new(cgoAllocMap)
	allocs78d20789.Add(mem78d20789)

	var crefs_allocs *cgoAllocMap
	ref78d20789.refs, crefs_allocs = (C.int)(x.Refs), cgoAllocsUnknown
	allocs78d20789.Borrow(crefs_allocs)

	var cw_allocs *cgoAllocMap
	ref78d20789.w, cw_allocs = (C.int)(x.W), cgoAllocsUnknown
	allocs78d20789.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	ref78d20789.h, ch_allocs = (C.int)(x.H), cgoAllocsUnknown
	allocs78d20789.Borrow(ch_allocs)

	var cstride_allocs *cgoAllocMap
	ref78d20789.stride, cstride_allocs = (C.int)(x.Stride), cgoAllocsUnknown
	allocs78d20789.Borrow(cstride_allocs)

	var cn_allocs *cgoAllocMap
	ref78d20789.n, cn_allocs = (C.int)(x.N), cgoAllocsUnknown
	allocs78d20789.Borrow(cn_allocs)

	var cxres_allocs *cgoAllocMap
	ref78d20789.xres, cxres_allocs = (C.int)(x.Xres), cgoAllocsUnknown
	allocs78d20789.Borrow(cxres_allocs)

	var cyres_allocs *cgoAllocMap
	ref78d20789.yres, cyres_allocs = (C.int)(x.Yres), cgoAllocsUnknown
	allocs78d20789.Borrow(cyres_allocs)

	var csamples_allocs *cgoAllocMap
	ref78d20789.samples, csamples_allocs = (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Samples)).Data)), cgoAllocsUnknown
	allocs78d20789.Borrow(csamples_allocs)

	x.ref78d20789 = ref78d20789
	x.allocs78d20789 = allocs78d20789
	return ref78d20789, allocs78d20789

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Bitmap) PassValue() (C.fz_bitmap, *cgoAllocMap) {
	if x.ref78d20789 != nil {
		return *x.ref78d20789, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Bitmap) Deref() {
	if x.ref78d20789 == nil {
		return
	}
	x.Refs = (int32)(x.ref78d20789.refs)
	x.W = (int32)(x.ref78d20789.w)
	x.H = (int32)(x.ref78d20789.h)
	x.Stride = (int32)(x.ref78d20789.stride)
	x.N = (int32)(x.ref78d20789.n)
	x.Xres = (int32)(x.ref78d20789.xres)
	x.Yres = (int32)(x.ref78d20789.yres)
	hxfe93325 := (*sliceHeader)(unsafe.Pointer(&x.Samples))
	hxfe93325.Data = uintptr(unsafe.Pointer(x.ref78d20789.samples))
	hxfe93325.Cap = 0x7fffffff
	// hxfe93325.Len = ?

}

// Ref returns a reference to C object as it is.
func (x *Halftone) Ref() *C.fz_halftone {
	if x == nil {
		return nil
	}
	return (*C.fz_halftone)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Halftone) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewHalftoneRef converts the C object reference into a raw struct reference without wrapping.
func NewHalftoneRef(ref unsafe.Pointer) *Halftone {
	return (*Halftone)(ref)
}

// NewHalftone allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewHalftone() *Halftone {
	return (*Halftone)(allocHalftoneMemory(1))
}

// allocHalftoneMemory allocates memory for type C.fz_halftone in C.
// The caller is responsible for freeing the this memory via C.free.
func allocHalftoneMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfHalftoneValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfHalftoneValue = unsafe.Sizeof([1]C.fz_halftone{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Halftone) PassRef() *C.fz_halftone {
	if x == nil {
		x = (*Halftone)(allocHalftoneMemory(1))
	}
	return (*C.fz_halftone)(unsafe.Pointer(x))
}

// allocImageMemory allocates memory for type C.fz_image in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageValue = unsafe.Sizeof([1]C.fz_image{})

// unpackSImage transforms a sliced Go data structure into plain C format.
func unpackSImage(x []Image) (unpacked *C.fz_image, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_image) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImageMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_image)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_image)(unsafe.Pointer(h.Data))
	return
}

// packSImage reads sliced Go data structure out from plain C format.
func packSImage(v []Image, ptr0 *C.fz_image) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfImageValue]C.fz_image)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewImageRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Image) Ref() *C.fz_image {
	if x == nil {
		return nil
	}
	return x.refc579b050
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Image) Free() {
	if x != nil && x.allocsc579b050 != nil {
		x.allocsc579b050.(*cgoAllocMap).Free()
		x.refc579b050 = nil
	}
}

// NewImageRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageRef(ref unsafe.Pointer) *Image {
	if ref == nil {
		return nil
	}
	obj := new(Image)
	obj.refc579b050 = (*C.fz_image)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Image) PassRef() (*C.fz_image, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc579b050 != nil {
		return x.refc579b050, nil
	}
	memc579b050 := allocImageMemory(1)
	refc579b050 := (*C.fz_image)(memc579b050)
	allocsc579b050 := new(cgoAllocMap)
	allocsc579b050.Add(memc579b050)

	var ckey_storable_allocs *cgoAllocMap
	refc579b050.key_storable, ckey_storable_allocs = x.KeyStorable.PassValue()
	allocsc579b050.Borrow(ckey_storable_allocs)

	var cw_allocs *cgoAllocMap
	refc579b050.w, cw_allocs = (C.int)(x.W), cgoAllocsUnknown
	allocsc579b050.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	refc579b050.h, ch_allocs = (C.int)(x.H), cgoAllocsUnknown
	allocsc579b050.Borrow(ch_allocs)

	var cn_allocs *cgoAllocMap
	refc579b050.n, cn_allocs = (C.uint8_t)(x.N), cgoAllocsUnknown
	allocsc579b050.Borrow(cn_allocs)

	var cbpc_allocs *cgoAllocMap
	refc579b050.bpc, cbpc_allocs = (C.uint8_t)(x.Bpc), cgoAllocsUnknown
	allocsc579b050.Borrow(cbpc_allocs)

	var cimagemask_allocs *cgoAllocMap
	refc579b050.imagemask, cimagemask_allocs = (C.uint)(x.Imagemask), cgoAllocsUnknown
	allocsc579b050.Borrow(cimagemask_allocs)

	var cinterpolate_allocs *cgoAllocMap
	refc579b050.interpolate, cinterpolate_allocs = (C.uint)(x.Interpolate), cgoAllocsUnknown
	allocsc579b050.Borrow(cinterpolate_allocs)

	var cuse_colorkey_allocs *cgoAllocMap
	refc579b050.use_colorkey, cuse_colorkey_allocs = (C.uint)(x.UseColorkey), cgoAllocsUnknown
	allocsc579b050.Borrow(cuse_colorkey_allocs)

	var cuse_decode_allocs *cgoAllocMap
	refc579b050.use_decode, cuse_decode_allocs = (C.uint)(x.UseDecode), cgoAllocsUnknown
	allocsc579b050.Borrow(cuse_decode_allocs)

	var cinvert_cmyk_jpeg_allocs *cgoAllocMap
	refc579b050.invert_cmyk_jpeg, cinvert_cmyk_jpeg_allocs = (C.uint)(x.InvertCmykJpeg), cgoAllocsUnknown
	allocsc579b050.Borrow(cinvert_cmyk_jpeg_allocs)

	var cdecoded_allocs *cgoAllocMap
	refc579b050.decoded, cdecoded_allocs = (C.uint)(x.Decoded), cgoAllocsUnknown
	allocsc579b050.Borrow(cdecoded_allocs)

	var cscalable_allocs *cgoAllocMap
	refc579b050.scalable, cscalable_allocs = (C.uint)(x.Scalable), cgoAllocsUnknown
	allocsc579b050.Borrow(cscalable_allocs)

	var cmask_allocs *cgoAllocMap
	refc579b050.mask, cmask_allocs = unpackSImage(x.Mask)
	allocsc579b050.Borrow(cmask_allocs)

	var cxres_allocs *cgoAllocMap
	refc579b050.xres, cxres_allocs = (C.int)(x.Xres), cgoAllocsUnknown
	allocsc579b050.Borrow(cxres_allocs)

	var cyres_allocs *cgoAllocMap
	refc579b050.yres, cyres_allocs = (C.int)(x.Yres), cgoAllocsUnknown
	allocsc579b050.Borrow(cyres_allocs)

	var ccolorspace_allocs *cgoAllocMap
	refc579b050.colorspace, ccolorspace_allocs = (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Colorspace)).Data)), cgoAllocsUnknown
	allocsc579b050.Borrow(ccolorspace_allocs)

	var cdrop_image_allocs *cgoAllocMap
	refc579b050.drop_image, cdrop_image_allocs = x.DropImage.PassRef()
	allocsc579b050.Borrow(cdrop_image_allocs)

	var cget_pixmap_allocs *cgoAllocMap
	refc579b050.get_pixmap, cget_pixmap_allocs = x.GetPixmap.PassRef()
	allocsc579b050.Borrow(cget_pixmap_allocs)

	var cget_size_allocs *cgoAllocMap
	refc579b050.get_size, cget_size_allocs = x.GetSize.PassRef()
	allocsc579b050.Borrow(cget_size_allocs)

	var ccolorkey_allocs *cgoAllocMap
	refc579b050.colorkey, ccolorkey_allocs = *(*[64]C.int)(unsafe.Pointer(&x.Colorkey)), cgoAllocsUnknown
	allocsc579b050.Borrow(ccolorkey_allocs)

	var cdecode_allocs *cgoAllocMap
	refc579b050.decode, cdecode_allocs = *(*[64]C.float)(unsafe.Pointer(&x.Decode)), cgoAllocsUnknown
	allocsc579b050.Borrow(cdecode_allocs)

	x.refc579b050 = refc579b050
	x.allocsc579b050 = allocsc579b050
	return refc579b050, allocsc579b050

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Image) PassValue() (C.fz_image, *cgoAllocMap) {
	if x.refc579b050 != nil {
		return *x.refc579b050, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Image) Deref() {
	if x.refc579b050 == nil {
		return
	}
	x.KeyStorable = *NewKeyStorableRef(unsafe.Pointer(&x.refc579b050.key_storable))
	x.W = (int32)(x.refc579b050.w)
	x.H = (int32)(x.refc579b050.h)
	x.N = (byte)(x.refc579b050.n)
	x.Bpc = (byte)(x.refc579b050.bpc)
	x.Imagemask = (uint32)(x.refc579b050.imagemask)
	x.Interpolate = (uint32)(x.refc579b050.interpolate)
	x.UseColorkey = (uint32)(x.refc579b050.use_colorkey)
	x.UseDecode = (uint32)(x.refc579b050.use_decode)
	x.InvertCmykJpeg = (uint32)(x.refc579b050.invert_cmyk_jpeg)
	x.Decoded = (uint32)(x.refc579b050.decoded)
	x.Scalable = (uint32)(x.refc579b050.scalable)
	packSImage(x.Mask, x.refc579b050.mask)
	x.Xres = (int32)(x.refc579b050.xres)
	x.Yres = (int32)(x.refc579b050.yres)
	hxf09ea94 := (*sliceHeader)(unsafe.Pointer(&x.Colorspace))
	hxf09ea94.Data = uintptr(unsafe.Pointer(x.refc579b050.colorspace))
	hxf09ea94.Cap = 0x7fffffff
	// hxf09ea94.Len = ?

	x.DropImage = NewDropImageFnRef(unsafe.Pointer(x.refc579b050.drop_image))
	x.GetPixmap = NewImageGetPixmapFnRef(unsafe.Pointer(x.refc579b050.get_pixmap))
	x.GetSize = NewImageGetSizeFnRef(unsafe.Pointer(x.refc579b050.get_size))
	x.Colorkey = *(*[64]int32)(unsafe.Pointer(&x.refc579b050.colorkey))
	x.Decode = *(*[64]float32)(unsafe.Pointer(&x.refc579b050.decode))
}

// Ref returns a reference to C object as it is.
func (x *CompressedImage) Ref() *C.fz_compressed_image {
	if x == nil {
		return nil
	}
	return (*C.fz_compressed_image)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CompressedImage) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCompressedImageRef converts the C object reference into a raw struct reference without wrapping.
func NewCompressedImageRef(ref unsafe.Pointer) *CompressedImage {
	return (*CompressedImage)(ref)
}

// NewCompressedImage allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCompressedImage() *CompressedImage {
	return (*CompressedImage)(allocCompressedImageMemory(1))
}

// allocCompressedImageMemory allocates memory for type C.fz_compressed_image in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCompressedImageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCompressedImageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCompressedImageValue = unsafe.Sizeof([1]C.fz_compressed_image{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CompressedImage) PassRef() *C.fz_compressed_image {
	if x == nil {
		x = (*CompressedImage)(allocCompressedImageMemory(1))
	}
	return (*C.fz_compressed_image)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PixmapImage) Ref() *C.fz_pixmap_image {
	if x == nil {
		return nil
	}
	return (*C.fz_pixmap_image)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PixmapImage) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPixmapImageRef converts the C object reference into a raw struct reference without wrapping.
func NewPixmapImageRef(ref unsafe.Pointer) *PixmapImage {
	return (*PixmapImage)(ref)
}

// NewPixmapImage allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPixmapImage() *PixmapImage {
	return (*PixmapImage)(allocPixmapImageMemory(1))
}

// allocPixmapImageMemory allocates memory for type C.fz_pixmap_image in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPixmapImageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPixmapImageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPixmapImageValue = unsafe.Sizeof([1]C.fz_pixmap_image{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PixmapImage) PassRef() *C.fz_pixmap_image {
	if x == nil {
		x = (*PixmapImage)(allocPixmapImageMemory(1))
	}
	return (*C.fz_pixmap_image)(unsafe.Pointer(x))
}

func (x DropImageFn) PassRef() (ref *C.fz_drop_image_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if dropImageFn37D8BE50Func == nil {
		dropImageFn37D8BE50Func = x
	}
	return (*C.fz_drop_image_fn)(C.fz_drop_image_fn_37d8be50), nil
}

func NewDropImageFnRef(ref unsafe.Pointer) *DropImageFn {
	return (*DropImageFn)(ref)
}

//export dropImageFn37D8BE50
func dropImageFn37D8BE50(cctx *C.fz_context, cimage *C.fz_image) {
	if dropImageFn37D8BE50Func != nil {
		var ctx37d8be50 []Context
		packSContext(ctx37d8be50, cctx)
		var image37d8be50 []Image
		packSImage(image37d8be50, cimage)
		dropImageFn37D8BE50Func(ctx37d8be50, image37d8be50)
		return
	}
	panic("callback func has not been set (race?)")
}

var dropImageFn37D8BE50Func DropImageFn

// unpackArgSPixmap transforms a sliced Go data structure into plain C format.
func unpackArgSPixmap(x []Pixmap) (unpacked *C.fz_pixmap, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_pixmap) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPixmapMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_pixmap)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_pixmap)(unsafe.Pointer(h.Data))
	return
}

func (x ImageGetPixmapFn) PassRef() (ref *C.fz_image_get_pixmap_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if imageGetPixmapFnE97EE8EBFunc == nil {
		imageGetPixmapFnE97EE8EBFunc = x
	}
	return (*C.fz_image_get_pixmap_fn)(C.fz_image_get_pixmap_fn_e97ee8eb), nil
}

func NewImageGetPixmapFnRef(ref unsafe.Pointer) *ImageGetPixmapFn {
	return (*ImageGetPixmapFn)(ref)
}

//export imageGetPixmapFnE97EE8EB
func imageGetPixmapFnE97EE8EB(cctx *C.fz_context, cim *C.fz_image, csubarea *C.fz_irect, cw C.int, ch C.int, cl2factor *C.int) *C.fz_pixmap {
	if imageGetPixmapFnE97EE8EBFunc != nil {
		var ctxe97ee8eb []Context
		packSContext(ctxe97ee8eb, cctx)
		var ime97ee8eb []Image
		packSImage(ime97ee8eb, cim)
		var subareae97ee8eb []Irect
		packSIrect(subareae97ee8eb, csubarea)
		we97ee8eb := (int32)(cw)
		he97ee8eb := (int32)(ch)
		var l2factore97ee8eb []int32
		hxfd687ee := (*sliceHeader)(unsafe.Pointer(&l2factore97ee8eb))
		hxfd687ee.Data = uintptr(unsafe.Pointer(cl2factor))
		hxfd687ee.Cap = 0x7fffffff
		// hxfd687ee.Len = ?

		rete97ee8eb := imageGetPixmapFnE97EE8EBFunc(ctxe97ee8eb, ime97ee8eb, subareae97ee8eb, we97ee8eb, he97ee8eb, l2factore97ee8eb)
		ret, _ := unpackArgSPixmap(rete97ee8eb)
		return ret
	}
	panic("callback func has not been set (race?)")
}

var imageGetPixmapFnE97EE8EBFunc ImageGetPixmapFn

func (x ImageGetSizeFn) PassRef() (ref *C.fz_image_get_size_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if imageGetSizeFn7202727CFunc == nil {
		imageGetSizeFn7202727CFunc = x
	}
	return (*C.fz_image_get_size_fn)(C.fz_image_get_size_fn_7202727c), nil
}

func NewImageGetSizeFnRef(ref unsafe.Pointer) *ImageGetSizeFn {
	return (*ImageGetSizeFn)(ref)
}

//export imageGetSizeFn7202727C
func imageGetSizeFn7202727C(carg0 *C.fz_context, carg1 *C.fz_image) C.size_t {
	if imageGetSizeFn7202727CFunc != nil {
		var arg07202727c []Context
		packSContext(arg07202727c, carg0)
		var arg17202727c []Image
		packSImage(arg17202727c, carg1)
		ret7202727c := imageGetSizeFn7202727CFunc(arg07202727c, arg17202727c)
		ret, _ := (C.size_t)(ret7202727c), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var imageGetSizeFn7202727CFunc ImageGetSizeFn

// allocShadeMemory allocates memory for type C.fz_shade in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShadeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShadeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfShadeValue = unsafe.Sizeof([1]C.fz_shade{})

// unpackSCompressedBuffer transforms a sliced Go data structure into plain C format.
func unpackSCompressedBuffer(x []CompressedBuffer) (unpacked *C.fz_compressed_buffer, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_compressed_buffer) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCompressedBufferMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_compressed_buffer)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_compressed_buffer)(unsafe.Pointer(h.Data))
	return
}

// packSCompressedBuffer reads sliced Go data structure out from plain C format.
func packSCompressedBuffer(v []CompressedBuffer, ptr0 *C.fz_compressed_buffer) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCompressedBufferValue]C.fz_compressed_buffer)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCompressedBufferRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Shade) Ref() *C.fz_shade {
	if x == nil {
		return nil
	}
	return x.reff3da9c82
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Shade) Free() {
	if x != nil && x.allocsf3da9c82 != nil {
		x.allocsf3da9c82.(*cgoAllocMap).Free()
		x.reff3da9c82 = nil
	}
}

// NewShadeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewShadeRef(ref unsafe.Pointer) *Shade {
	if ref == nil {
		return nil
	}
	obj := new(Shade)
	obj.reff3da9c82 = (*C.fz_shade)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Shade) PassRef() (*C.fz_shade, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff3da9c82 != nil {
		return x.reff3da9c82, nil
	}
	memf3da9c82 := allocShadeMemory(1)
	reff3da9c82 := (*C.fz_shade)(memf3da9c82)
	allocsf3da9c82 := new(cgoAllocMap)
	allocsf3da9c82.Add(memf3da9c82)

	var cstorable_allocs *cgoAllocMap
	reff3da9c82.storable, cstorable_allocs = x.Storable.PassValue()
	allocsf3da9c82.Borrow(cstorable_allocs)

	var cbbox_allocs *cgoAllocMap
	reff3da9c82.bbox, cbbox_allocs = x.Bbox.PassValue()
	allocsf3da9c82.Borrow(cbbox_allocs)

	var ccolorspace_allocs *cgoAllocMap
	reff3da9c82.colorspace, ccolorspace_allocs = (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Colorspace)).Data)), cgoAllocsUnknown
	allocsf3da9c82.Borrow(ccolorspace_allocs)

	var cmatrix_allocs *cgoAllocMap
	reff3da9c82.matrix, cmatrix_allocs = x.Matrix.PassValue()
	allocsf3da9c82.Borrow(cmatrix_allocs)

	var cuse_background_allocs *cgoAllocMap
	reff3da9c82.use_background, cuse_background_allocs = (C.int)(x.UseBackground), cgoAllocsUnknown
	allocsf3da9c82.Borrow(cuse_background_allocs)

	var cbackground_allocs *cgoAllocMap
	reff3da9c82.background, cbackground_allocs = *(*[32]C.float)(unsafe.Pointer(&x.Background)), cgoAllocsUnknown
	allocsf3da9c82.Borrow(cbackground_allocs)

	var cuse_function_allocs *cgoAllocMap
	reff3da9c82.use_function, cuse_function_allocs = (C.int)(x.UseFunction), cgoAllocsUnknown
	allocsf3da9c82.Borrow(cuse_function_allocs)

	var cfunction_allocs *cgoAllocMap
	reff3da9c82.function, cfunction_allocs = *(*[256][33]C.float)(unsafe.Pointer(&x.Function)), cgoAllocsUnknown
	allocsf3da9c82.Borrow(cfunction_allocs)

	var c_type_allocs *cgoAllocMap
	reff3da9c82._type, c_type_allocs = (C.int)(x.Type), cgoAllocsUnknown
	allocsf3da9c82.Borrow(c_type_allocs)

	var cbuffer_allocs *cgoAllocMap
	reff3da9c82.buffer, cbuffer_allocs = unpackSCompressedBuffer(x.Buffer)
	allocsf3da9c82.Borrow(cbuffer_allocs)

	x.reff3da9c82 = reff3da9c82
	x.allocsf3da9c82 = allocsf3da9c82
	return reff3da9c82, allocsf3da9c82

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Shade) PassValue() (C.fz_shade, *cgoAllocMap) {
	if x.reff3da9c82 != nil {
		return *x.reff3da9c82, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Shade) Deref() {
	if x.reff3da9c82 == nil {
		return
	}
	x.Storable = *NewStorableRef(unsafe.Pointer(&x.reff3da9c82.storable))
	x.Bbox = *NewRectRef(unsafe.Pointer(&x.reff3da9c82.bbox))
	hxf15a567 := (*sliceHeader)(unsafe.Pointer(&x.Colorspace))
	hxf15a567.Data = uintptr(unsafe.Pointer(x.reff3da9c82.colorspace))
	hxf15a567.Cap = 0x7fffffff
	// hxf15a567.Len = ?

	x.Matrix = *NewMatrixRef(unsafe.Pointer(&x.reff3da9c82.matrix))
	x.UseBackground = (int32)(x.reff3da9c82.use_background)
	x.Background = *(*[32]float32)(unsafe.Pointer(&x.reff3da9c82.background))
	x.UseFunction = (int32)(x.reff3da9c82.use_function)
	x.Function = *(*[256][33]float32)(unsafe.Pointer(&x.reff3da9c82.function))
	x.Type = (int32)(x.reff3da9c82._type)
	packSCompressedBuffer(x.Buffer, x.reff3da9c82.buffer)
}

// allocVertexMemory allocates memory for type C.fz_vertex in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVertexMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVertexValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVertexValue = unsafe.Sizeof([1]C.fz_vertex{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Vertex) Ref() *C.fz_vertex {
	if x == nil {
		return nil
	}
	return x.ref794e2010
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Vertex) Free() {
	if x != nil && x.allocs794e2010 != nil {
		x.allocs794e2010.(*cgoAllocMap).Free()
		x.ref794e2010 = nil
	}
}

// NewVertexRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVertexRef(ref unsafe.Pointer) *Vertex {
	if ref == nil {
		return nil
	}
	obj := new(Vertex)
	obj.ref794e2010 = (*C.fz_vertex)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Vertex) PassRef() (*C.fz_vertex, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref794e2010 != nil {
		return x.ref794e2010, nil
	}
	mem794e2010 := allocVertexMemory(1)
	ref794e2010 := (*C.fz_vertex)(mem794e2010)
	allocs794e2010 := new(cgoAllocMap)
	allocs794e2010.Add(mem794e2010)

	var cp_allocs *cgoAllocMap
	ref794e2010.p, cp_allocs = x.P.PassValue()
	allocs794e2010.Borrow(cp_allocs)

	var cc_allocs *cgoAllocMap
	ref794e2010.c, cc_allocs = *(*[32]C.float)(unsafe.Pointer(&x.C)), cgoAllocsUnknown
	allocs794e2010.Borrow(cc_allocs)

	x.ref794e2010 = ref794e2010
	x.allocs794e2010 = allocs794e2010
	return ref794e2010, allocs794e2010

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Vertex) PassValue() (C.fz_vertex, *cgoAllocMap) {
	if x.ref794e2010 != nil {
		return *x.ref794e2010, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Vertex) Deref() {
	if x.ref794e2010 == nil {
		return
	}
	x.P = *NewPointRef(unsafe.Pointer(&x.ref794e2010.p))
	x.C = *(*[32]float32)(unsafe.Pointer(&x.ref794e2010.c))
}

// packSVertex reads sliced Go data structure out from plain C format.
func packSVertex(v []Vertex, ptr0 *C.fz_vertex) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfVertexValue]C.fz_vertex)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVertexRef(unsafe.Pointer(&ptr1))
	}
}

func (x ShadePrepareFn) PassRef() (ref *C.fz_shade_prepare_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if shadePrepareFn6A663594Func == nil {
		shadePrepareFn6A663594Func = x
	}
	return (*C.fz_shade_prepare_fn)(C.fz_shade_prepare_fn_6a663594), nil
}

func NewShadePrepareFnRef(ref unsafe.Pointer) *ShadePrepareFn {
	return (*ShadePrepareFn)(ref)
}

//export shadePrepareFn6A663594
func shadePrepareFn6A663594(cctx *C.fz_context, carg unsafe.Pointer, cv *C.fz_vertex, cc *C.float) {
	if shadePrepareFn6A663594Func != nil {
		var ctx6a663594 []Context
		packSContext(ctx6a663594, cctx)
		arg6a663594 := (unsafe.Pointer)(unsafe.Pointer(carg))
		var v6a663594 []Vertex
		packSVertex(v6a663594, cv)
		var c6a663594 []float32
		hxf8aebb5 := (*sliceHeader)(unsafe.Pointer(&c6a663594))
		hxf8aebb5.Data = uintptr(unsafe.Pointer(cc))
		hxf8aebb5.Cap = 0x7fffffff
		// hxf8aebb5.Len = ?

		shadePrepareFn6A663594Func(ctx6a663594, arg6a663594, v6a663594, c6a663594)
		return
	}
	panic("callback func has not been set (race?)")
}

var shadePrepareFn6A663594Func ShadePrepareFn

func (x ShadeProcessFn) PassRef() (ref *C.fz_shade_process_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if shadeProcessFn7E13CCEAFunc == nil {
		shadeProcessFn7E13CCEAFunc = x
	}
	return (*C.fz_shade_process_fn)(C.fz_shade_process_fn_7e13ccea), nil
}

func NewShadeProcessFnRef(ref unsafe.Pointer) *ShadeProcessFn {
	return (*ShadeProcessFn)(ref)
}

//export shadeProcessFn7E13CCEA
func shadeProcessFn7E13CCEA(cctx *C.fz_context, carg unsafe.Pointer, cav *C.fz_vertex, cbv *C.fz_vertex, ccv *C.fz_vertex) {
	if shadeProcessFn7E13CCEAFunc != nil {
		var ctx7e13ccea []Context
		packSContext(ctx7e13ccea, cctx)
		arg7e13ccea := (unsafe.Pointer)(unsafe.Pointer(carg))
		var av7e13ccea []Vertex
		packSVertex(av7e13ccea, cav)
		var bv7e13ccea []Vertex
		packSVertex(bv7e13ccea, cbv)
		var cv7e13ccea []Vertex
		packSVertex(cv7e13ccea, ccv)
		shadeProcessFn7E13CCEAFunc(ctx7e13ccea, arg7e13ccea, av7e13ccea, bv7e13ccea, cv7e13ccea)
		return
	}
	panic("callback func has not been set (race?)")
}

var shadeProcessFn7E13CCEAFunc ShadeProcessFn

// Ref returns a reference to C object as it is.
func (x *Font) Ref() *C.fz_font {
	if x == nil {
		return nil
	}
	return (*C.fz_font)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Font) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFontRef converts the C object reference into a raw struct reference without wrapping.
func NewFontRef(ref unsafe.Pointer) *Font {
	return (*Font)(ref)
}

// NewFont allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFont() *Font {
	return (*Font)(allocFontMemory(1))
}

// allocFontMemory allocates memory for type C.fz_font in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFontMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFontValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFontValue = unsafe.Sizeof([1]C.fz_font{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Font) PassRef() *C.fz_font {
	if x == nil {
		x = (*Font)(allocFontMemory(1))
	}
	return (*C.fz_font)(unsafe.Pointer(x))
}

// allocFontFlagsMemory allocates memory for type C.fz_font_flags_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFontFlagsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFontFlagsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFontFlagsValue = unsafe.Sizeof([1]C.fz_font_flags_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FontFlags) Ref() *C.fz_font_flags_t {
	if x == nil {
		return nil
	}
	return x.refe29ef004
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FontFlags) Free() {
	if x != nil && x.allocse29ef004 != nil {
		x.allocse29ef004.(*cgoAllocMap).Free()
		x.refe29ef004 = nil
	}
}

// NewFontFlagsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFontFlagsRef(ref unsafe.Pointer) *FontFlags {
	if ref == nil {
		return nil
	}
	obj := new(FontFlags)
	obj.refe29ef004 = (*C.fz_font_flags_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FontFlags) PassRef() (*C.fz_font_flags_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe29ef004 != nil {
		return x.refe29ef004, nil
	}
	meme29ef004 := allocFontFlagsMemory(1)
	refe29ef004 := (*C.fz_font_flags_t)(meme29ef004)
	allocse29ef004 := new(cgoAllocMap)
	allocse29ef004.Add(meme29ef004)

	var cis_mono_allocs *cgoAllocMap
	refe29ef004.is_mono, cis_mono_allocs = (C.uint)(x.IsMono), cgoAllocsUnknown
	allocse29ef004.Borrow(cis_mono_allocs)

	var cis_serif_allocs *cgoAllocMap
	refe29ef004.is_serif, cis_serif_allocs = (C.uint)(x.IsSerif), cgoAllocsUnknown
	allocse29ef004.Borrow(cis_serif_allocs)

	var cis_bold_allocs *cgoAllocMap
	refe29ef004.is_bold, cis_bold_allocs = (C.uint)(x.IsBold), cgoAllocsUnknown
	allocse29ef004.Borrow(cis_bold_allocs)

	var cis_italic_allocs *cgoAllocMap
	refe29ef004.is_italic, cis_italic_allocs = (C.uint)(x.IsItalic), cgoAllocsUnknown
	allocse29ef004.Borrow(cis_italic_allocs)

	var cft_substitute_allocs *cgoAllocMap
	refe29ef004.ft_substitute, cft_substitute_allocs = (C.uint)(x.FtSubstitute), cgoAllocsUnknown
	allocse29ef004.Borrow(cft_substitute_allocs)

	var cft_stretch_allocs *cgoAllocMap
	refe29ef004.ft_stretch, cft_stretch_allocs = (C.uint)(x.FtStretch), cgoAllocsUnknown
	allocse29ef004.Borrow(cft_stretch_allocs)

	var cfake_bold_allocs *cgoAllocMap
	refe29ef004.fake_bold, cfake_bold_allocs = (C.uint)(x.FakeBold), cgoAllocsUnknown
	allocse29ef004.Borrow(cfake_bold_allocs)

	var cfake_italic_allocs *cgoAllocMap
	refe29ef004.fake_italic, cfake_italic_allocs = (C.uint)(x.FakeItalic), cgoAllocsUnknown
	allocse29ef004.Borrow(cfake_italic_allocs)

	var cforce_hinting_allocs *cgoAllocMap
	refe29ef004.force_hinting, cforce_hinting_allocs = (C.uint)(x.ForceHinting), cgoAllocsUnknown
	allocse29ef004.Borrow(cforce_hinting_allocs)

	var chas_opentype_allocs *cgoAllocMap
	refe29ef004.has_opentype, chas_opentype_allocs = (C.uint)(x.HasOpentype), cgoAllocsUnknown
	allocse29ef004.Borrow(chas_opentype_allocs)

	var cinvalid_bbox_allocs *cgoAllocMap
	refe29ef004.invalid_bbox, cinvalid_bbox_allocs = (C.uint)(x.InvalidBbox), cgoAllocsUnknown
	allocse29ef004.Borrow(cinvalid_bbox_allocs)

	x.refe29ef004 = refe29ef004
	x.allocse29ef004 = allocse29ef004
	return refe29ef004, allocse29ef004

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FontFlags) PassValue() (C.fz_font_flags_t, *cgoAllocMap) {
	if x.refe29ef004 != nil {
		return *x.refe29ef004, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FontFlags) Deref() {
	if x.refe29ef004 == nil {
		return
	}
	x.IsMono = (uint32)(x.refe29ef004.is_mono)
	x.IsSerif = (uint32)(x.refe29ef004.is_serif)
	x.IsBold = (uint32)(x.refe29ef004.is_bold)
	x.IsItalic = (uint32)(x.refe29ef004.is_italic)
	x.FtSubstitute = (uint32)(x.refe29ef004.ft_substitute)
	x.FtStretch = (uint32)(x.refe29ef004.ft_stretch)
	x.FakeBold = (uint32)(x.refe29ef004.fake_bold)
	x.FakeItalic = (uint32)(x.refe29ef004.fake_italic)
	x.ForceHinting = (uint32)(x.refe29ef004.force_hinting)
	x.HasOpentype = (uint32)(x.refe29ef004.has_opentype)
	x.InvalidBbox = (uint32)(x.refe29ef004.invalid_bbox)
}

// allocShaperDataMemory allocates memory for type C.fz_shaper_data_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShaperDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShaperDataValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfShaperDataValue = unsafe.Sizeof([1]C.fz_shaper_data_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ShaperData) Ref() *C.fz_shaper_data_t {
	if x == nil {
		return nil
	}
	return x.ref5fc0bb0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ShaperData) Free() {
	if x != nil && x.allocs5fc0bb0 != nil {
		x.allocs5fc0bb0.(*cgoAllocMap).Free()
		x.ref5fc0bb0 = nil
	}
}

// NewShaperDataRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewShaperDataRef(ref unsafe.Pointer) *ShaperData {
	if ref == nil {
		return nil
	}
	obj := new(ShaperData)
	obj.ref5fc0bb0 = (*C.fz_shaper_data_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ShaperData) PassRef() (*C.fz_shaper_data_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5fc0bb0 != nil {
		return x.ref5fc0bb0, nil
	}
	mem5fc0bb0 := allocShaperDataMemory(1)
	ref5fc0bb0 := (*C.fz_shaper_data_t)(mem5fc0bb0)
	allocs5fc0bb0 := new(cgoAllocMap)
	allocs5fc0bb0.Add(mem5fc0bb0)

	var cshaper_handle_allocs *cgoAllocMap
	ref5fc0bb0.shaper_handle, cshaper_handle_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.ShaperHandle)), cgoAllocsUnknown
	allocs5fc0bb0.Borrow(cshaper_handle_allocs)

	var cdestroy_allocs *cgoAllocMap
	ref5fc0bb0.destroy, cdestroy_allocs = x.Destroy.PassRef()
	allocs5fc0bb0.Borrow(cdestroy_allocs)

	x.ref5fc0bb0 = ref5fc0bb0
	x.allocs5fc0bb0 = allocs5fc0bb0
	return ref5fc0bb0, allocs5fc0bb0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ShaperData) PassValue() (C.fz_shaper_data_t, *cgoAllocMap) {
	if x.ref5fc0bb0 != nil {
		return *x.ref5fc0bb0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ShaperData) Deref() {
	if x.ref5fc0bb0 == nil {
		return
	}
	x.ShaperHandle = (unsafe.Pointer)(unsafe.Pointer(x.ref5fc0bb0.shaper_handle))
	x.Destroy = NewRef(unsafe.Pointer(x.ref5fc0bb0.destroy))
}

func (x LoadSystemFontFn) PassRef() (ref *C.fz_load_system_font_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if loadSystemFontFnCF2C657Func == nil {
		loadSystemFontFnCF2C657Func = x
	}
	return (*C.fz_load_system_font_fn)(C.fz_load_system_font_fn_cf2c657), nil
}

func NewLoadSystemFontFnRef(ref unsafe.Pointer) *LoadSystemFontFn {
	return (*LoadSystemFontFn)(ref)
}

//export loadSystemFontFnCF2C657
func loadSystemFontFnCF2C657(cctx *C.fz_context, cname *C.char, cbold C.int, citalic C.int, cneedsExactMetrics C.int) *C.fz_font {
	if loadSystemFontFnCF2C657Func != nil {
		var ctxcf2c657 []Context
		packSContext(ctxcf2c657, cctx)
		namecf2c657 := packPCharString(cname)
		boldcf2c657 := (int32)(cbold)
		italiccf2c657 := (int32)(citalic)
		needsExactMetricscf2c657 := (int32)(cneedsExactMetrics)
		retcf2c657 := loadSystemFontFnCF2C657Func(ctxcf2c657, namecf2c657, boldcf2c657, italiccf2c657, needsExactMetricscf2c657)
		ret, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&retcf2c657)).Data)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var loadSystemFontFnCF2C657Func LoadSystemFontFn

func (x LoadSystemCjkFontFn) PassRef() (ref *C.fz_load_system_cjk_font_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if loadSystemCjkFontFnB491FED9Func == nil {
		loadSystemCjkFontFnB491FED9Func = x
	}
	return (*C.fz_load_system_cjk_font_fn)(C.fz_load_system_cjk_font_fn_b491fed9), nil
}

func NewLoadSystemCjkFontFnRef(ref unsafe.Pointer) *LoadSystemCjkFontFn {
	return (*LoadSystemCjkFontFn)(ref)
}

//export loadSystemCjkFontFnB491FED9
func loadSystemCjkFontFnB491FED9(cctx *C.fz_context, cname *C.char, cros C.int, cserif C.int) *C.fz_font {
	if loadSystemCjkFontFnB491FED9Func != nil {
		var ctxb491fed9 []Context
		packSContext(ctxb491fed9, cctx)
		nameb491fed9 := packPCharString(cname)
		rosb491fed9 := (int32)(cros)
		serifb491fed9 := (int32)(cserif)
		retb491fed9 := loadSystemCjkFontFnB491FED9Func(ctxb491fed9, nameb491fed9, rosb491fed9, serifb491fed9)
		ret, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&retb491fed9)).Data)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var loadSystemCjkFontFnB491FED9Func LoadSystemCjkFontFn

func (x LoadSystemFallbackFontFn) PassRef() (ref *C.fz_load_system_fallback_font_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if loadSystemFallbackFontFn36CB0CBFunc == nil {
		loadSystemFallbackFontFn36CB0CBFunc = x
	}
	return (*C.fz_load_system_fallback_font_fn)(C.fz_load_system_fallback_font_fn_36cb0cb), nil
}

func NewLoadSystemFallbackFontFnRef(ref unsafe.Pointer) *LoadSystemFallbackFontFn {
	return (*LoadSystemFallbackFontFn)(ref)
}

//export loadSystemFallbackFontFn36CB0CB
func loadSystemFallbackFontFn36CB0CB(cctx *C.fz_context, cscript C.int, clanguage C.int, cserif C.int, cbold C.int, citalic C.int) *C.fz_font {
	if loadSystemFallbackFontFn36CB0CBFunc != nil {
		var ctx36cb0cb []Context
		packSContext(ctx36cb0cb, cctx)
		script36cb0cb := (int32)(cscript)
		language36cb0cb := (int32)(clanguage)
		serif36cb0cb := (int32)(cserif)
		bold36cb0cb := (int32)(cbold)
		italic36cb0cb := (int32)(citalic)
		ret36cb0cb := loadSystemFallbackFontFn36CB0CBFunc(ctx36cb0cb, script36cb0cb, language36cb0cb, serif36cb0cb, bold36cb0cb, italic36cb0cb)
		ret, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ret36cb0cb)).Data)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var loadSystemFallbackFontFn36CB0CBFunc LoadSystemFallbackFontFn

// Ref returns a reference to C object as it is.
func (x *Path) Ref() *C.fz_path {
	if x == nil {
		return nil
	}
	return (*C.fz_path)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Path) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPathRef converts the C object reference into a raw struct reference without wrapping.
func NewPathRef(ref unsafe.Pointer) *Path {
	return (*Path)(ref)
}

// NewPath allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPath() *Path {
	return (*Path)(allocPathMemory(1))
}

// allocPathMemory allocates memory for type C.fz_path in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPathMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPathValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPathValue = unsafe.Sizeof([1]C.fz_path{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Path) PassRef() *C.fz_path {
	if x == nil {
		x = (*Path)(allocPathMemory(1))
	}
	return (*C.fz_path)(unsafe.Pointer(x))
}

// allocStrokeStateMemory allocates memory for type C.fz_stroke_state in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStrokeStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStrokeStateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStrokeStateValue = unsafe.Sizeof([1]C.fz_stroke_state{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StrokeState) Ref() *C.fz_stroke_state {
	if x == nil {
		return nil
	}
	return x.ref19a30a2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StrokeState) Free() {
	if x != nil && x.allocs19a30a2 != nil {
		x.allocs19a30a2.(*cgoAllocMap).Free()
		x.ref19a30a2 = nil
	}
}

// NewStrokeStateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStrokeStateRef(ref unsafe.Pointer) *StrokeState {
	if ref == nil {
		return nil
	}
	obj := new(StrokeState)
	obj.ref19a30a2 = (*C.fz_stroke_state)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StrokeState) PassRef() (*C.fz_stroke_state, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref19a30a2 != nil {
		return x.ref19a30a2, nil
	}
	mem19a30a2 := allocStrokeStateMemory(1)
	ref19a30a2 := (*C.fz_stroke_state)(mem19a30a2)
	allocs19a30a2 := new(cgoAllocMap)
	allocs19a30a2.Add(mem19a30a2)

	var crefs_allocs *cgoAllocMap
	ref19a30a2.refs, crefs_allocs = (C.int)(x.Refs), cgoAllocsUnknown
	allocs19a30a2.Borrow(crefs_allocs)

	var cstart_cap_allocs *cgoAllocMap
	ref19a30a2.start_cap, cstart_cap_allocs = (C.fz_linecap)(x.StartCap), cgoAllocsUnknown
	allocs19a30a2.Borrow(cstart_cap_allocs)

	var cdash_cap_allocs *cgoAllocMap
	ref19a30a2.dash_cap, cdash_cap_allocs = (C.fz_linecap)(x.DashCap), cgoAllocsUnknown
	allocs19a30a2.Borrow(cdash_cap_allocs)

	var cend_cap_allocs *cgoAllocMap
	ref19a30a2.end_cap, cend_cap_allocs = (C.fz_linecap)(x.EndCap), cgoAllocsUnknown
	allocs19a30a2.Borrow(cend_cap_allocs)

	var clinejoin_allocs *cgoAllocMap
	ref19a30a2.linejoin, clinejoin_allocs = (C.fz_linejoin)(x.Linejoin), cgoAllocsUnknown
	allocs19a30a2.Borrow(clinejoin_allocs)

	var clinewidth_allocs *cgoAllocMap
	ref19a30a2.linewidth, clinewidth_allocs = (C.float)(x.Linewidth), cgoAllocsUnknown
	allocs19a30a2.Borrow(clinewidth_allocs)

	var cmiterlimit_allocs *cgoAllocMap
	ref19a30a2.miterlimit, cmiterlimit_allocs = (C.float)(x.Miterlimit), cgoAllocsUnknown
	allocs19a30a2.Borrow(cmiterlimit_allocs)

	var cdash_phase_allocs *cgoAllocMap
	ref19a30a2.dash_phase, cdash_phase_allocs = (C.float)(x.DashPhase), cgoAllocsUnknown
	allocs19a30a2.Borrow(cdash_phase_allocs)

	var cdash_len_allocs *cgoAllocMap
	ref19a30a2.dash_len, cdash_len_allocs = (C.int)(x.DashLen), cgoAllocsUnknown
	allocs19a30a2.Borrow(cdash_len_allocs)

	var cdash_list_allocs *cgoAllocMap
	ref19a30a2.dash_list, cdash_list_allocs = *(*[32]C.float)(unsafe.Pointer(&x.DashList)), cgoAllocsUnknown
	allocs19a30a2.Borrow(cdash_list_allocs)

	x.ref19a30a2 = ref19a30a2
	x.allocs19a30a2 = allocs19a30a2
	return ref19a30a2, allocs19a30a2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StrokeState) PassValue() (C.fz_stroke_state, *cgoAllocMap) {
	if x.ref19a30a2 != nil {
		return *x.ref19a30a2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StrokeState) Deref() {
	if x.ref19a30a2 == nil {
		return
	}
	x.Refs = (int32)(x.ref19a30a2.refs)
	x.StartCap = (Linecap)(x.ref19a30a2.start_cap)
	x.DashCap = (Linecap)(x.ref19a30a2.dash_cap)
	x.EndCap = (Linecap)(x.ref19a30a2.end_cap)
	x.Linejoin = (Linejoin)(x.ref19a30a2.linejoin)
	x.Linewidth = (float32)(x.ref19a30a2.linewidth)
	x.Miterlimit = (float32)(x.ref19a30a2.miterlimit)
	x.DashPhase = (float32)(x.ref19a30a2.dash_phase)
	x.DashLen = (int32)(x.ref19a30a2.dash_len)
	x.DashList = *(*[32]float32)(unsafe.Pointer(&x.ref19a30a2.dash_list))
}

// allocPathWalkerMemory allocates memory for type C.fz_path_walker in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPathWalkerMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPathWalkerValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPathWalkerValue = unsafe.Sizeof([1]C.fz_path_walker{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PathWalker) Ref() *C.fz_path_walker {
	if x == nil {
		return nil
	}
	return x.reff1bd6fbf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PathWalker) Free() {
	if x != nil && x.allocsf1bd6fbf != nil {
		x.allocsf1bd6fbf.(*cgoAllocMap).Free()
		x.reff1bd6fbf = nil
	}
}

// NewPathWalkerRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPathWalkerRef(ref unsafe.Pointer) *PathWalker {
	if ref == nil {
		return nil
	}
	obj := new(PathWalker)
	obj.reff1bd6fbf = (*C.fz_path_walker)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PathWalker) PassRef() (*C.fz_path_walker, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff1bd6fbf != nil {
		return x.reff1bd6fbf, nil
	}
	memf1bd6fbf := allocPathWalkerMemory(1)
	reff1bd6fbf := (*C.fz_path_walker)(memf1bd6fbf)
	allocsf1bd6fbf := new(cgoAllocMap)
	allocsf1bd6fbf.Add(memf1bd6fbf)

	var cmoveto_allocs *cgoAllocMap
	reff1bd6fbf.moveto, cmoveto_allocs = x.Moveto.PassRef()
	allocsf1bd6fbf.Borrow(cmoveto_allocs)

	var clineto_allocs *cgoAllocMap
	reff1bd6fbf.lineto, clineto_allocs = x.Lineto.PassRef()
	allocsf1bd6fbf.Borrow(clineto_allocs)

	var ccurveto_allocs *cgoAllocMap
	reff1bd6fbf.curveto, ccurveto_allocs = x.Curveto.PassRef()
	allocsf1bd6fbf.Borrow(ccurveto_allocs)

	var cclosepath_allocs *cgoAllocMap
	reff1bd6fbf.closepath, cclosepath_allocs = x.Closepath.PassRef()
	allocsf1bd6fbf.Borrow(cclosepath_allocs)

	var cquadto_allocs *cgoAllocMap
	reff1bd6fbf.quadto, cquadto_allocs = x.Quadto.PassRef()
	allocsf1bd6fbf.Borrow(cquadto_allocs)

	var ccurvetov_allocs *cgoAllocMap
	reff1bd6fbf.curvetov, ccurvetov_allocs = x.Curvetov.PassRef()
	allocsf1bd6fbf.Borrow(ccurvetov_allocs)

	var ccurvetoy_allocs *cgoAllocMap
	reff1bd6fbf.curvetoy, ccurvetoy_allocs = x.Curvetoy.PassRef()
	allocsf1bd6fbf.Borrow(ccurvetoy_allocs)

	var crectto_allocs *cgoAllocMap
	reff1bd6fbf.rectto, crectto_allocs = x.Rectto.PassRef()
	allocsf1bd6fbf.Borrow(crectto_allocs)

	x.reff1bd6fbf = reff1bd6fbf
	x.allocsf1bd6fbf = allocsf1bd6fbf
	return reff1bd6fbf, allocsf1bd6fbf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PathWalker) PassValue() (C.fz_path_walker, *cgoAllocMap) {
	if x.reff1bd6fbf != nil {
		return *x.reff1bd6fbf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PathWalker) Deref() {
	if x.reff1bd6fbf == nil {
		return
	}
	x.Moveto = NewRef(unsafe.Pointer(x.reff1bd6fbf.moveto))
	x.Lineto = NewRef(unsafe.Pointer(x.reff1bd6fbf.lineto))
	x.Curveto = NewRef(unsafe.Pointer(x.reff1bd6fbf.curveto))
	x.Closepath = NewRef(unsafe.Pointer(x.reff1bd6fbf.closepath))
	x.Quadto = NewRef(unsafe.Pointer(x.reff1bd6fbf.quadto))
	x.Curvetov = NewRef(unsafe.Pointer(x.reff1bd6fbf.curvetov))
	x.Curvetoy = NewRef(unsafe.Pointer(x.reff1bd6fbf.curvetoy))
	x.Rectto = NewRef(unsafe.Pointer(x.reff1bd6fbf.rectto))
}

// allocTextMemory allocates memory for type C.fz_text in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTextValue = unsafe.Sizeof([1]C.fz_text{})

// allocTextSpanMemory allocates memory for type C.fz_text_span in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTextSpanMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTextSpanValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTextSpanValue = unsafe.Sizeof([1]C.fz_text_span{})

// unpackSTextSpan transforms a sliced Go data structure into plain C format.
func unpackSTextSpan(x []TextSpan) (unpacked *C.fz_text_span, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_text_span) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocTextSpanMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_text_span)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_text_span)(unsafe.Pointer(h.Data))
	return
}

// packSTextSpan reads sliced Go data structure out from plain C format.
func packSTextSpan(v []TextSpan, ptr0 *C.fz_text_span) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTextSpanValue]C.fz_text_span)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTextSpanRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Text) Ref() *C.fz_text {
	if x == nil {
		return nil
	}
	return x.ref7f3fa8c7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Text) Free() {
	if x != nil && x.allocs7f3fa8c7 != nil {
		x.allocs7f3fa8c7.(*cgoAllocMap).Free()
		x.ref7f3fa8c7 = nil
	}
}

// NewTextRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTextRef(ref unsafe.Pointer) *Text {
	if ref == nil {
		return nil
	}
	obj := new(Text)
	obj.ref7f3fa8c7 = (*C.fz_text)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Text) PassRef() (*C.fz_text, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7f3fa8c7 != nil {
		return x.ref7f3fa8c7, nil
	}
	mem7f3fa8c7 := allocTextMemory(1)
	ref7f3fa8c7 := (*C.fz_text)(mem7f3fa8c7)
	allocs7f3fa8c7 := new(cgoAllocMap)
	allocs7f3fa8c7.Add(mem7f3fa8c7)

	var crefs_allocs *cgoAllocMap
	ref7f3fa8c7.refs, crefs_allocs = (C.int)(x.Refs), cgoAllocsUnknown
	allocs7f3fa8c7.Borrow(crefs_allocs)

	var chead_allocs *cgoAllocMap
	ref7f3fa8c7.head, chead_allocs = unpackSTextSpan(x.Head)
	allocs7f3fa8c7.Borrow(chead_allocs)

	var ctail_allocs *cgoAllocMap
	ref7f3fa8c7.tail, ctail_allocs = unpackSTextSpan(x.Tail)
	allocs7f3fa8c7.Borrow(ctail_allocs)

	x.ref7f3fa8c7 = ref7f3fa8c7
	x.allocs7f3fa8c7 = allocs7f3fa8c7
	return ref7f3fa8c7, allocs7f3fa8c7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Text) PassValue() (C.fz_text, *cgoAllocMap) {
	if x.ref7f3fa8c7 != nil {
		return *x.ref7f3fa8c7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Text) Deref() {
	if x.ref7f3fa8c7 == nil {
		return
	}
	x.Refs = (int32)(x.ref7f3fa8c7.refs)
	packSTextSpan(x.Head, x.ref7f3fa8c7.head)
	packSTextSpan(x.Tail, x.ref7f3fa8c7.tail)
}

// allocTextItemMemory allocates memory for type C.fz_text_item in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTextItemMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTextItemValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTextItemValue = unsafe.Sizeof([1]C.fz_text_item{})

// unpackSTextItem transforms a sliced Go data structure into plain C format.
func unpackSTextItem(x []TextItem) (unpacked *C.fz_text_item, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_text_item) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocTextItemMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_text_item)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_text_item)(unsafe.Pointer(h.Data))
	return
}

// packSTextItem reads sliced Go data structure out from plain C format.
func packSTextItem(v []TextItem, ptr0 *C.fz_text_item) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTextItemValue]C.fz_text_item)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTextItemRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TextSpan) Ref() *C.fz_text_span {
	if x == nil {
		return nil
	}
	return x.refd38c1c29
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TextSpan) Free() {
	if x != nil && x.allocsd38c1c29 != nil {
		x.allocsd38c1c29.(*cgoAllocMap).Free()
		x.refd38c1c29 = nil
	}
}

// NewTextSpanRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTextSpanRef(ref unsafe.Pointer) *TextSpan {
	if ref == nil {
		return nil
	}
	obj := new(TextSpan)
	obj.refd38c1c29 = (*C.fz_text_span)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TextSpan) PassRef() (*C.fz_text_span, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd38c1c29 != nil {
		return x.refd38c1c29, nil
	}
	memd38c1c29 := allocTextSpanMemory(1)
	refd38c1c29 := (*C.fz_text_span)(memd38c1c29)
	allocsd38c1c29 := new(cgoAllocMap)
	allocsd38c1c29.Add(memd38c1c29)

	var cfont_allocs *cgoAllocMap
	refd38c1c29.font, cfont_allocs = (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Font)).Data)), cgoAllocsUnknown
	allocsd38c1c29.Borrow(cfont_allocs)

	var ctrm_allocs *cgoAllocMap
	refd38c1c29.trm, ctrm_allocs = x.Trm.PassValue()
	allocsd38c1c29.Borrow(ctrm_allocs)

	var cwmode_allocs *cgoAllocMap
	refd38c1c29.wmode, cwmode_allocs = (C.uint)(x.Wmode), cgoAllocsUnknown
	allocsd38c1c29.Borrow(cwmode_allocs)

	var cbidi_level_allocs *cgoAllocMap
	refd38c1c29.bidi_level, cbidi_level_allocs = (C.uint)(x.BidiLevel), cgoAllocsUnknown
	allocsd38c1c29.Borrow(cbidi_level_allocs)

	var cmarkup_dir_allocs *cgoAllocMap
	refd38c1c29.markup_dir, cmarkup_dir_allocs = (C.uint)(x.MarkupDir), cgoAllocsUnknown
	allocsd38c1c29.Borrow(cmarkup_dir_allocs)

	var clanguage_allocs *cgoAllocMap
	refd38c1c29.language, clanguage_allocs = (C.uint)(x.Language), cgoAllocsUnknown
	allocsd38c1c29.Borrow(clanguage_allocs)

	var clen_allocs *cgoAllocMap
	refd38c1c29.len, clen_allocs = (C.int)(x.Len), cgoAllocsUnknown
	allocsd38c1c29.Borrow(clen_allocs)

	var ccap_allocs *cgoAllocMap
	refd38c1c29.cap, ccap_allocs = (C.int)(x.Cap), cgoAllocsUnknown
	allocsd38c1c29.Borrow(ccap_allocs)

	var citems_allocs *cgoAllocMap
	refd38c1c29.items, citems_allocs = unpackSTextItem(x.Items)
	allocsd38c1c29.Borrow(citems_allocs)

	var cnext_allocs *cgoAllocMap
	refd38c1c29.next, cnext_allocs = unpackSTextSpan(x.Next)
	allocsd38c1c29.Borrow(cnext_allocs)

	x.refd38c1c29 = refd38c1c29
	x.allocsd38c1c29 = allocsd38c1c29
	return refd38c1c29, allocsd38c1c29

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TextSpan) PassValue() (C.fz_text_span, *cgoAllocMap) {
	if x.refd38c1c29 != nil {
		return *x.refd38c1c29, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TextSpan) Deref() {
	if x.refd38c1c29 == nil {
		return
	}
	hxf5d30cf := (*sliceHeader)(unsafe.Pointer(&x.Font))
	hxf5d30cf.Data = uintptr(unsafe.Pointer(x.refd38c1c29.font))
	hxf5d30cf.Cap = 0x7fffffff
	// hxf5d30cf.Len = ?

	x.Trm = *NewMatrixRef(unsafe.Pointer(&x.refd38c1c29.trm))
	x.Wmode = (uint32)(x.refd38c1c29.wmode)
	x.BidiLevel = (uint32)(x.refd38c1c29.bidi_level)
	x.MarkupDir = (uint32)(x.refd38c1c29.markup_dir)
	x.Language = (uint32)(x.refd38c1c29.language)
	x.Len = (int32)(x.refd38c1c29.len)
	x.Cap = (int32)(x.refd38c1c29.cap)
	packSTextItem(x.Items, x.refd38c1c29.items)
	packSTextSpan(x.Next, x.refd38c1c29.next)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TextItem) Ref() *C.fz_text_item {
	if x == nil {
		return nil
	}
	return x.ref164497b0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TextItem) Free() {
	if x != nil && x.allocs164497b0 != nil {
		x.allocs164497b0.(*cgoAllocMap).Free()
		x.ref164497b0 = nil
	}
}

// NewTextItemRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTextItemRef(ref unsafe.Pointer) *TextItem {
	if ref == nil {
		return nil
	}
	obj := new(TextItem)
	obj.ref164497b0 = (*C.fz_text_item)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TextItem) PassRef() (*C.fz_text_item, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref164497b0 != nil {
		return x.ref164497b0, nil
	}
	mem164497b0 := allocTextItemMemory(1)
	ref164497b0 := (*C.fz_text_item)(mem164497b0)
	allocs164497b0 := new(cgoAllocMap)
	allocs164497b0.Add(mem164497b0)

	var cx_allocs *cgoAllocMap
	ref164497b0.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocs164497b0.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref164497b0.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocs164497b0.Borrow(cy_allocs)

	var cgid_allocs *cgoAllocMap
	ref164497b0.gid, cgid_allocs = (C.int)(x.Gid), cgoAllocsUnknown
	allocs164497b0.Borrow(cgid_allocs)

	var cucs_allocs *cgoAllocMap
	ref164497b0.ucs, cucs_allocs = (C.int)(x.Ucs), cgoAllocsUnknown
	allocs164497b0.Borrow(cucs_allocs)

	x.ref164497b0 = ref164497b0
	x.allocs164497b0 = allocs164497b0
	return ref164497b0, allocs164497b0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TextItem) PassValue() (C.fz_text_item, *cgoAllocMap) {
	if x.ref164497b0 != nil {
		return *x.ref164497b0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TextItem) Deref() {
	if x.ref164497b0 == nil {
		return
	}
	x.X = (float32)(x.ref164497b0.x)
	x.Y = (float32)(x.ref164497b0.y)
	x.Gid = (int32)(x.ref164497b0.gid)
	x.Ucs = (int32)(x.ref164497b0.ucs)
}

func (x CmmNewInstanceFn) PassRef() (ref *C.fz_cmm_new_instance_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if cmmNewInstanceFn3BC12687Func == nil {
		cmmNewInstanceFn3BC12687Func = x
	}
	return (*C.fz_cmm_new_instance_fn)(C.fz_cmm_new_instance_fn_3bc12687), nil
}

func NewCmmNewInstanceFnRef(ref unsafe.Pointer) *CmmNewInstanceFn {
	return (*CmmNewInstanceFn)(ref)
}

//export cmmNewInstanceFn3BC12687
func cmmNewInstanceFn3BC12687(cctx *C.fz_context) *C.fz_cmm_instance {
	if cmmNewInstanceFn3BC12687Func != nil {
		var ctx3bc12687 []Context
		packSContext(ctx3bc12687, cctx)
		ret3bc12687 := cmmNewInstanceFn3BC12687Func(ctx3bc12687)
		ret, _ := (*C.fz_cmm_instance)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ret3bc12687)).Data)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var cmmNewInstanceFn3BC12687Func CmmNewInstanceFn

func (x CmmDropInstanceFn) PassRef() (ref *C.fz_cmm_drop_instance_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if cmmDropInstanceFn8FCE668Func == nil {
		cmmDropInstanceFn8FCE668Func = x
	}
	return (*C.fz_cmm_drop_instance_fn)(C.fz_cmm_drop_instance_fn_8fce668), nil
}

func NewCmmDropInstanceFnRef(ref unsafe.Pointer) *CmmDropInstanceFn {
	return (*CmmDropInstanceFn)(ref)
}

//export cmmDropInstanceFn8FCE668
func cmmDropInstanceFn8FCE668(cinstance *C.fz_cmm_instance) {
	if cmmDropInstanceFn8FCE668Func != nil {
		var instance8fce668 []CmmInstance
		hxf882e98 := (*sliceHeader)(unsafe.Pointer(&instance8fce668))
		hxf882e98.Data = uintptr(unsafe.Pointer(cinstance))
		hxf882e98.Cap = 0x7fffffff
		// hxf882e98.Len = ?

		cmmDropInstanceFn8FCE668Func(instance8fce668)
		return
	}
	panic("callback func has not been set (race?)")
}

var cmmDropInstanceFn8FCE668Func CmmDropInstanceFn

func (x CmmTransformPixmapFn) PassRef() (ref *C.fz_cmm_transform_pixmap_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if cmmTransformPixmapFnA9AD9719Func == nil {
		cmmTransformPixmapFnA9AD9719Func = x
	}
	return (*C.fz_cmm_transform_pixmap_fn)(C.fz_cmm_transform_pixmap_fn_a9ad9719), nil
}

func NewCmmTransformPixmapFnRef(ref unsafe.Pointer) *CmmTransformPixmapFn {
	return (*CmmTransformPixmapFn)(ref)
}

//export cmmTransformPixmapFnA9AD9719
func cmmTransformPixmapFnA9AD9719(cctx *C.fz_cmm_instance, clink *C.fz_icclink, cdst *C.fz_pixmap, csrc *C.fz_pixmap) {
	if cmmTransformPixmapFnA9AD9719Func != nil {
		var ctxa9ad9719 []CmmInstance
		hxf992404 := (*sliceHeader)(unsafe.Pointer(&ctxa9ad9719))
		hxf992404.Data = uintptr(unsafe.Pointer(cctx))
		hxf992404.Cap = 0x7fffffff
		// hxf992404.Len = ?

		var linka9ad9719 []Icclink
		hxf8e0dd2 := (*sliceHeader)(unsafe.Pointer(&linka9ad9719))
		hxf8e0dd2.Data = uintptr(unsafe.Pointer(clink))
		hxf8e0dd2.Cap = 0x7fffffff
		// hxf8e0dd2.Len = ?

		var dsta9ad9719 []Pixmap
		packSPixmap(dsta9ad9719, cdst)
		var srca9ad9719 []Pixmap
		packSPixmap(srca9ad9719, csrc)
		cmmTransformPixmapFnA9AD9719Func(ctxa9ad9719, linka9ad9719, dsta9ad9719, srca9ad9719)
		return
	}
	panic("callback func has not been set (race?)")
}

var cmmTransformPixmapFnA9AD9719Func CmmTransformPixmapFn

func (x CmmTransformColorFn) PassRef() (ref *C.fz_cmm_transform_color_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if cmmTransformColorFn1CD2D69FFunc == nil {
		cmmTransformColorFn1CD2D69FFunc = x
	}
	return (*C.fz_cmm_transform_color_fn)(C.fz_cmm_transform_color_fn_1cd2d69f), nil
}

func NewCmmTransformColorFnRef(ref unsafe.Pointer) *CmmTransformColorFn {
	return (*CmmTransformColorFn)(ref)
}

//export cmmTransformColorFn1CD2D69F
func cmmTransformColorFn1CD2D69F(cctx *C.fz_cmm_instance, clink *C.fz_icclink, cdst *C.ushort, csrc *C.ushort) {
	if cmmTransformColorFn1CD2D69FFunc != nil {
		var ctx1cd2d69f []CmmInstance
		hxf44d909 := (*sliceHeader)(unsafe.Pointer(&ctx1cd2d69f))
		hxf44d909.Data = uintptr(unsafe.Pointer(cctx))
		hxf44d909.Cap = 0x7fffffff
		// hxf44d909.Len = ?

		var link1cd2d69f []Icclink
		hxfa835e7 := (*sliceHeader)(unsafe.Pointer(&link1cd2d69f))
		hxfa835e7.Data = uintptr(unsafe.Pointer(clink))
		hxfa835e7.Cap = 0x7fffffff
		// hxfa835e7.Len = ?

		var dst1cd2d69f []uint16
		hxf8eae10 := (*sliceHeader)(unsafe.Pointer(&dst1cd2d69f))
		hxf8eae10.Data = uintptr(unsafe.Pointer(cdst))
		hxf8eae10.Cap = 0x7fffffff
		// hxf8eae10.Len = ?

		var src1cd2d69f []uint16
		hxfeb55cf := (*sliceHeader)(unsafe.Pointer(&src1cd2d69f))
		hxfeb55cf.Data = uintptr(unsafe.Pointer(csrc))
		hxfeb55cf.Cap = 0x7fffffff
		// hxfeb55cf.Len = ?

		cmmTransformColorFn1CD2D69FFunc(ctx1cd2d69f, link1cd2d69f, dst1cd2d69f, src1cd2d69f)
		return
	}
	panic("callback func has not been set (race?)")
}

var cmmTransformColorFn1CD2D69FFunc CmmTransformColorFn

func (x CmmInitLinkFn) PassRef() (ref *C.fz_cmm_init_link_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if cmmInitLinkFn2C234A07Func == nil {
		cmmInitLinkFn2C234A07Func = x
	}
	return (*C.fz_cmm_init_link_fn)(C.fz_cmm_init_link_fn_2c234a07), nil
}

func NewCmmInitLinkFnRef(ref unsafe.Pointer) *CmmInitLinkFn {
	return (*CmmInitLinkFn)(ref)
}

//export cmmInitLinkFn2C234A07
func cmmInitLinkFn2C234A07(cctx *C.fz_cmm_instance, clink *C.fz_icclink, cdst *C.fz_iccprofile, cdstExtras C.int, csrc *C.fz_iccprofile, csrcExtras C.int, cprf *C.fz_iccprofile, crend *C.fz_color_params, ccmmFlags C.int, cnumBytes C.int, ccopySpots C.int) {
	if cmmInitLinkFn2C234A07Func != nil {
		var ctx2c234a07 []CmmInstance
		hxf458096 := (*sliceHeader)(unsafe.Pointer(&ctx2c234a07))
		hxf458096.Data = uintptr(unsafe.Pointer(cctx))
		hxf458096.Cap = 0x7fffffff
		// hxf458096.Len = ?

		var link2c234a07 []Icclink
		hxf9aab83 := (*sliceHeader)(unsafe.Pointer(&link2c234a07))
		hxf9aab83.Data = uintptr(unsafe.Pointer(clink))
		hxf9aab83.Cap = 0x7fffffff
		// hxf9aab83.Len = ?

		var dst2c234a07 []Iccprofile
		hxf8b35a8 := (*sliceHeader)(unsafe.Pointer(&dst2c234a07))
		hxf8b35a8.Data = uintptr(unsafe.Pointer(cdst))
		hxf8b35a8.Cap = 0x7fffffff
		// hxf8b35a8.Len = ?

		dstExtras2c234a07 := (int32)(cdstExtras)
		var src2c234a07 []Iccprofile
		hxf8959c2 := (*sliceHeader)(unsafe.Pointer(&src2c234a07))
		hxf8959c2.Data = uintptr(unsafe.Pointer(csrc))
		hxf8959c2.Cap = 0x7fffffff
		// hxf8959c2.Len = ?

		srcExtras2c234a07 := (int32)(csrcExtras)
		var prf2c234a07 []Iccprofile
		hxfb029a7 := (*sliceHeader)(unsafe.Pointer(&prf2c234a07))
		hxfb029a7.Data = uintptr(unsafe.Pointer(cprf))
		hxfb029a7.Cap = 0x7fffffff
		// hxfb029a7.Len = ?

		var rend2c234a07 []ColorParams
		packSColorParams(rend2c234a07, crend)
		cmmFlags2c234a07 := (int32)(ccmmFlags)
		numBytes2c234a07 := (int32)(cnumBytes)
		copySpots2c234a07 := (int32)(ccopySpots)
		cmmInitLinkFn2C234A07Func(ctx2c234a07, link2c234a07, dst2c234a07, dstExtras2c234a07, src2c234a07, srcExtras2c234a07, prf2c234a07, rend2c234a07, cmmFlags2c234a07, numBytes2c234a07, copySpots2c234a07)
		return
	}
	panic("callback func has not been set (race?)")
}

var cmmInitLinkFn2C234A07Func CmmInitLinkFn

func (x CmmFinLinkFn) PassRef() (ref *C.fz_cmm_fin_link_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if cmmFinLinkFn2B624A1AFunc == nil {
		cmmFinLinkFn2B624A1AFunc = x
	}
	return (*C.fz_cmm_fin_link_fn)(C.fz_cmm_fin_link_fn_2b624a1a), nil
}

func NewCmmFinLinkFnRef(ref unsafe.Pointer) *CmmFinLinkFn {
	return (*CmmFinLinkFn)(ref)
}

//export cmmFinLinkFn2B624A1A
func cmmFinLinkFn2B624A1A(cctx *C.fz_cmm_instance, clink *C.fz_icclink) {
	if cmmFinLinkFn2B624A1AFunc != nil {
		var ctx2b624a1a []CmmInstance
		hxf7d15a2 := (*sliceHeader)(unsafe.Pointer(&ctx2b624a1a))
		hxf7d15a2.Data = uintptr(unsafe.Pointer(cctx))
		hxf7d15a2.Cap = 0x7fffffff
		// hxf7d15a2.Len = ?

		var link2b624a1a []Icclink
		hxf8dbbe5 := (*sliceHeader)(unsafe.Pointer(&link2b624a1a))
		hxf8dbbe5.Data = uintptr(unsafe.Pointer(clink))
		hxf8dbbe5.Cap = 0x7fffffff
		// hxf8dbbe5.Len = ?

		cmmFinLinkFn2B624A1AFunc(ctx2b624a1a, link2b624a1a)
		return
	}
	panic("callback func has not been set (race?)")
}

var cmmFinLinkFn2B624A1AFunc CmmFinLinkFn

func (x CmmInitProfileFn) PassRef() (ref *C.fz_cmm_init_profile_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if cmmInitProfileFn5D5A5731Func == nil {
		cmmInitProfileFn5D5A5731Func = x
	}
	return (*C.fz_cmm_init_profile_fn)(C.fz_cmm_init_profile_fn_5d5a5731), nil
}

func NewCmmInitProfileFnRef(ref unsafe.Pointer) *CmmInitProfileFn {
	return (*CmmInitProfileFn)(ref)
}

//export cmmInitProfileFn5D5A5731
func cmmInitProfileFn5D5A5731(cctx *C.fz_cmm_instance, cprofile *C.fz_iccprofile) {
	if cmmInitProfileFn5D5A5731Func != nil {
		var ctx5d5a5731 []CmmInstance
		hxf766ff8 := (*sliceHeader)(unsafe.Pointer(&ctx5d5a5731))
		hxf766ff8.Data = uintptr(unsafe.Pointer(cctx))
		hxf766ff8.Cap = 0x7fffffff
		// hxf766ff8.Len = ?

		var profile5d5a5731 []Iccprofile
		hxf9b1633 := (*sliceHeader)(unsafe.Pointer(&profile5d5a5731))
		hxf9b1633.Data = uintptr(unsafe.Pointer(cprofile))
		hxf9b1633.Cap = 0x7fffffff
		// hxf9b1633.Len = ?

		cmmInitProfileFn5D5A5731Func(ctx5d5a5731, profile5d5a5731)
		return
	}
	panic("callback func has not been set (race?)")
}

var cmmInitProfileFn5D5A5731Func CmmInitProfileFn

func (x CmmFinProfileFn) PassRef() (ref *C.fz_cmm_fin_profile_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if cmmFinProfileFn487F1613Func == nil {
		cmmFinProfileFn487F1613Func = x
	}
	return (*C.fz_cmm_fin_profile_fn)(C.fz_cmm_fin_profile_fn_487f1613), nil
}

func NewCmmFinProfileFnRef(ref unsafe.Pointer) *CmmFinProfileFn {
	return (*CmmFinProfileFn)(ref)
}

//export cmmFinProfileFn487F1613
func cmmFinProfileFn487F1613(cctx *C.fz_cmm_instance, cprofile *C.fz_iccprofile) {
	if cmmFinProfileFn487F1613Func != nil {
		var ctx487f1613 []CmmInstance
		hxf502c9a := (*sliceHeader)(unsafe.Pointer(&ctx487f1613))
		hxf502c9a.Data = uintptr(unsafe.Pointer(cctx))
		hxf502c9a.Cap = 0x7fffffff
		// hxf502c9a.Len = ?

		var profile487f1613 []Iccprofile
		hxf4a9453 := (*sliceHeader)(unsafe.Pointer(&profile487f1613))
		hxf4a9453.Data = uintptr(unsafe.Pointer(cprofile))
		hxf4a9453.Cap = 0x7fffffff
		// hxf4a9453.Len = ?

		cmmFinProfileFn487F1613Func(ctx487f1613, profile487f1613)
		return
	}
	panic("callback func has not been set (race?)")
}

var cmmFinProfileFn487F1613Func CmmFinProfileFn

// allocDeviceMemory allocates memory for type C.fz_device in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceValue = unsafe.Sizeof([1]C.fz_device{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Device) Ref() *C.fz_device {
	if x == nil {
		return nil
	}
	return x.ref9990efab
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Device) Free() {
	if x != nil && x.allocs9990efab != nil {
		x.allocs9990efab.(*cgoAllocMap).Free()
		x.ref9990efab = nil
	}
}

// NewDeviceRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDeviceRef(ref unsafe.Pointer) *Device {
	if ref == nil {
		return nil
	}
	obj := new(Device)
	obj.ref9990efab = (*C.fz_device)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Device) PassRef() (*C.fz_device, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9990efab != nil {
		return x.ref9990efab, nil
	}
	mem9990efab := allocDeviceMemory(1)
	ref9990efab := (*C.fz_device)(mem9990efab)
	allocs9990efab := new(cgoAllocMap)
	allocs9990efab.Add(mem9990efab)

	var crefs_allocs *cgoAllocMap
	ref9990efab.refs, crefs_allocs = (C.int)(x.Refs), cgoAllocsUnknown
	allocs9990efab.Borrow(crefs_allocs)

	var chints_allocs *cgoAllocMap
	ref9990efab.hints, chints_allocs = (C.int)(x.Hints), cgoAllocsUnknown
	allocs9990efab.Borrow(chints_allocs)

	var cflags_allocs *cgoAllocMap
	ref9990efab.flags, cflags_allocs = (C.int)(x.Flags), cgoAllocsUnknown
	allocs9990efab.Borrow(cflags_allocs)

	var cclose_device_allocs *cgoAllocMap
	ref9990efab.close_device, cclose_device_allocs = x.CloseDevice.PassRef()
	allocs9990efab.Borrow(cclose_device_allocs)

	var cdrop_device_allocs *cgoAllocMap
	ref9990efab.drop_device, cdrop_device_allocs = x.DropDevice.PassRef()
	allocs9990efab.Borrow(cdrop_device_allocs)

	var cfill_path_allocs *cgoAllocMap
	ref9990efab.fill_path, cfill_path_allocs = x.FillPath.PassRef()
	allocs9990efab.Borrow(cfill_path_allocs)

	var cstroke_path_allocs *cgoAllocMap
	ref9990efab.stroke_path, cstroke_path_allocs = x.StrokePath.PassRef()
	allocs9990efab.Borrow(cstroke_path_allocs)

	var cclip_path_allocs *cgoAllocMap
	ref9990efab.clip_path, cclip_path_allocs = x.ClipPath.PassRef()
	allocs9990efab.Borrow(cclip_path_allocs)

	var cclip_stroke_path_allocs *cgoAllocMap
	ref9990efab.clip_stroke_path, cclip_stroke_path_allocs = x.ClipStrokePath.PassRef()
	allocs9990efab.Borrow(cclip_stroke_path_allocs)

	var cfill_text_allocs *cgoAllocMap
	ref9990efab.fill_text, cfill_text_allocs = x.FillText.PassRef()
	allocs9990efab.Borrow(cfill_text_allocs)

	var cstroke_text_allocs *cgoAllocMap
	ref9990efab.stroke_text, cstroke_text_allocs = x.StrokeText.PassRef()
	allocs9990efab.Borrow(cstroke_text_allocs)

	var cclip_text_allocs *cgoAllocMap
	ref9990efab.clip_text, cclip_text_allocs = x.ClipText.PassRef()
	allocs9990efab.Borrow(cclip_text_allocs)

	var cclip_stroke_text_allocs *cgoAllocMap
	ref9990efab.clip_stroke_text, cclip_stroke_text_allocs = x.ClipStrokeText.PassRef()
	allocs9990efab.Borrow(cclip_stroke_text_allocs)

	var cignore_text_allocs *cgoAllocMap
	ref9990efab.ignore_text, cignore_text_allocs = x.IgnoreText.PassRef()
	allocs9990efab.Borrow(cignore_text_allocs)

	var cfill_shade_allocs *cgoAllocMap
	ref9990efab.fill_shade, cfill_shade_allocs = x.FillShade.PassRef()
	allocs9990efab.Borrow(cfill_shade_allocs)

	var cfill_image_allocs *cgoAllocMap
	ref9990efab.fill_image, cfill_image_allocs = x.FillImage.PassRef()
	allocs9990efab.Borrow(cfill_image_allocs)

	var cfill_image_mask_allocs *cgoAllocMap
	ref9990efab.fill_image_mask, cfill_image_mask_allocs = x.FillImageMask.PassRef()
	allocs9990efab.Borrow(cfill_image_mask_allocs)

	var cclip_image_mask_allocs *cgoAllocMap
	ref9990efab.clip_image_mask, cclip_image_mask_allocs = x.ClipImageMask.PassRef()
	allocs9990efab.Borrow(cclip_image_mask_allocs)

	var cpop_clip_allocs *cgoAllocMap
	ref9990efab.pop_clip, cpop_clip_allocs = x.PopClip.PassRef()
	allocs9990efab.Borrow(cpop_clip_allocs)

	var cbegin_mask_allocs *cgoAllocMap
	ref9990efab.begin_mask, cbegin_mask_allocs = x.BeginMask.PassRef()
	allocs9990efab.Borrow(cbegin_mask_allocs)

	var cend_mask_allocs *cgoAllocMap
	ref9990efab.end_mask, cend_mask_allocs = x.EndMask.PassRef()
	allocs9990efab.Borrow(cend_mask_allocs)

	var cbegin_group_allocs *cgoAllocMap
	ref9990efab.begin_group, cbegin_group_allocs = x.BeginGroup.PassRef()
	allocs9990efab.Borrow(cbegin_group_allocs)

	var cend_group_allocs *cgoAllocMap
	ref9990efab.end_group, cend_group_allocs = x.EndGroup.PassRef()
	allocs9990efab.Borrow(cend_group_allocs)

	var cbegin_tile_allocs *cgoAllocMap
	ref9990efab.begin_tile, cbegin_tile_allocs = x.BeginTile.PassRef()
	allocs9990efab.Borrow(cbegin_tile_allocs)

	var cend_tile_allocs *cgoAllocMap
	ref9990efab.end_tile, cend_tile_allocs = x.EndTile.PassRef()
	allocs9990efab.Borrow(cend_tile_allocs)

	var crender_flags_allocs *cgoAllocMap
	ref9990efab.render_flags, crender_flags_allocs = x.RenderFlags.PassRef()
	allocs9990efab.Borrow(crender_flags_allocs)

	var cset_default_colorspaces_allocs *cgoAllocMap
	ref9990efab.set_default_colorspaces, cset_default_colorspaces_allocs = x.SetDefaultColorspaces.PassRef()
	allocs9990efab.Borrow(cset_default_colorspaces_allocs)

	var cd1_rect_allocs *cgoAllocMap
	ref9990efab.d1_rect, cd1_rect_allocs = x.D1Rect.PassValue()
	allocs9990efab.Borrow(cd1_rect_allocs)

	var cerror_depth_allocs *cgoAllocMap
	ref9990efab.error_depth, cerror_depth_allocs = (C.int)(x.ErrorDepth), cgoAllocsUnknown
	allocs9990efab.Borrow(cerror_depth_allocs)

	var cerrmess_allocs *cgoAllocMap
	ref9990efab.errmess, cerrmess_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Errmess)), cgoAllocsUnknown
	allocs9990efab.Borrow(cerrmess_allocs)

	var ccontainer_len_allocs *cgoAllocMap
	ref9990efab.container_len, ccontainer_len_allocs = (C.int)(x.ContainerLen), cgoAllocsUnknown
	allocs9990efab.Borrow(ccontainer_len_allocs)

	var ccontainer_cap_allocs *cgoAllocMap
	ref9990efab.container_cap, ccontainer_cap_allocs = (C.int)(x.ContainerCap), cgoAllocsUnknown
	allocs9990efab.Borrow(ccontainer_cap_allocs)

	var ccontainer_allocs *cgoAllocMap
	ref9990efab.container, ccontainer_allocs = (*C.fz_device_container_stack)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Container)).Data)), cgoAllocsUnknown
	allocs9990efab.Borrow(ccontainer_allocs)

	x.ref9990efab = ref9990efab
	x.allocs9990efab = allocs9990efab
	return ref9990efab, allocs9990efab

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Device) PassValue() (C.fz_device, *cgoAllocMap) {
	if x.ref9990efab != nil {
		return *x.ref9990efab, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Device) Deref() {
	if x.ref9990efab == nil {
		return
	}
	x.Refs = (int32)(x.ref9990efab.refs)
	x.Hints = (int32)(x.ref9990efab.hints)
	x.Flags = (int32)(x.ref9990efab.flags)
	x.CloseDevice = NewRef(unsafe.Pointer(x.ref9990efab.close_device))
	x.DropDevice = NewRef(unsafe.Pointer(x.ref9990efab.drop_device))
	x.FillPath = NewRef(unsafe.Pointer(x.ref9990efab.fill_path))
	x.StrokePath = NewRef(unsafe.Pointer(x.ref9990efab.stroke_path))
	x.ClipPath = NewRef(unsafe.Pointer(x.ref9990efab.clip_path))
	x.ClipStrokePath = NewRef(unsafe.Pointer(x.ref9990efab.clip_stroke_path))
	x.FillText = NewRef(unsafe.Pointer(x.ref9990efab.fill_text))
	x.StrokeText = NewRef(unsafe.Pointer(x.ref9990efab.stroke_text))
	x.ClipText = NewRef(unsafe.Pointer(x.ref9990efab.clip_text))
	x.ClipStrokeText = NewRef(unsafe.Pointer(x.ref9990efab.clip_stroke_text))
	x.IgnoreText = NewRef(unsafe.Pointer(x.ref9990efab.ignore_text))
	x.FillShade = NewRef(unsafe.Pointer(x.ref9990efab.fill_shade))
	x.FillImage = NewRef(unsafe.Pointer(x.ref9990efab.fill_image))
	x.FillImageMask = NewRef(unsafe.Pointer(x.ref9990efab.fill_image_mask))
	x.ClipImageMask = NewRef(unsafe.Pointer(x.ref9990efab.clip_image_mask))
	x.PopClip = NewRef(unsafe.Pointer(x.ref9990efab.pop_clip))
	x.BeginMask = NewRef(unsafe.Pointer(x.ref9990efab.begin_mask))
	x.EndMask = NewRef(unsafe.Pointer(x.ref9990efab.end_mask))
	x.BeginGroup = NewRef(unsafe.Pointer(x.ref9990efab.begin_group))
	x.EndGroup = NewRef(unsafe.Pointer(x.ref9990efab.end_group))
	x.BeginTile = NewRef(unsafe.Pointer(x.ref9990efab.begin_tile))
	x.EndTile = NewRef(unsafe.Pointer(x.ref9990efab.end_tile))
	x.RenderFlags = NewRef(unsafe.Pointer(x.ref9990efab.render_flags))
	x.SetDefaultColorspaces = NewRef(unsafe.Pointer(x.ref9990efab.set_default_colorspaces))
	x.D1Rect = *NewRectRef(unsafe.Pointer(&x.ref9990efab.d1_rect))
	x.ErrorDepth = (int32)(x.ref9990efab.error_depth)
	x.Errmess = *(*[256]byte)(unsafe.Pointer(&x.ref9990efab.errmess))
	x.ContainerLen = (int32)(x.ref9990efab.container_len)
	x.ContainerCap = (int32)(x.ref9990efab.container_cap)
	hxf1a1416 := (*sliceHeader)(unsafe.Pointer(&x.Container))
	hxf1a1416.Data = uintptr(unsafe.Pointer(x.ref9990efab.container))
	hxf1a1416.Cap = 0x7fffffff
	// hxf1a1416.Len = ?

}

// Ref returns a reference to C object as it is.
func (x *DeviceContainerStack) Ref() *C.fz_device_container_stack {
	if x == nil {
		return nil
	}
	return (*C.fz_device_container_stack)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DeviceContainerStack) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDeviceContainerStackRef converts the C object reference into a raw struct reference without wrapping.
func NewDeviceContainerStackRef(ref unsafe.Pointer) *DeviceContainerStack {
	return (*DeviceContainerStack)(ref)
}

// NewDeviceContainerStack allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDeviceContainerStack() *DeviceContainerStack {
	return (*DeviceContainerStack)(allocDeviceContainerStackMemory(1))
}

// allocDeviceContainerStackMemory allocates memory for type C.fz_device_container_stack in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceContainerStackMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceContainerStackValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceContainerStackValue = unsafe.Sizeof([1]C.fz_device_container_stack{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DeviceContainerStack) PassRef() *C.fz_device_container_stack {
	if x == nil {
		x = (*DeviceContainerStack)(allocDeviceContainerStackMemory(1))
	}
	return (*C.fz_device_container_stack)(unsafe.Pointer(x))
}

// allocCookieMemory allocates memory for type C.fz_cookie in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCookieMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCookieValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCookieValue = unsafe.Sizeof([1]C.fz_cookie{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Cookie) Ref() *C.fz_cookie {
	if x == nil {
		return nil
	}
	return x.ref1a5fe343
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Cookie) Free() {
	if x != nil && x.allocs1a5fe343 != nil {
		x.allocs1a5fe343.(*cgoAllocMap).Free()
		x.ref1a5fe343 = nil
	}
}

// NewCookieRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCookieRef(ref unsafe.Pointer) *Cookie {
	if ref == nil {
		return nil
	}
	obj := new(Cookie)
	obj.ref1a5fe343 = (*C.fz_cookie)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Cookie) PassRef() (*C.fz_cookie, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1a5fe343 != nil {
		return x.ref1a5fe343, nil
	}
	mem1a5fe343 := allocCookieMemory(1)
	ref1a5fe343 := (*C.fz_cookie)(mem1a5fe343)
	allocs1a5fe343 := new(cgoAllocMap)
	allocs1a5fe343.Add(mem1a5fe343)

	var cabort_allocs *cgoAllocMap
	ref1a5fe343.abort, cabort_allocs = (C.int)(x.Abort), cgoAllocsUnknown
	allocs1a5fe343.Borrow(cabort_allocs)

	var cprogress_allocs *cgoAllocMap
	ref1a5fe343.progress, cprogress_allocs = (C.int)(x.Progress), cgoAllocsUnknown
	allocs1a5fe343.Borrow(cprogress_allocs)

	var cprogress_max_allocs *cgoAllocMap
	ref1a5fe343.progress_max, cprogress_max_allocs = (C.int)(x.ProgressMax), cgoAllocsUnknown
	allocs1a5fe343.Borrow(cprogress_max_allocs)

	var cerrors_allocs *cgoAllocMap
	ref1a5fe343.errors, cerrors_allocs = (C.int)(x.Errors), cgoAllocsUnknown
	allocs1a5fe343.Borrow(cerrors_allocs)

	var cincomplete_ok_allocs *cgoAllocMap
	ref1a5fe343.incomplete_ok, cincomplete_ok_allocs = (C.int)(x.IncompleteOk), cgoAllocsUnknown
	allocs1a5fe343.Borrow(cincomplete_ok_allocs)

	var cincomplete_allocs *cgoAllocMap
	ref1a5fe343.incomplete, cincomplete_allocs = (C.int)(x.Incomplete), cgoAllocsUnknown
	allocs1a5fe343.Borrow(cincomplete_allocs)

	x.ref1a5fe343 = ref1a5fe343
	x.allocs1a5fe343 = allocs1a5fe343
	return ref1a5fe343, allocs1a5fe343

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Cookie) PassValue() (C.fz_cookie, *cgoAllocMap) {
	if x.ref1a5fe343 != nil {
		return *x.ref1a5fe343, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Cookie) Deref() {
	if x.ref1a5fe343 == nil {
		return
	}
	x.Abort = (int32)(x.ref1a5fe343.abort)
	x.Progress = (int32)(x.ref1a5fe343.progress)
	x.ProgressMax = (int32)(x.ref1a5fe343.progress_max)
	x.Errors = (int32)(x.ref1a5fe343.errors)
	x.IncompleteOk = (int32)(x.ref1a5fe343.incomplete_ok)
	x.Incomplete = (int32)(x.ref1a5fe343.incomplete)
}

// allocDrawOptionsMemory allocates memory for type C.fz_draw_options in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDrawOptionsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDrawOptionsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDrawOptionsValue = unsafe.Sizeof([1]C.fz_draw_options{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DrawOptions) Ref() *C.fz_draw_options {
	if x == nil {
		return nil
	}
	return x.ref4717a0e8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DrawOptions) Free() {
	if x != nil && x.allocs4717a0e8 != nil {
		x.allocs4717a0e8.(*cgoAllocMap).Free()
		x.ref4717a0e8 = nil
	}
}

// NewDrawOptionsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDrawOptionsRef(ref unsafe.Pointer) *DrawOptions {
	if ref == nil {
		return nil
	}
	obj := new(DrawOptions)
	obj.ref4717a0e8 = (*C.fz_draw_options)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DrawOptions) PassRef() (*C.fz_draw_options, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4717a0e8 != nil {
		return x.ref4717a0e8, nil
	}
	mem4717a0e8 := allocDrawOptionsMemory(1)
	ref4717a0e8 := (*C.fz_draw_options)(mem4717a0e8)
	allocs4717a0e8 := new(cgoAllocMap)
	allocs4717a0e8.Add(mem4717a0e8)

	var crotate_allocs *cgoAllocMap
	ref4717a0e8.rotate, crotate_allocs = (C.int)(x.Rotate), cgoAllocsUnknown
	allocs4717a0e8.Borrow(crotate_allocs)

	var cx_resolution_allocs *cgoAllocMap
	ref4717a0e8.x_resolution, cx_resolution_allocs = (C.int)(x.XResolution), cgoAllocsUnknown
	allocs4717a0e8.Borrow(cx_resolution_allocs)

	var cy_resolution_allocs *cgoAllocMap
	ref4717a0e8.y_resolution, cy_resolution_allocs = (C.int)(x.YResolution), cgoAllocsUnknown
	allocs4717a0e8.Borrow(cy_resolution_allocs)

	var cwidth_allocs *cgoAllocMap
	ref4717a0e8.width, cwidth_allocs = (C.int)(x.Width), cgoAllocsUnknown
	allocs4717a0e8.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	ref4717a0e8.height, cheight_allocs = (C.int)(x.Height), cgoAllocsUnknown
	allocs4717a0e8.Borrow(cheight_allocs)

	var ccolorspace_allocs *cgoAllocMap
	ref4717a0e8.colorspace, ccolorspace_allocs = (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Colorspace)).Data)), cgoAllocsUnknown
	allocs4717a0e8.Borrow(ccolorspace_allocs)

	var calpha_allocs *cgoAllocMap
	ref4717a0e8.alpha, calpha_allocs = (C.int)(x.Alpha), cgoAllocsUnknown
	allocs4717a0e8.Borrow(calpha_allocs)

	var cgraphics_allocs *cgoAllocMap
	ref4717a0e8.graphics, cgraphics_allocs = (C.int)(x.Graphics), cgoAllocsUnknown
	allocs4717a0e8.Borrow(cgraphics_allocs)

	var ctext_allocs *cgoAllocMap
	ref4717a0e8.text, ctext_allocs = (C.int)(x.Text), cgoAllocsUnknown
	allocs4717a0e8.Borrow(ctext_allocs)

	x.ref4717a0e8 = ref4717a0e8
	x.allocs4717a0e8 = allocs4717a0e8
	return ref4717a0e8, allocs4717a0e8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DrawOptions) PassValue() (C.fz_draw_options, *cgoAllocMap) {
	if x.ref4717a0e8 != nil {
		return *x.ref4717a0e8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DrawOptions) Deref() {
	if x.ref4717a0e8 == nil {
		return
	}
	x.Rotate = (int32)(x.ref4717a0e8.rotate)
	x.XResolution = (int32)(x.ref4717a0e8.x_resolution)
	x.YResolution = (int32)(x.ref4717a0e8.y_resolution)
	x.Width = (int32)(x.ref4717a0e8.width)
	x.Height = (int32)(x.ref4717a0e8.height)
	hxf92be66 := (*sliceHeader)(unsafe.Pointer(&x.Colorspace))
	hxf92be66.Data = uintptr(unsafe.Pointer(x.ref4717a0e8.colorspace))
	hxf92be66.Cap = 0x7fffffff
	// hxf92be66.Len = ?

	x.Alpha = (int32)(x.ref4717a0e8.alpha)
	x.Graphics = (int32)(x.ref4717a0e8.graphics)
	x.Text = (int32)(x.ref4717a0e8.text)
}

// Ref returns a reference to C object as it is.
func (x *DisplayList) Ref() *C.fz_display_list {
	if x == nil {
		return nil
	}
	return (*C.fz_display_list)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DisplayList) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDisplayListRef converts the C object reference into a raw struct reference without wrapping.
func NewDisplayListRef(ref unsafe.Pointer) *DisplayList {
	return (*DisplayList)(ref)
}

// NewDisplayList allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDisplayList() *DisplayList {
	return (*DisplayList)(allocDisplayListMemory(1))
}

// allocDisplayListMemory allocates memory for type C.fz_display_list in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDisplayListMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDisplayListValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDisplayListValue = unsafe.Sizeof([1]C.fz_display_list{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DisplayList) PassRef() *C.fz_display_list {
	if x == nil {
		x = (*DisplayList)(allocDisplayListMemory(1))
	}
	return (*C.fz_display_list)(unsafe.Pointer(x))
}

// allocStextCharMemory allocates memory for type C.fz_stext_char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStextCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStextCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStextCharValue = unsafe.Sizeof([1]C.fz_stext_char{})

// unpackSStextChar transforms a sliced Go data structure into plain C format.
func unpackSStextChar(x []StextChar) (unpacked *C.fz_stext_char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_stext_char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStextCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_stext_char)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_stext_char)(unsafe.Pointer(h.Data))
	return
}

// packSStextChar reads sliced Go data structure out from plain C format.
func packSStextChar(v []StextChar, ptr0 *C.fz_stext_char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStextCharValue]C.fz_stext_char)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewStextCharRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StextChar) Ref() *C.fz_stext_char {
	if x == nil {
		return nil
	}
	return x.reff4ae00e9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StextChar) Free() {
	if x != nil && x.allocsf4ae00e9 != nil {
		x.allocsf4ae00e9.(*cgoAllocMap).Free()
		x.reff4ae00e9 = nil
	}
}

// NewStextCharRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStextCharRef(ref unsafe.Pointer) *StextChar {
	if ref == nil {
		return nil
	}
	obj := new(StextChar)
	obj.reff4ae00e9 = (*C.fz_stext_char)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StextChar) PassRef() (*C.fz_stext_char, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff4ae00e9 != nil {
		return x.reff4ae00e9, nil
	}
	memf4ae00e9 := allocStextCharMemory(1)
	reff4ae00e9 := (*C.fz_stext_char)(memf4ae00e9)
	allocsf4ae00e9 := new(cgoAllocMap)
	allocsf4ae00e9.Add(memf4ae00e9)

	var cc_allocs *cgoAllocMap
	reff4ae00e9.c, cc_allocs = (C.int)(x.C), cgoAllocsUnknown
	allocsf4ae00e9.Borrow(cc_allocs)

	var crtl_allocs *cgoAllocMap
	reff4ae00e9.rtl, crtl_allocs = (C.int)(x.Rtl), cgoAllocsUnknown
	allocsf4ae00e9.Borrow(crtl_allocs)

	var corigin_allocs *cgoAllocMap
	reff4ae00e9.origin, corigin_allocs = x.Origin.PassValue()
	allocsf4ae00e9.Borrow(corigin_allocs)

	var cbbox_allocs *cgoAllocMap
	reff4ae00e9.bbox, cbbox_allocs = x.Bbox.PassValue()
	allocsf4ae00e9.Borrow(cbbox_allocs)

	var csize_allocs *cgoAllocMap
	reff4ae00e9.size, csize_allocs = (C.float)(x.Size), cgoAllocsUnknown
	allocsf4ae00e9.Borrow(csize_allocs)

	var cfont_allocs *cgoAllocMap
	reff4ae00e9.font, cfont_allocs = (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Font)).Data)), cgoAllocsUnknown
	allocsf4ae00e9.Borrow(cfont_allocs)

	var cnext_allocs *cgoAllocMap
	reff4ae00e9.next, cnext_allocs = unpackSStextChar(x.Next)
	allocsf4ae00e9.Borrow(cnext_allocs)

	x.reff4ae00e9 = reff4ae00e9
	x.allocsf4ae00e9 = allocsf4ae00e9
	return reff4ae00e9, allocsf4ae00e9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StextChar) PassValue() (C.fz_stext_char, *cgoAllocMap) {
	if x.reff4ae00e9 != nil {
		return *x.reff4ae00e9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StextChar) Deref() {
	if x.reff4ae00e9 == nil {
		return
	}
	x.C = (int32)(x.reff4ae00e9.c)
	x.Rtl = (int32)(x.reff4ae00e9.rtl)
	x.Origin = *NewPointRef(unsafe.Pointer(&x.reff4ae00e9.origin))
	x.Bbox = *NewRectRef(unsafe.Pointer(&x.reff4ae00e9.bbox))
	x.Size = (float32)(x.reff4ae00e9.size)
	hxf4b5187 := (*sliceHeader)(unsafe.Pointer(&x.Font))
	hxf4b5187.Data = uintptr(unsafe.Pointer(x.reff4ae00e9.font))
	hxf4b5187.Cap = 0x7fffffff
	// hxf4b5187.Len = ?

	packSStextChar(x.Next, x.reff4ae00e9.next)
}

// allocStextLineMemory allocates memory for type C.fz_stext_line in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStextLineMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStextLineValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStextLineValue = unsafe.Sizeof([1]C.fz_stext_line{})

// unpackSStextLine transforms a sliced Go data structure into plain C format.
func unpackSStextLine(x []StextLine) (unpacked *C.fz_stext_line, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_stext_line) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStextLineMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_stext_line)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_stext_line)(unsafe.Pointer(h.Data))
	return
}

// packSStextLine reads sliced Go data structure out from plain C format.
func packSStextLine(v []StextLine, ptr0 *C.fz_stext_line) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStextLineValue]C.fz_stext_line)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewStextLineRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StextLine) Ref() *C.fz_stext_line {
	if x == nil {
		return nil
	}
	return x.refa944e380
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StextLine) Free() {
	if x != nil && x.allocsa944e380 != nil {
		x.allocsa944e380.(*cgoAllocMap).Free()
		x.refa944e380 = nil
	}
}

// NewStextLineRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStextLineRef(ref unsafe.Pointer) *StextLine {
	if ref == nil {
		return nil
	}
	obj := new(StextLine)
	obj.refa944e380 = (*C.fz_stext_line)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StextLine) PassRef() (*C.fz_stext_line, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa944e380 != nil {
		return x.refa944e380, nil
	}
	mema944e380 := allocStextLineMemory(1)
	refa944e380 := (*C.fz_stext_line)(mema944e380)
	allocsa944e380 := new(cgoAllocMap)
	allocsa944e380.Add(mema944e380)

	var cwmode_allocs *cgoAllocMap
	refa944e380.wmode, cwmode_allocs = (C.int)(x.Wmode), cgoAllocsUnknown
	allocsa944e380.Borrow(cwmode_allocs)

	var cdir_allocs *cgoAllocMap
	refa944e380.dir, cdir_allocs = x.Dir.PassValue()
	allocsa944e380.Borrow(cdir_allocs)

	var cbbox_allocs *cgoAllocMap
	refa944e380.bbox, cbbox_allocs = x.Bbox.PassValue()
	allocsa944e380.Borrow(cbbox_allocs)

	var cfirst_char_allocs *cgoAllocMap
	refa944e380.first_char, cfirst_char_allocs = unpackSStextChar(x.FirstChar)
	allocsa944e380.Borrow(cfirst_char_allocs)

	var clast_char_allocs *cgoAllocMap
	refa944e380.last_char, clast_char_allocs = unpackSStextChar(x.LastChar)
	allocsa944e380.Borrow(clast_char_allocs)

	var cprev_allocs *cgoAllocMap
	refa944e380.prev, cprev_allocs = unpackSStextLine(x.Prev)
	allocsa944e380.Borrow(cprev_allocs)

	var cnext_allocs *cgoAllocMap
	refa944e380.next, cnext_allocs = unpackSStextLine(x.Next)
	allocsa944e380.Borrow(cnext_allocs)

	x.refa944e380 = refa944e380
	x.allocsa944e380 = allocsa944e380
	return refa944e380, allocsa944e380

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StextLine) PassValue() (C.fz_stext_line, *cgoAllocMap) {
	if x.refa944e380 != nil {
		return *x.refa944e380, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StextLine) Deref() {
	if x.refa944e380 == nil {
		return
	}
	x.Wmode = (int32)(x.refa944e380.wmode)
	x.Dir = *NewPointRef(unsafe.Pointer(&x.refa944e380.dir))
	x.Bbox = *NewRectRef(unsafe.Pointer(&x.refa944e380.bbox))
	packSStextChar(x.FirstChar, x.refa944e380.first_char)
	packSStextChar(x.LastChar, x.refa944e380.last_char)
	packSStextLine(x.Prev, x.refa944e380.prev)
	packSStextLine(x.Next, x.refa944e380.next)
}

// allocStextBlockMemory allocates memory for type C.fz_stext_block in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStextBlockMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStextBlockValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStextBlockValue = unsafe.Sizeof([1]C.fz_stext_block{})

// unpackSStextBlock transforms a sliced Go data structure into plain C format.
func unpackSStextBlock(x []StextBlock) (unpacked *C.fz_stext_block, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_stext_block) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStextBlockMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_stext_block)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_stext_block)(unsafe.Pointer(h.Data))
	return
}

// packSStextBlock reads sliced Go data structure out from plain C format.
func packSStextBlock(v []StextBlock, ptr0 *C.fz_stext_block) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStextBlockValue]C.fz_stext_block)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewStextBlockRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StextBlock) Ref() *C.fz_stext_block {
	if x == nil {
		return nil
	}
	return x.ref3a05137c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StextBlock) Free() {
	if x != nil && x.allocs3a05137c != nil {
		x.allocs3a05137c.(*cgoAllocMap).Free()
		x.ref3a05137c = nil
	}
}

// NewStextBlockRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStextBlockRef(ref unsafe.Pointer) *StextBlock {
	if ref == nil {
		return nil
	}
	obj := new(StextBlock)
	obj.ref3a05137c = (*C.fz_stext_block)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StextBlock) PassRef() (*C.fz_stext_block, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3a05137c != nil {
		return x.ref3a05137c, nil
	}
	mem3a05137c := allocStextBlockMemory(1)
	ref3a05137c := (*C.fz_stext_block)(mem3a05137c)
	allocs3a05137c := new(cgoAllocMap)
	allocs3a05137c.Add(mem3a05137c)

	var c_type_allocs *cgoAllocMap
	ref3a05137c._type, c_type_allocs = (C.int)(x.Type), cgoAllocsUnknown
	allocs3a05137c.Borrow(c_type_allocs)

	var cbbox_allocs *cgoAllocMap
	ref3a05137c.bbox, cbbox_allocs = x.Bbox.PassValue()
	allocs3a05137c.Borrow(cbbox_allocs)

	var cprev_allocs *cgoAllocMap
	ref3a05137c.prev, cprev_allocs = unpackSStextBlock(x.Prev)
	allocs3a05137c.Borrow(cprev_allocs)

	var cnext_allocs *cgoAllocMap
	ref3a05137c.next, cnext_allocs = unpackSStextBlock(x.Next)
	allocs3a05137c.Borrow(cnext_allocs)

	x.ref3a05137c = ref3a05137c
	x.allocs3a05137c = allocs3a05137c
	return ref3a05137c, allocs3a05137c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StextBlock) PassValue() (C.fz_stext_block, *cgoAllocMap) {
	if x.ref3a05137c != nil {
		return *x.ref3a05137c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StextBlock) Deref() {
	if x.ref3a05137c == nil {
		return
	}
	x.Type = (int32)(x.ref3a05137c._type)
	x.Bbox = *NewRectRef(unsafe.Pointer(&x.ref3a05137c.bbox))
	packSStextBlock(x.Prev, x.ref3a05137c.prev)
	packSStextBlock(x.Next, x.ref3a05137c.next)
}

// allocStextPageMemory allocates memory for type C.fz_stext_page in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStextPageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStextPageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStextPageValue = unsafe.Sizeof([1]C.fz_stext_page{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StextPage) Ref() *C.fz_stext_page {
	if x == nil {
		return nil
	}
	return x.ref6c5ae156
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StextPage) Free() {
	if x != nil && x.allocs6c5ae156 != nil {
		x.allocs6c5ae156.(*cgoAllocMap).Free()
		x.ref6c5ae156 = nil
	}
}

// NewStextPageRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStextPageRef(ref unsafe.Pointer) *StextPage {
	if ref == nil {
		return nil
	}
	obj := new(StextPage)
	obj.ref6c5ae156 = (*C.fz_stext_page)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StextPage) PassRef() (*C.fz_stext_page, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6c5ae156 != nil {
		return x.ref6c5ae156, nil
	}
	mem6c5ae156 := allocStextPageMemory(1)
	ref6c5ae156 := (*C.fz_stext_page)(mem6c5ae156)
	allocs6c5ae156 := new(cgoAllocMap)
	allocs6c5ae156.Add(mem6c5ae156)

	var cpool_allocs *cgoAllocMap
	ref6c5ae156.pool, cpool_allocs = (*C.fz_pool)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Pool)).Data)), cgoAllocsUnknown
	allocs6c5ae156.Borrow(cpool_allocs)

	var cmediabox_allocs *cgoAllocMap
	ref6c5ae156.mediabox, cmediabox_allocs = x.Mediabox.PassValue()
	allocs6c5ae156.Borrow(cmediabox_allocs)

	var cfirst_block_allocs *cgoAllocMap
	ref6c5ae156.first_block, cfirst_block_allocs = unpackSStextBlock(x.FirstBlock)
	allocs6c5ae156.Borrow(cfirst_block_allocs)

	var clast_block_allocs *cgoAllocMap
	ref6c5ae156.last_block, clast_block_allocs = unpackSStextBlock(x.LastBlock)
	allocs6c5ae156.Borrow(clast_block_allocs)

	x.ref6c5ae156 = ref6c5ae156
	x.allocs6c5ae156 = allocs6c5ae156
	return ref6c5ae156, allocs6c5ae156

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StextPage) PassValue() (C.fz_stext_page, *cgoAllocMap) {
	if x.ref6c5ae156 != nil {
		return *x.ref6c5ae156, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StextPage) Deref() {
	if x.ref6c5ae156 == nil {
		return
	}
	hxf177f79 := (*sliceHeader)(unsafe.Pointer(&x.Pool))
	hxf177f79.Data = uintptr(unsafe.Pointer(x.ref6c5ae156.pool))
	hxf177f79.Cap = 0x7fffffff
	// hxf177f79.Len = ?

	x.Mediabox = *NewRectRef(unsafe.Pointer(&x.ref6c5ae156.mediabox))
	packSStextBlock(x.FirstBlock, x.ref6c5ae156.first_block)
	packSStextBlock(x.LastBlock, x.ref6c5ae156.last_block)
}

// allocStextOptionsMemory allocates memory for type C.fz_stext_options in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStextOptionsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStextOptionsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStextOptionsValue = unsafe.Sizeof([1]C.fz_stext_options{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *StextOptions) Ref() *C.fz_stext_options {
	if x == nil {
		return nil
	}
	return x.ref1ed8747a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *StextOptions) Free() {
	if x != nil && x.allocs1ed8747a != nil {
		x.allocs1ed8747a.(*cgoAllocMap).Free()
		x.ref1ed8747a = nil
	}
}

// NewStextOptionsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStextOptionsRef(ref unsafe.Pointer) *StextOptions {
	if ref == nil {
		return nil
	}
	obj := new(StextOptions)
	obj.ref1ed8747a = (*C.fz_stext_options)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *StextOptions) PassRef() (*C.fz_stext_options, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1ed8747a != nil {
		return x.ref1ed8747a, nil
	}
	mem1ed8747a := allocStextOptionsMemory(1)
	ref1ed8747a := (*C.fz_stext_options)(mem1ed8747a)
	allocs1ed8747a := new(cgoAllocMap)
	allocs1ed8747a.Add(mem1ed8747a)

	var cflags_allocs *cgoAllocMap
	ref1ed8747a.flags, cflags_allocs = (C.int)(x.Flags), cgoAllocsUnknown
	allocs1ed8747a.Borrow(cflags_allocs)

	x.ref1ed8747a = ref1ed8747a
	x.allocs1ed8747a = allocs1ed8747a
	return ref1ed8747a, allocs1ed8747a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x StextOptions) PassValue() (C.fz_stext_options, *cgoAllocMap) {
	if x.ref1ed8747a != nil {
		return *x.ref1ed8747a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *StextOptions) Deref() {
	if x.ref1ed8747a == nil {
		return
	}
	x.Flags = (int32)(x.ref1ed8747a.flags)
}

// allocTransitionMemory allocates memory for type C.fz_transition in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTransitionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTransitionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTransitionValue = unsafe.Sizeof([1]C.fz_transition{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Transition) Ref() *C.fz_transition {
	if x == nil {
		return nil
	}
	return x.ref90c6cc5a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Transition) Free() {
	if x != nil && x.allocs90c6cc5a != nil {
		x.allocs90c6cc5a.(*cgoAllocMap).Free()
		x.ref90c6cc5a = nil
	}
}

// NewTransitionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTransitionRef(ref unsafe.Pointer) *Transition {
	if ref == nil {
		return nil
	}
	obj := new(Transition)
	obj.ref90c6cc5a = (*C.fz_transition)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Transition) PassRef() (*C.fz_transition, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref90c6cc5a != nil {
		return x.ref90c6cc5a, nil
	}
	mem90c6cc5a := allocTransitionMemory(1)
	ref90c6cc5a := (*C.fz_transition)(mem90c6cc5a)
	allocs90c6cc5a := new(cgoAllocMap)
	allocs90c6cc5a.Add(mem90c6cc5a)

	var c_type_allocs *cgoAllocMap
	ref90c6cc5a._type, c_type_allocs = (C.int)(x.Type), cgoAllocsUnknown
	allocs90c6cc5a.Borrow(c_type_allocs)

	var cduration_allocs *cgoAllocMap
	ref90c6cc5a.duration, cduration_allocs = (C.float)(x.Duration), cgoAllocsUnknown
	allocs90c6cc5a.Borrow(cduration_allocs)

	var cvertical_allocs *cgoAllocMap
	ref90c6cc5a.vertical, cvertical_allocs = (C.int)(x.Vertical), cgoAllocsUnknown
	allocs90c6cc5a.Borrow(cvertical_allocs)

	var coutwards_allocs *cgoAllocMap
	ref90c6cc5a.outwards, coutwards_allocs = (C.int)(x.Outwards), cgoAllocsUnknown
	allocs90c6cc5a.Borrow(coutwards_allocs)

	var cdirection_allocs *cgoAllocMap
	ref90c6cc5a.direction, cdirection_allocs = (C.int)(x.Direction), cgoAllocsUnknown
	allocs90c6cc5a.Borrow(cdirection_allocs)

	var cstate0_allocs *cgoAllocMap
	ref90c6cc5a.state0, cstate0_allocs = (C.int)(x.State0), cgoAllocsUnknown
	allocs90c6cc5a.Borrow(cstate0_allocs)

	var cstate1_allocs *cgoAllocMap
	ref90c6cc5a.state1, cstate1_allocs = (C.int)(x.State1), cgoAllocsUnknown
	allocs90c6cc5a.Borrow(cstate1_allocs)

	x.ref90c6cc5a = ref90c6cc5a
	x.allocs90c6cc5a = allocs90c6cc5a
	return ref90c6cc5a, allocs90c6cc5a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Transition) PassValue() (C.fz_transition, *cgoAllocMap) {
	if x.ref90c6cc5a != nil {
		return *x.ref90c6cc5a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Transition) Deref() {
	if x.ref90c6cc5a == nil {
		return
	}
	x.Type = (int32)(x.ref90c6cc5a._type)
	x.Duration = (float32)(x.ref90c6cc5a.duration)
	x.Vertical = (int32)(x.ref90c6cc5a.vertical)
	x.Outwards = (int32)(x.ref90c6cc5a.outwards)
	x.Direction = (int32)(x.ref90c6cc5a.direction)
	x.State0 = (int32)(x.ref90c6cc5a.state0)
	x.State1 = (int32)(x.ref90c6cc5a.state1)
}

// allocLinkMemory allocates memory for type C.fz_link in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLinkMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLinkValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfLinkValue = unsafe.Sizeof([1]C.fz_link{})

// unpackSLink transforms a sliced Go data structure into plain C format.
func unpackSLink(x []Link) (unpacked *C.fz_link, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_link) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocLinkMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_link)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_link)(unsafe.Pointer(h.Data))
	return
}

// packSLink reads sliced Go data structure out from plain C format.
func packSLink(v []Link, ptr0 *C.fz_link) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfLinkValue]C.fz_link)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewLinkRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Link) Ref() *C.fz_link {
	if x == nil {
		return nil
	}
	return x.ref721896f1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Link) Free() {
	if x != nil && x.allocs721896f1 != nil {
		x.allocs721896f1.(*cgoAllocMap).Free()
		x.ref721896f1 = nil
	}
}

// NewLinkRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewLinkRef(ref unsafe.Pointer) *Link {
	if ref == nil {
		return nil
	}
	obj := new(Link)
	obj.ref721896f1 = (*C.fz_link)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Link) PassRef() (*C.fz_link, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref721896f1 != nil {
		return x.ref721896f1, nil
	}
	mem721896f1 := allocLinkMemory(1)
	ref721896f1 := (*C.fz_link)(mem721896f1)
	allocs721896f1 := new(cgoAllocMap)
	allocs721896f1.Add(mem721896f1)

	var crefs_allocs *cgoAllocMap
	ref721896f1.refs, crefs_allocs = (C.int)(x.Refs), cgoAllocsUnknown
	allocs721896f1.Borrow(crefs_allocs)

	var cnext_allocs *cgoAllocMap
	ref721896f1.next, cnext_allocs = unpackSLink(x.Next)
	allocs721896f1.Borrow(cnext_allocs)

	var crect_allocs *cgoAllocMap
	ref721896f1.rect, crect_allocs = x.Rect.PassValue()
	allocs721896f1.Borrow(crect_allocs)

	var cdoc_allocs *cgoAllocMap
	ref721896f1.doc, cdoc_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Doc)), cgoAllocsUnknown
	allocs721896f1.Borrow(cdoc_allocs)

	var curi_allocs *cgoAllocMap
	ref721896f1.uri, curi_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Uri)).Data)), cgoAllocsUnknown
	allocs721896f1.Borrow(curi_allocs)

	x.ref721896f1 = ref721896f1
	x.allocs721896f1 = allocs721896f1
	return ref721896f1, allocs721896f1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Link) PassValue() (C.fz_link, *cgoAllocMap) {
	if x.ref721896f1 != nil {
		return *x.ref721896f1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Link) Deref() {
	if x.ref721896f1 == nil {
		return
	}
	x.Refs = (int32)(x.ref721896f1.refs)
	packSLink(x.Next, x.ref721896f1.next)
	x.Rect = *NewRectRef(unsafe.Pointer(&x.ref721896f1.rect))
	x.Doc = (unsafe.Pointer)(unsafe.Pointer(x.ref721896f1.doc))
	hxfaa359c := (*sliceHeader)(unsafe.Pointer(&x.Uri))
	hxfaa359c.Data = uintptr(unsafe.Pointer(x.ref721896f1.uri))
	hxfaa359c.Cap = 0x7fffffff
	// hxfaa359c.Len = ?

}

// allocOutlineMemory allocates memory for type C.fz_outline in C.
// The caller is responsible for freeing the this memory via C.free.
func allocOutlineMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfOutlineValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfOutlineValue = unsafe.Sizeof([1]C.fz_outline{})

// unpackSOutline transforms a sliced Go data structure into plain C format.
func unpackSOutline(x []Outline) (unpacked *C.fz_outline, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_outline) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocOutlineMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_outline)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_outline)(unsafe.Pointer(h.Data))
	return
}

// packSOutline reads sliced Go data structure out from plain C format.
func packSOutline(v []Outline, ptr0 *C.fz_outline) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfOutlineValue]C.fz_outline)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewOutlineRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Outline) Ref() *C.fz_outline {
	if x == nil {
		return nil
	}
	return x.refceb39fb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Outline) Free() {
	if x != nil && x.allocsceb39fb != nil {
		x.allocsceb39fb.(*cgoAllocMap).Free()
		x.refceb39fb = nil
	}
}

// NewOutlineRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewOutlineRef(ref unsafe.Pointer) *Outline {
	if ref == nil {
		return nil
	}
	obj := new(Outline)
	obj.refceb39fb = (*C.fz_outline)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Outline) PassRef() (*C.fz_outline, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refceb39fb != nil {
		return x.refceb39fb, nil
	}
	memceb39fb := allocOutlineMemory(1)
	refceb39fb := (*C.fz_outline)(memceb39fb)
	allocsceb39fb := new(cgoAllocMap)
	allocsceb39fb.Add(memceb39fb)

	var crefs_allocs *cgoAllocMap
	refceb39fb.refs, crefs_allocs = (C.int)(x.Refs), cgoAllocsUnknown
	allocsceb39fb.Borrow(crefs_allocs)

	var ctitle_allocs *cgoAllocMap
	refceb39fb.title, ctitle_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Title)).Data)), cgoAllocsUnknown
	allocsceb39fb.Borrow(ctitle_allocs)

	var curi_allocs *cgoAllocMap
	refceb39fb.uri, curi_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Uri)).Data)), cgoAllocsUnknown
	allocsceb39fb.Borrow(curi_allocs)

	var cpage_allocs *cgoAllocMap
	refceb39fb.page, cpage_allocs = (C.int)(x.Page), cgoAllocsUnknown
	allocsceb39fb.Borrow(cpage_allocs)

	var cx_allocs *cgoAllocMap
	refceb39fb.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocsceb39fb.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refceb39fb.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocsceb39fb.Borrow(cy_allocs)

	var cnext_allocs *cgoAllocMap
	refceb39fb.next, cnext_allocs = unpackSOutline(x.Next)
	allocsceb39fb.Borrow(cnext_allocs)

	var cdown_allocs *cgoAllocMap
	refceb39fb.down, cdown_allocs = unpackSOutline(x.Down)
	allocsceb39fb.Borrow(cdown_allocs)

	var cis_open_allocs *cgoAllocMap
	refceb39fb.is_open, cis_open_allocs = (C.int)(x.IsOpen), cgoAllocsUnknown
	allocsceb39fb.Borrow(cis_open_allocs)

	x.refceb39fb = refceb39fb
	x.allocsceb39fb = allocsceb39fb
	return refceb39fb, allocsceb39fb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Outline) PassValue() (C.fz_outline, *cgoAllocMap) {
	if x.refceb39fb != nil {
		return *x.refceb39fb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Outline) Deref() {
	if x.refceb39fb == nil {
		return
	}
	x.Refs = (int32)(x.refceb39fb.refs)
	hxfa897de := (*sliceHeader)(unsafe.Pointer(&x.Title))
	hxfa897de.Data = uintptr(unsafe.Pointer(x.refceb39fb.title))
	hxfa897de.Cap = 0x7fffffff
	// hxfa897de.Len = ?

	hxfe33f90 := (*sliceHeader)(unsafe.Pointer(&x.Uri))
	hxfe33f90.Data = uintptr(unsafe.Pointer(x.refceb39fb.uri))
	hxfe33f90.Cap = 0x7fffffff
	// hxfe33f90.Len = ?

	x.Page = (int32)(x.refceb39fb.page)
	x.X = (float32)(x.refceb39fb.x)
	x.Y = (float32)(x.refceb39fb.y)
	packSOutline(x.Next, x.refceb39fb.next)
	packSOutline(x.Down, x.refceb39fb.down)
	x.IsOpen = (int32)(x.refceb39fb.is_open)
}

// allocDocumentMemory allocates memory for type C.fz_document in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDocumentMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDocumentValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDocumentValue = unsafe.Sizeof([1]C.fz_document{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Document) Ref() *C.fz_document {
	if x == nil {
		return nil
	}
	return x.ref222d237e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Document) Free() {
	if x != nil && x.allocs222d237e != nil {
		x.allocs222d237e.(*cgoAllocMap).Free()
		x.ref222d237e = nil
	}
}

// NewDocumentRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDocumentRef(ref unsafe.Pointer) *Document {
	if ref == nil {
		return nil
	}
	obj := new(Document)
	obj.ref222d237e = (*C.fz_document)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Document) PassRef() (*C.fz_document, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref222d237e != nil {
		return x.ref222d237e, nil
	}
	mem222d237e := allocDocumentMemory(1)
	ref222d237e := (*C.fz_document)(mem222d237e)
	allocs222d237e := new(cgoAllocMap)
	allocs222d237e.Add(mem222d237e)

	var crefs_allocs *cgoAllocMap
	ref222d237e.refs, crefs_allocs = (C.int)(x.Refs), cgoAllocsUnknown
	allocs222d237e.Borrow(crefs_allocs)

	var cdrop_document_allocs *cgoAllocMap
	ref222d237e.drop_document, cdrop_document_allocs = x.DropDocument.PassRef()
	allocs222d237e.Borrow(cdrop_document_allocs)

	var cneeds_password_allocs *cgoAllocMap
	ref222d237e.needs_password, cneeds_password_allocs = x.NeedsPassword.PassRef()
	allocs222d237e.Borrow(cneeds_password_allocs)

	var cauthenticate_password_allocs *cgoAllocMap
	ref222d237e.authenticate_password, cauthenticate_password_allocs = x.AuthenticatePassword.PassRef()
	allocs222d237e.Borrow(cauthenticate_password_allocs)

	var chas_permission_allocs *cgoAllocMap
	ref222d237e.has_permission, chas_permission_allocs = x.HasPermission.PassRef()
	allocs222d237e.Borrow(chas_permission_allocs)

	var cload_outline_allocs *cgoAllocMap
	ref222d237e.load_outline, cload_outline_allocs = x.LoadOutline.PassRef()
	allocs222d237e.Borrow(cload_outline_allocs)

	var clayout_allocs *cgoAllocMap
	ref222d237e.layout, clayout_allocs = x.Layout.PassRef()
	allocs222d237e.Borrow(clayout_allocs)

	var cmake_bookmark_allocs *cgoAllocMap
	ref222d237e.make_bookmark, cmake_bookmark_allocs = x.MakeBookmark.PassRef()
	allocs222d237e.Borrow(cmake_bookmark_allocs)

	var clookup_bookmark_allocs *cgoAllocMap
	ref222d237e.lookup_bookmark, clookup_bookmark_allocs = x.LookupBookmark.PassRef()
	allocs222d237e.Borrow(clookup_bookmark_allocs)

	var cresolve_link_allocs *cgoAllocMap
	ref222d237e.resolve_link, cresolve_link_allocs = x.ResolveLink.PassRef()
	allocs222d237e.Borrow(cresolve_link_allocs)

	var ccount_pages_allocs *cgoAllocMap
	ref222d237e.count_pages, ccount_pages_allocs = x.CountPages.PassRef()
	allocs222d237e.Borrow(ccount_pages_allocs)

	var cload_page_allocs *cgoAllocMap
	ref222d237e.load_page, cload_page_allocs = x.LoadPage.PassRef()
	allocs222d237e.Borrow(cload_page_allocs)

	var clookup_metadata_allocs *cgoAllocMap
	ref222d237e.lookup_metadata, clookup_metadata_allocs = x.LookupMetadata.PassRef()
	allocs222d237e.Borrow(clookup_metadata_allocs)

	var cget_output_intent_allocs *cgoAllocMap
	ref222d237e.get_output_intent, cget_output_intent_allocs = x.GetOutputIntent.PassRef()
	allocs222d237e.Borrow(cget_output_intent_allocs)

	var cdid_layout_allocs *cgoAllocMap
	ref222d237e.did_layout, cdid_layout_allocs = (C.int)(x.DidLayout), cgoAllocsUnknown
	allocs222d237e.Borrow(cdid_layout_allocs)

	var cis_reflowable_allocs *cgoAllocMap
	ref222d237e.is_reflowable, cis_reflowable_allocs = (C.int)(x.IsReflowable), cgoAllocsUnknown
	allocs222d237e.Borrow(cis_reflowable_allocs)

	x.ref222d237e = ref222d237e
	x.allocs222d237e = allocs222d237e
	return ref222d237e, allocs222d237e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Document) PassValue() (C.fz_document, *cgoAllocMap) {
	if x.ref222d237e != nil {
		return *x.ref222d237e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Document) Deref() {
	if x.ref222d237e == nil {
		return
	}
	x.Refs = (int32)(x.ref222d237e.refs)
	x.DropDocument = NewDocumentDropFnRef(unsafe.Pointer(x.ref222d237e.drop_document))
	x.NeedsPassword = NewDocumentNeedsPasswordFnRef(unsafe.Pointer(x.ref222d237e.needs_password))
	x.AuthenticatePassword = NewDocumentAuthenticatePasswordFnRef(unsafe.Pointer(x.ref222d237e.authenticate_password))
	x.HasPermission = NewDocumentHasPermissionFnRef(unsafe.Pointer(x.ref222d237e.has_permission))
	x.LoadOutline = NewDocumentLoadOutlineFnRef(unsafe.Pointer(x.ref222d237e.load_outline))
	x.Layout = NewDocumentLayoutFnRef(unsafe.Pointer(x.ref222d237e.layout))
	x.MakeBookmark = NewDocumentMakeBookmarkFnRef(unsafe.Pointer(x.ref222d237e.make_bookmark))
	x.LookupBookmark = NewDocumentLookupBookmarkFnRef(unsafe.Pointer(x.ref222d237e.lookup_bookmark))
	x.ResolveLink = NewDocumentResolveLinkFnRef(unsafe.Pointer(x.ref222d237e.resolve_link))
	x.CountPages = NewDocumentCountPagesFnRef(unsafe.Pointer(x.ref222d237e.count_pages))
	x.LoadPage = NewDocumentLoadPageFnRef(unsafe.Pointer(x.ref222d237e.load_page))
	x.LookupMetadata = NewDocumentLookupMetadataFnRef(unsafe.Pointer(x.ref222d237e.lookup_metadata))
	x.GetOutputIntent = NewDocumentOutputIntentFnRef(unsafe.Pointer(x.ref222d237e.get_output_intent))
	x.DidLayout = (int32)(x.ref222d237e.did_layout)
	x.IsReflowable = (int32)(x.ref222d237e.is_reflowable)
}

// allocDocumentHandlerMemory allocates memory for type C.fz_document_handler in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDocumentHandlerMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDocumentHandlerValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDocumentHandlerValue = unsafe.Sizeof([1]C.fz_document_handler{})

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

// unpackSString transforms a sliced Go data structure into plain C format.
func unpackSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = unpackPCharString(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(unsafe.Pointer(h.Data))
	return
}

// packSString reads sliced Go data structure out from plain C format.
func packSString(v []string, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = packPCharString(ptr1)
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DocumentHandler) Ref() *C.fz_document_handler {
	if x == nil {
		return nil
	}
	return x.refa0633e9f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DocumentHandler) Free() {
	if x != nil && x.allocsa0633e9f != nil {
		x.allocsa0633e9f.(*cgoAllocMap).Free()
		x.refa0633e9f = nil
	}
}

// NewDocumentHandlerRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDocumentHandlerRef(ref unsafe.Pointer) *DocumentHandler {
	if ref == nil {
		return nil
	}
	obj := new(DocumentHandler)
	obj.refa0633e9f = (*C.fz_document_handler)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DocumentHandler) PassRef() (*C.fz_document_handler, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa0633e9f != nil {
		return x.refa0633e9f, nil
	}
	mema0633e9f := allocDocumentHandlerMemory(1)
	refa0633e9f := (*C.fz_document_handler)(mema0633e9f)
	allocsa0633e9f := new(cgoAllocMap)
	allocsa0633e9f.Add(mema0633e9f)

	var crecognize_allocs *cgoAllocMap
	refa0633e9f.recognize, crecognize_allocs = x.Recognize.PassRef()
	allocsa0633e9f.Borrow(crecognize_allocs)

	var copen_allocs *cgoAllocMap
	refa0633e9f.open, copen_allocs = x.Open.PassRef()
	allocsa0633e9f.Borrow(copen_allocs)

	var copen_with_stream_allocs *cgoAllocMap
	refa0633e9f.open_with_stream, copen_with_stream_allocs = x.OpenWithStream.PassRef()
	allocsa0633e9f.Borrow(copen_with_stream_allocs)

	var cextensions_allocs *cgoAllocMap
	refa0633e9f.extensions, cextensions_allocs = unpackSString(x.Extensions)
	allocsa0633e9f.Borrow(cextensions_allocs)

	var cmimetypes_allocs *cgoAllocMap
	refa0633e9f.mimetypes, cmimetypes_allocs = unpackSString(x.Mimetypes)
	allocsa0633e9f.Borrow(cmimetypes_allocs)

	x.refa0633e9f = refa0633e9f
	x.allocsa0633e9f = allocsa0633e9f
	return refa0633e9f, allocsa0633e9f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DocumentHandler) PassValue() (C.fz_document_handler, *cgoAllocMap) {
	if x.refa0633e9f != nil {
		return *x.refa0633e9f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DocumentHandler) Deref() {
	if x.refa0633e9f == nil {
		return
	}
	x.Recognize = NewDocumentRecognizeFnRef(unsafe.Pointer(x.refa0633e9f.recognize))
	x.Open = NewDocumentOpenFnRef(unsafe.Pointer(x.refa0633e9f.open))
	x.OpenWithStream = NewDocumentOpenWithStreamFnRef(unsafe.Pointer(x.refa0633e9f.open_with_stream))
	packSString(x.Extensions, x.refa0633e9f.extensions)
	packSString(x.Mimetypes, x.refa0633e9f.mimetypes)
}

// allocPageMemory allocates memory for type C.fz_page in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPageValue = unsafe.Sizeof([1]C.fz_page{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Page) Ref() *C.fz_page {
	if x == nil {
		return nil
	}
	return x.ref50beb920
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Page) Free() {
	if x != nil && x.allocs50beb920 != nil {
		x.allocs50beb920.(*cgoAllocMap).Free()
		x.ref50beb920 = nil
	}
}

// NewPageRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPageRef(ref unsafe.Pointer) *Page {
	if ref == nil {
		return nil
	}
	obj := new(Page)
	obj.ref50beb920 = (*C.fz_page)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Page) PassRef() (*C.fz_page, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref50beb920 != nil {
		return x.ref50beb920, nil
	}
	mem50beb920 := allocPageMemory(1)
	ref50beb920 := (*C.fz_page)(mem50beb920)
	allocs50beb920 := new(cgoAllocMap)
	allocs50beb920.Add(mem50beb920)

	var crefs_allocs *cgoAllocMap
	ref50beb920.refs, crefs_allocs = (C.int)(x.Refs), cgoAllocsUnknown
	allocs50beb920.Borrow(crefs_allocs)

	var cdrop_page_allocs *cgoAllocMap
	ref50beb920.drop_page, cdrop_page_allocs = x.DropPage.PassRef()
	allocs50beb920.Borrow(cdrop_page_allocs)

	var cbound_page_allocs *cgoAllocMap
	ref50beb920.bound_page, cbound_page_allocs = x.BoundPage.PassRef()
	allocs50beb920.Borrow(cbound_page_allocs)

	var crun_page_contents_allocs *cgoAllocMap
	ref50beb920.run_page_contents, crun_page_contents_allocs = x.RunPageContents.PassRef()
	allocs50beb920.Borrow(crun_page_contents_allocs)

	var cload_links_allocs *cgoAllocMap
	ref50beb920.load_links, cload_links_allocs = x.LoadLinks.PassRef()
	allocs50beb920.Borrow(cload_links_allocs)

	var cfirst_annot_allocs *cgoAllocMap
	ref50beb920.first_annot, cfirst_annot_allocs = x.FirstAnnot.PassRef()
	allocs50beb920.Borrow(cfirst_annot_allocs)

	var cpage_presentation_allocs *cgoAllocMap
	ref50beb920.page_presentation, cpage_presentation_allocs = x.PagePresentation.PassRef()
	allocs50beb920.Borrow(cpage_presentation_allocs)

	var ccontrol_separation_allocs *cgoAllocMap
	ref50beb920.control_separation, ccontrol_separation_allocs = x.ControlSeparation.PassRef()
	allocs50beb920.Borrow(ccontrol_separation_allocs)

	var cseparation_disabled_allocs *cgoAllocMap
	ref50beb920.separation_disabled, cseparation_disabled_allocs = x.SeparationDisabled.PassRef()
	allocs50beb920.Borrow(cseparation_disabled_allocs)

	var cseparations_allocs *cgoAllocMap
	ref50beb920.separations, cseparations_allocs = x.Separations.PassRef()
	allocs50beb920.Borrow(cseparations_allocs)

	x.ref50beb920 = ref50beb920
	x.allocs50beb920 = allocs50beb920
	return ref50beb920, allocs50beb920

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Page) PassValue() (C.fz_page, *cgoAllocMap) {
	if x.ref50beb920 != nil {
		return *x.ref50beb920, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Page) Deref() {
	if x.ref50beb920 == nil {
		return
	}
	x.Refs = (int32)(x.ref50beb920.refs)
	x.DropPage = NewPageDropPageFnRef(unsafe.Pointer(x.ref50beb920.drop_page))
	x.BoundPage = NewPageBoundPageFnRef(unsafe.Pointer(x.ref50beb920.bound_page))
	x.RunPageContents = NewPageRunPageContentsFnRef(unsafe.Pointer(x.ref50beb920.run_page_contents))
	x.LoadLinks = NewPageLoadLinksFnRef(unsafe.Pointer(x.ref50beb920.load_links))
	x.FirstAnnot = NewPageFirstAnnotFnRef(unsafe.Pointer(x.ref50beb920.first_annot))
	x.PagePresentation = NewPagePagePresentationFnRef(unsafe.Pointer(x.ref50beb920.page_presentation))
	x.ControlSeparation = NewPageControlSeparationFnRef(unsafe.Pointer(x.ref50beb920.control_separation))
	x.SeparationDisabled = NewPageSeparationDisabledFnRef(unsafe.Pointer(x.ref50beb920.separation_disabled))
	x.Separations = NewPageSeparationsFnRef(unsafe.Pointer(x.ref50beb920.separations))
}

// allocAnnotMemory allocates memory for type C.fz_annot in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAnnotMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAnnotValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAnnotValue = unsafe.Sizeof([1]C.fz_annot{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Annot) Ref() *C.fz_annot {
	if x == nil {
		return nil
	}
	return x.ref4e89b9b8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Annot) Free() {
	if x != nil && x.allocs4e89b9b8 != nil {
		x.allocs4e89b9b8.(*cgoAllocMap).Free()
		x.ref4e89b9b8 = nil
	}
}

// NewAnnotRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAnnotRef(ref unsafe.Pointer) *Annot {
	if ref == nil {
		return nil
	}
	obj := new(Annot)
	obj.ref4e89b9b8 = (*C.fz_annot)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Annot) PassRef() (*C.fz_annot, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4e89b9b8 != nil {
		return x.ref4e89b9b8, nil
	}
	mem4e89b9b8 := allocAnnotMemory(1)
	ref4e89b9b8 := (*C.fz_annot)(mem4e89b9b8)
	allocs4e89b9b8 := new(cgoAllocMap)
	allocs4e89b9b8.Add(mem4e89b9b8)

	var crefs_allocs *cgoAllocMap
	ref4e89b9b8.refs, crefs_allocs = (C.int)(x.Refs), cgoAllocsUnknown
	allocs4e89b9b8.Borrow(crefs_allocs)

	var cdrop_annot_allocs *cgoAllocMap
	ref4e89b9b8.drop_annot, cdrop_annot_allocs = x.DropAnnot.PassRef()
	allocs4e89b9b8.Borrow(cdrop_annot_allocs)

	var cbound_annot_allocs *cgoAllocMap
	ref4e89b9b8.bound_annot, cbound_annot_allocs = x.BoundAnnot.PassRef()
	allocs4e89b9b8.Borrow(cbound_annot_allocs)

	var crun_annot_allocs *cgoAllocMap
	ref4e89b9b8.run_annot, crun_annot_allocs = x.RunAnnot.PassRef()
	allocs4e89b9b8.Borrow(crun_annot_allocs)

	var cnext_annot_allocs *cgoAllocMap
	ref4e89b9b8.next_annot, cnext_annot_allocs = x.NextAnnot.PassRef()
	allocs4e89b9b8.Borrow(cnext_annot_allocs)

	x.ref4e89b9b8 = ref4e89b9b8
	x.allocs4e89b9b8 = allocs4e89b9b8
	return ref4e89b9b8, allocs4e89b9b8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Annot) PassValue() (C.fz_annot, *cgoAllocMap) {
	if x.ref4e89b9b8 != nil {
		return *x.ref4e89b9b8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Annot) Deref() {
	if x.ref4e89b9b8 == nil {
		return
	}
	x.Refs = (int32)(x.ref4e89b9b8.refs)
	x.DropAnnot = NewAnnotDropFnRef(unsafe.Pointer(x.ref4e89b9b8.drop_annot))
	x.BoundAnnot = NewAnnotBoundFnRef(unsafe.Pointer(x.ref4e89b9b8.bound_annot))
	x.RunAnnot = NewAnnotRunFnRef(unsafe.Pointer(x.ref4e89b9b8.run_annot))
	x.NextAnnot = NewAnnotNextFnRef(unsafe.Pointer(x.ref4e89b9b8.next_annot))
}

// packSDocument reads sliced Go data structure out from plain C format.
func packSDocument(v []Document, ptr0 *C.fz_document) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDocumentValue]C.fz_document)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDocumentRef(unsafe.Pointer(&ptr1))
	}
}

func (x DocumentDropFn) PassRef() (ref *C.fz_document_drop_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if documentDropFn199B99E3Func == nil {
		documentDropFn199B99E3Func = x
	}
	return (*C.fz_document_drop_fn)(C.fz_document_drop_fn_199b99e3), nil
}

func NewDocumentDropFnRef(ref unsafe.Pointer) *DocumentDropFn {
	return (*DocumentDropFn)(ref)
}

//export documentDropFn199B99E3
func documentDropFn199B99E3(cctx *C.fz_context, cdoc *C.fz_document) {
	if documentDropFn199B99E3Func != nil {
		var ctx199b99e3 []Context
		packSContext(ctx199b99e3, cctx)
		var doc199b99e3 []Document
		packSDocument(doc199b99e3, cdoc)
		documentDropFn199B99E3Func(ctx199b99e3, doc199b99e3)
		return
	}
	panic("callback func has not been set (race?)")
}

var documentDropFn199B99E3Func DocumentDropFn

func (x DocumentNeedsPasswordFn) PassRef() (ref *C.fz_document_needs_password_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if documentNeedsPasswordFn7840F251Func == nil {
		documentNeedsPasswordFn7840F251Func = x
	}
	return (*C.fz_document_needs_password_fn)(C.fz_document_needs_password_fn_7840f251), nil
}

func NewDocumentNeedsPasswordFnRef(ref unsafe.Pointer) *DocumentNeedsPasswordFn {
	return (*DocumentNeedsPasswordFn)(ref)
}

//export documentNeedsPasswordFn7840F251
func documentNeedsPasswordFn7840F251(cctx *C.fz_context, cdoc *C.fz_document) C.int {
	if documentNeedsPasswordFn7840F251Func != nil {
		var ctx7840f251 []Context
		packSContext(ctx7840f251, cctx)
		var doc7840f251 []Document
		packSDocument(doc7840f251, cdoc)
		ret7840f251 := documentNeedsPasswordFn7840F251Func(ctx7840f251, doc7840f251)
		ret, _ := (C.int)(ret7840f251), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var documentNeedsPasswordFn7840F251Func DocumentNeedsPasswordFn

func (x DocumentAuthenticatePasswordFn) PassRef() (ref *C.fz_document_authenticate_password_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if documentAuthenticatePasswordFnCCF5E3DFunc == nil {
		documentAuthenticatePasswordFnCCF5E3DFunc = x
	}
	return (*C.fz_document_authenticate_password_fn)(C.fz_document_authenticate_password_fn_ccf5e3d), nil
}

func NewDocumentAuthenticatePasswordFnRef(ref unsafe.Pointer) *DocumentAuthenticatePasswordFn {
	return (*DocumentAuthenticatePasswordFn)(ref)
}

//export documentAuthenticatePasswordFnCCF5E3D
func documentAuthenticatePasswordFnCCF5E3D(cctx *C.fz_context, cdoc *C.fz_document, cpassword *C.char) C.int {
	if documentAuthenticatePasswordFnCCF5E3DFunc != nil {
		var ctxccf5e3d []Context
		packSContext(ctxccf5e3d, cctx)
		var docccf5e3d []Document
		packSDocument(docccf5e3d, cdoc)
		passwordccf5e3d := packPCharString(cpassword)
		retccf5e3d := documentAuthenticatePasswordFnCCF5E3DFunc(ctxccf5e3d, docccf5e3d, passwordccf5e3d)
		ret, _ := (C.int)(retccf5e3d), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var documentAuthenticatePasswordFnCCF5E3DFunc DocumentAuthenticatePasswordFn

func (x DocumentHasPermissionFn) PassRef() (ref *C.fz_document_has_permission_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if documentHasPermissionFn64826A68Func == nil {
		documentHasPermissionFn64826A68Func = x
	}
	return (*C.fz_document_has_permission_fn)(C.fz_document_has_permission_fn_64826a68), nil
}

func NewDocumentHasPermissionFnRef(ref unsafe.Pointer) *DocumentHasPermissionFn {
	return (*DocumentHasPermissionFn)(ref)
}

//export documentHasPermissionFn64826A68
func documentHasPermissionFn64826A68(cctx *C.fz_context, cdoc *C.fz_document, cpermission C.fz_permission) C.int {
	if documentHasPermissionFn64826A68Func != nil {
		var ctx64826a68 []Context
		packSContext(ctx64826a68, cctx)
		var doc64826a68 []Document
		packSDocument(doc64826a68, cdoc)
		permission64826a68 := (Permission)(cpermission)
		ret64826a68 := documentHasPermissionFn64826A68Func(ctx64826a68, doc64826a68, permission64826a68)
		ret, _ := (C.int)(ret64826a68), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var documentHasPermissionFn64826A68Func DocumentHasPermissionFn

// unpackArgSOutline transforms a sliced Go data structure into plain C format.
func unpackArgSOutline(x []Outline) (unpacked *C.fz_outline, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_outline) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocOutlineMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_outline)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_outline)(unsafe.Pointer(h.Data))
	return
}

func (x DocumentLoadOutlineFn) PassRef() (ref *C.fz_document_load_outline_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if documentLoadOutlineFnAE85B015Func == nil {
		documentLoadOutlineFnAE85B015Func = x
	}
	return (*C.fz_document_load_outline_fn)(C.fz_document_load_outline_fn_ae85b015), nil
}

func NewDocumentLoadOutlineFnRef(ref unsafe.Pointer) *DocumentLoadOutlineFn {
	return (*DocumentLoadOutlineFn)(ref)
}

//export documentLoadOutlineFnAE85B015
func documentLoadOutlineFnAE85B015(cctx *C.fz_context, cdoc *C.fz_document) *C.fz_outline {
	if documentLoadOutlineFnAE85B015Func != nil {
		var ctxae85b015 []Context
		packSContext(ctxae85b015, cctx)
		var docae85b015 []Document
		packSDocument(docae85b015, cdoc)
		retae85b015 := documentLoadOutlineFnAE85B015Func(ctxae85b015, docae85b015)
		ret, _ := unpackArgSOutline(retae85b015)
		return ret
	}
	panic("callback func has not been set (race?)")
}

var documentLoadOutlineFnAE85B015Func DocumentLoadOutlineFn

func (x DocumentLayoutFn) PassRef() (ref *C.fz_document_layout_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if documentLayoutFnCF5EAAA9Func == nil {
		documentLayoutFnCF5EAAA9Func = x
	}
	return (*C.fz_document_layout_fn)(C.fz_document_layout_fn_cf5eaaa9), nil
}

func NewDocumentLayoutFnRef(ref unsafe.Pointer) *DocumentLayoutFn {
	return (*DocumentLayoutFn)(ref)
}

//export documentLayoutFnCF5EAAA9
func documentLayoutFnCF5EAAA9(cctx *C.fz_context, cdoc *C.fz_document, cw C.float, ch C.float, cem C.float) {
	if documentLayoutFnCF5EAAA9Func != nil {
		var ctxcf5eaaa9 []Context
		packSContext(ctxcf5eaaa9, cctx)
		var doccf5eaaa9 []Document
		packSDocument(doccf5eaaa9, cdoc)
		wcf5eaaa9 := (float32)(cw)
		hcf5eaaa9 := (float32)(ch)
		emcf5eaaa9 := (float32)(cem)
		documentLayoutFnCF5EAAA9Func(ctxcf5eaaa9, doccf5eaaa9, wcf5eaaa9, hcf5eaaa9, emcf5eaaa9)
		return
	}
	panic("callback func has not been set (race?)")
}

var documentLayoutFnCF5EAAA9Func DocumentLayoutFn

func (x DocumentResolveLinkFn) PassRef() (ref *C.fz_document_resolve_link_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if documentResolveLinkFnF25A9656Func == nil {
		documentResolveLinkFnF25A9656Func = x
	}
	return (*C.fz_document_resolve_link_fn)(C.fz_document_resolve_link_fn_f25a9656), nil
}

func NewDocumentResolveLinkFnRef(ref unsafe.Pointer) *DocumentResolveLinkFn {
	return (*DocumentResolveLinkFn)(ref)
}

//export documentResolveLinkFnF25A9656
func documentResolveLinkFnF25A9656(cctx *C.fz_context, cdoc *C.fz_document, curi *C.char, cxp *C.float, cyp *C.float) C.int {
	if documentResolveLinkFnF25A9656Func != nil {
		var ctxf25a9656 []Context
		packSContext(ctxf25a9656, cctx)
		var docf25a9656 []Document
		packSDocument(docf25a9656, cdoc)
		urif25a9656 := packPCharString(curi)
		var xpf25a9656 []float32
		hxf08bba9 := (*sliceHeader)(unsafe.Pointer(&xpf25a9656))
		hxf08bba9.Data = uintptr(unsafe.Pointer(cxp))
		hxf08bba9.Cap = 0x7fffffff
		// hxf08bba9.Len = ?

		var ypf25a9656 []float32
		hxfd3aa9c := (*sliceHeader)(unsafe.Pointer(&ypf25a9656))
		hxfd3aa9c.Data = uintptr(unsafe.Pointer(cyp))
		hxfd3aa9c.Cap = 0x7fffffff
		// hxfd3aa9c.Len = ?

		retf25a9656 := documentResolveLinkFnF25A9656Func(ctxf25a9656, docf25a9656, urif25a9656, xpf25a9656, ypf25a9656)
		ret, _ := (C.int)(retf25a9656), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var documentResolveLinkFnF25A9656Func DocumentResolveLinkFn

func (x DocumentCountPagesFn) PassRef() (ref *C.fz_document_count_pages_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if documentCountPagesFn20F867E7Func == nil {
		documentCountPagesFn20F867E7Func = x
	}
	return (*C.fz_document_count_pages_fn)(C.fz_document_count_pages_fn_20f867e7), nil
}

func NewDocumentCountPagesFnRef(ref unsafe.Pointer) *DocumentCountPagesFn {
	return (*DocumentCountPagesFn)(ref)
}

//export documentCountPagesFn20F867E7
func documentCountPagesFn20F867E7(cctx *C.fz_context, cdoc *C.fz_document) C.int {
	if documentCountPagesFn20F867E7Func != nil {
		var ctx20f867e7 []Context
		packSContext(ctx20f867e7, cctx)
		var doc20f867e7 []Document
		packSDocument(doc20f867e7, cdoc)
		ret20f867e7 := documentCountPagesFn20F867E7Func(ctx20f867e7, doc20f867e7)
		ret, _ := (C.int)(ret20f867e7), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var documentCountPagesFn20F867E7Func DocumentCountPagesFn

// unpackArgSPage transforms a sliced Go data structure into plain C format.
func unpackArgSPage(x []Page) (unpacked *C.fz_page, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_page) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPageMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_page)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_page)(unsafe.Pointer(h.Data))
	return
}

func (x DocumentLoadPageFn) PassRef() (ref *C.fz_document_load_page_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if documentLoadPageFnA32C9877Func == nil {
		documentLoadPageFnA32C9877Func = x
	}
	return (*C.fz_document_load_page_fn)(C.fz_document_load_page_fn_a32c9877), nil
}

func NewDocumentLoadPageFnRef(ref unsafe.Pointer) *DocumentLoadPageFn {
	return (*DocumentLoadPageFn)(ref)
}

//export documentLoadPageFnA32C9877
func documentLoadPageFnA32C9877(cctx *C.fz_context, cdoc *C.fz_document, cnumber C.int) *C.fz_page {
	if documentLoadPageFnA32C9877Func != nil {
		var ctxa32c9877 []Context
		packSContext(ctxa32c9877, cctx)
		var doca32c9877 []Document
		packSDocument(doca32c9877, cdoc)
		numbera32c9877 := (int32)(cnumber)
		reta32c9877 := documentLoadPageFnA32C9877Func(ctxa32c9877, doca32c9877, numbera32c9877)
		ret, _ := unpackArgSPage(reta32c9877)
		return ret
	}
	panic("callback func has not been set (race?)")
}

var documentLoadPageFnA32C9877Func DocumentLoadPageFn

func (x DocumentLookupMetadataFn) PassRef() (ref *C.fz_document_lookup_metadata_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if documentLookupMetadataFn1F9B8013Func == nil {
		documentLookupMetadataFn1F9B8013Func = x
	}
	return (*C.fz_document_lookup_metadata_fn)(C.fz_document_lookup_metadata_fn_1f9b8013), nil
}

func NewDocumentLookupMetadataFnRef(ref unsafe.Pointer) *DocumentLookupMetadataFn {
	return (*DocumentLookupMetadataFn)(ref)
}

//export documentLookupMetadataFn1F9B8013
func documentLookupMetadataFn1F9B8013(cctx *C.fz_context, cdoc *C.fz_document, ckey *C.char, cbuf *C.char, csize C.int) C.int {
	if documentLookupMetadataFn1F9B8013Func != nil {
		var ctx1f9b8013 []Context
		packSContext(ctx1f9b8013, cctx)
		var doc1f9b8013 []Document
		packSDocument(doc1f9b8013, cdoc)
		key1f9b8013 := packPCharString(ckey)
		var buf1f9b8013 []byte
		hxfb2f596 := (*sliceHeader)(unsafe.Pointer(&buf1f9b8013))
		hxfb2f596.Data = uintptr(unsafe.Pointer(cbuf))
		hxfb2f596.Cap = 0x7fffffff
		// hxfb2f596.Len = ?

		size1f9b8013 := (int32)(csize)
		ret1f9b8013 := documentLookupMetadataFn1F9B8013Func(ctx1f9b8013, doc1f9b8013, key1f9b8013, buf1f9b8013, size1f9b8013)
		ret, _ := (C.int)(ret1f9b8013), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var documentLookupMetadataFn1F9B8013Func DocumentLookupMetadataFn

func (x DocumentOutputIntentFn) PassRef() (ref *C.fz_document_output_intent_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if documentOutputIntentFn3E3B0BCFFunc == nil {
		documentOutputIntentFn3E3B0BCFFunc = x
	}
	return (*C.fz_document_output_intent_fn)(C.fz_document_output_intent_fn_3e3b0bcf), nil
}

func NewDocumentOutputIntentFnRef(ref unsafe.Pointer) *DocumentOutputIntentFn {
	return (*DocumentOutputIntentFn)(ref)
}

//export documentOutputIntentFn3E3B0BCF
func documentOutputIntentFn3E3B0BCF(cctx *C.fz_context, cdoc *C.fz_document) *C.fz_colorspace {
	if documentOutputIntentFn3E3B0BCFFunc != nil {
		var ctx3e3b0bcf []Context
		packSContext(ctx3e3b0bcf, cctx)
		var doc3e3b0bcf []Document
		packSDocument(doc3e3b0bcf, cdoc)
		ret3e3b0bcf := documentOutputIntentFn3E3B0BCFFunc(ctx3e3b0bcf, doc3e3b0bcf)
		ret, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ret3e3b0bcf)).Data)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var documentOutputIntentFn3E3B0BCFFunc DocumentOutputIntentFn

func (x DocumentMakeBookmarkFn) PassRef() (ref *C.fz_document_make_bookmark_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if documentMakeBookmarkFnCD7A2755Func == nil {
		documentMakeBookmarkFnCD7A2755Func = x
	}
	return (*C.fz_document_make_bookmark_fn)(C.fz_document_make_bookmark_fn_cd7a2755), nil
}

func NewDocumentMakeBookmarkFnRef(ref unsafe.Pointer) *DocumentMakeBookmarkFn {
	return (*DocumentMakeBookmarkFn)(ref)
}

//export documentMakeBookmarkFnCD7A2755
func documentMakeBookmarkFnCD7A2755(cctx *C.fz_context, cdoc *C.fz_document, cpage C.int) C.fz_bookmark {
	if documentMakeBookmarkFnCD7A2755Func != nil {
		var ctxcd7a2755 []Context
		packSContext(ctxcd7a2755, cctx)
		var doccd7a2755 []Document
		packSDocument(doccd7a2755, cdoc)
		pagecd7a2755 := (int32)(cpage)
		retcd7a2755 := documentMakeBookmarkFnCD7A2755Func(ctxcd7a2755, doccd7a2755, pagecd7a2755)
		ret, _ := (C.fz_bookmark)(retcd7a2755), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var documentMakeBookmarkFnCD7A2755Func DocumentMakeBookmarkFn

func (x DocumentLookupBookmarkFn) PassRef() (ref *C.fz_document_lookup_bookmark_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if documentLookupBookmarkFn5171746FFunc == nil {
		documentLookupBookmarkFn5171746FFunc = x
	}
	return (*C.fz_document_lookup_bookmark_fn)(C.fz_document_lookup_bookmark_fn_5171746f), nil
}

func NewDocumentLookupBookmarkFnRef(ref unsafe.Pointer) *DocumentLookupBookmarkFn {
	return (*DocumentLookupBookmarkFn)(ref)
}

//export documentLookupBookmarkFn5171746F
func documentLookupBookmarkFn5171746F(cctx *C.fz_context, cdoc *C.fz_document, cmark C.fz_bookmark) C.int {
	if documentLookupBookmarkFn5171746FFunc != nil {
		var ctx5171746f []Context
		packSContext(ctx5171746f, cctx)
		var doc5171746f []Document
		packSDocument(doc5171746f, cdoc)
		mark5171746f := (Bookmark)(cmark)
		ret5171746f := documentLookupBookmarkFn5171746FFunc(ctx5171746f, doc5171746f, mark5171746f)
		ret, _ := (C.int)(ret5171746f), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var documentLookupBookmarkFn5171746FFunc DocumentLookupBookmarkFn

// packSPage reads sliced Go data structure out from plain C format.
func packSPage(v []Page, ptr0 *C.fz_page) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPageValue]C.fz_page)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPageRef(unsafe.Pointer(&ptr1))
	}
}

func (x PageDropPageFn) PassRef() (ref *C.fz_page_drop_page_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pageDropPageFnE86AD7C7Func == nil {
		pageDropPageFnE86AD7C7Func = x
	}
	return (*C.fz_page_drop_page_fn)(C.fz_page_drop_page_fn_e86ad7c7), nil
}

func NewPageDropPageFnRef(ref unsafe.Pointer) *PageDropPageFn {
	return (*PageDropPageFn)(ref)
}

//export pageDropPageFnE86AD7C7
func pageDropPageFnE86AD7C7(cctx *C.fz_context, cpage *C.fz_page) {
	if pageDropPageFnE86AD7C7Func != nil {
		var ctxe86ad7c7 []Context
		packSContext(ctxe86ad7c7, cctx)
		var pagee86ad7c7 []Page
		packSPage(pagee86ad7c7, cpage)
		pageDropPageFnE86AD7C7Func(ctxe86ad7c7, pagee86ad7c7)
		return
	}
	panic("callback func has not been set (race?)")
}

var pageDropPageFnE86AD7C7Func PageDropPageFn

// packSRect reads sliced Go data structure out from plain C format.
func packSRect(v []Rect, ptr0 *C.fz_rect) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRectValue]C.fz_rect)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRectRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSRect transforms a sliced Go data structure into plain C format.
func unpackArgSRect(x []Rect) (unpacked *C.fz_rect, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_rect) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRectMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_rect)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_rect)(unsafe.Pointer(h.Data))
	return
}

func (x PageBoundPageFn) PassRef() (ref *C.fz_page_bound_page_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pageBoundPageFnA77BC5EDFunc == nil {
		pageBoundPageFnA77BC5EDFunc = x
	}
	return (*C.fz_page_bound_page_fn)(C.fz_page_bound_page_fn_a77bc5ed), nil
}

func NewPageBoundPageFnRef(ref unsafe.Pointer) *PageBoundPageFn {
	return (*PageBoundPageFn)(ref)
}

//export pageBoundPageFnA77BC5ED
func pageBoundPageFnA77BC5ED(cctx *C.fz_context, cpage *C.fz_page, carg2 *C.fz_rect) *C.fz_rect {
	if pageBoundPageFnA77BC5EDFunc != nil {
		var ctxa77bc5ed []Context
		packSContext(ctxa77bc5ed, cctx)
		var pagea77bc5ed []Page
		packSPage(pagea77bc5ed, cpage)
		var arg2a77bc5ed []Rect
		packSRect(arg2a77bc5ed, carg2)
		reta77bc5ed := pageBoundPageFnA77BC5EDFunc(ctxa77bc5ed, pagea77bc5ed, arg2a77bc5ed)
		ret, _ := unpackArgSRect(reta77bc5ed)
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pageBoundPageFnA77BC5EDFunc PageBoundPageFn

// packSDevice reads sliced Go data structure out from plain C format.
func packSDevice(v []Device, ptr0 *C.fz_device) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDeviceValue]C.fz_device)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDeviceRef(unsafe.Pointer(&ptr1))
	}
}

// packSMatrix reads sliced Go data structure out from plain C format.
func packSMatrix(v []Matrix, ptr0 *C.fz_matrix) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMatrixValue]C.fz_matrix)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMatrixRef(unsafe.Pointer(&ptr1))
	}
}

// packSCookie reads sliced Go data structure out from plain C format.
func packSCookie(v []Cookie, ptr0 *C.fz_cookie) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCookieValue]C.fz_cookie)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCookieRef(unsafe.Pointer(&ptr1))
	}
}

func (x PageRunPageContentsFn) PassRef() (ref *C.fz_page_run_page_contents_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pageRunPageContentsFn7710BE3EFunc == nil {
		pageRunPageContentsFn7710BE3EFunc = x
	}
	return (*C.fz_page_run_page_contents_fn)(C.fz_page_run_page_contents_fn_7710be3e), nil
}

func NewPageRunPageContentsFnRef(ref unsafe.Pointer) *PageRunPageContentsFn {
	return (*PageRunPageContentsFn)(ref)
}

//export pageRunPageContentsFn7710BE3E
func pageRunPageContentsFn7710BE3E(cctx *C.fz_context, cpage *C.fz_page, cdev *C.fz_device, ctransform *C.fz_matrix, ccookie *C.fz_cookie) {
	if pageRunPageContentsFn7710BE3EFunc != nil {
		var ctx7710be3e []Context
		packSContext(ctx7710be3e, cctx)
		var page7710be3e []Page
		packSPage(page7710be3e, cpage)
		var dev7710be3e []Device
		packSDevice(dev7710be3e, cdev)
		var transform7710be3e []Matrix
		packSMatrix(transform7710be3e, ctransform)
		var cookie7710be3e []Cookie
		packSCookie(cookie7710be3e, ccookie)
		pageRunPageContentsFn7710BE3EFunc(ctx7710be3e, page7710be3e, dev7710be3e, transform7710be3e, cookie7710be3e)
		return
	}
	panic("callback func has not been set (race?)")
}

var pageRunPageContentsFn7710BE3EFunc PageRunPageContentsFn

// unpackArgSLink transforms a sliced Go data structure into plain C format.
func unpackArgSLink(x []Link) (unpacked *C.fz_link, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_link) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocLinkMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_link)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_link)(unsafe.Pointer(h.Data))
	return
}

func (x PageLoadLinksFn) PassRef() (ref *C.fz_page_load_links_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pageLoadLinksFn40246AC6Func == nil {
		pageLoadLinksFn40246AC6Func = x
	}
	return (*C.fz_page_load_links_fn)(C.fz_page_load_links_fn_40246ac6), nil
}

func NewPageLoadLinksFnRef(ref unsafe.Pointer) *PageLoadLinksFn {
	return (*PageLoadLinksFn)(ref)
}

//export pageLoadLinksFn40246AC6
func pageLoadLinksFn40246AC6(cctx *C.fz_context, cpage *C.fz_page) *C.fz_link {
	if pageLoadLinksFn40246AC6Func != nil {
		var ctx40246ac6 []Context
		packSContext(ctx40246ac6, cctx)
		var page40246ac6 []Page
		packSPage(page40246ac6, cpage)
		ret40246ac6 := pageLoadLinksFn40246AC6Func(ctx40246ac6, page40246ac6)
		ret, _ := unpackArgSLink(ret40246ac6)
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pageLoadLinksFn40246AC6Func PageLoadLinksFn

// unpackArgSAnnot transforms a sliced Go data structure into plain C format.
func unpackArgSAnnot(x []Annot) (unpacked *C.fz_annot, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_annot) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocAnnotMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_annot)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_annot)(unsafe.Pointer(h.Data))
	return
}

func (x PageFirstAnnotFn) PassRef() (ref *C.fz_page_first_annot_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pageFirstAnnotFn96BF83A2Func == nil {
		pageFirstAnnotFn96BF83A2Func = x
	}
	return (*C.fz_page_first_annot_fn)(C.fz_page_first_annot_fn_96bf83a2), nil
}

func NewPageFirstAnnotFnRef(ref unsafe.Pointer) *PageFirstAnnotFn {
	return (*PageFirstAnnotFn)(ref)
}

//export pageFirstAnnotFn96BF83A2
func pageFirstAnnotFn96BF83A2(cctx *C.fz_context, cpage *C.fz_page) *C.fz_annot {
	if pageFirstAnnotFn96BF83A2Func != nil {
		var ctx96bf83a2 []Context
		packSContext(ctx96bf83a2, cctx)
		var page96bf83a2 []Page
		packSPage(page96bf83a2, cpage)
		ret96bf83a2 := pageFirstAnnotFn96BF83A2Func(ctx96bf83a2, page96bf83a2)
		ret, _ := unpackArgSAnnot(ret96bf83a2)
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pageFirstAnnotFn96BF83A2Func PageFirstAnnotFn

// packSTransition reads sliced Go data structure out from plain C format.
func packSTransition(v []Transition, ptr0 *C.fz_transition) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTransitionValue]C.fz_transition)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTransitionRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTransition transforms a sliced Go data structure into plain C format.
func unpackArgSTransition(x []Transition) (unpacked *C.fz_transition, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_transition) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocTransitionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_transition)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_transition)(unsafe.Pointer(h.Data))
	return
}

func (x PagePagePresentationFn) PassRef() (ref *C.fz_page_page_presentation_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pagePagePresentationFn4C62D63FFunc == nil {
		pagePagePresentationFn4C62D63FFunc = x
	}
	return (*C.fz_page_page_presentation_fn)(C.fz_page_page_presentation_fn_4c62d63f), nil
}

func NewPagePagePresentationFnRef(ref unsafe.Pointer) *PagePagePresentationFn {
	return (*PagePagePresentationFn)(ref)
}

//export pagePagePresentationFn4C62D63F
func pagePagePresentationFn4C62D63F(cctx *C.fz_context, cpage *C.fz_page, ctransition *C.fz_transition, cduration *C.float) *C.fz_transition {
	if pagePagePresentationFn4C62D63FFunc != nil {
		var ctx4c62d63f []Context
		packSContext(ctx4c62d63f, cctx)
		var page4c62d63f []Page
		packSPage(page4c62d63f, cpage)
		var transition4c62d63f []Transition
		packSTransition(transition4c62d63f, ctransition)
		var duration4c62d63f []float32
		hxf11683e := (*sliceHeader)(unsafe.Pointer(&duration4c62d63f))
		hxf11683e.Data = uintptr(unsafe.Pointer(cduration))
		hxf11683e.Cap = 0x7fffffff
		// hxf11683e.Len = ?

		ret4c62d63f := pagePagePresentationFn4C62D63FFunc(ctx4c62d63f, page4c62d63f, transition4c62d63f, duration4c62d63f)
		ret, _ := unpackArgSTransition(ret4c62d63f)
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pagePagePresentationFn4C62D63FFunc PagePagePresentationFn

func (x PageControlSeparationFn) PassRef() (ref *C.fz_page_control_separation_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pageControlSeparationFnA66789C6Func == nil {
		pageControlSeparationFnA66789C6Func = x
	}
	return (*C.fz_page_control_separation_fn)(C.fz_page_control_separation_fn_a66789c6), nil
}

func NewPageControlSeparationFnRef(ref unsafe.Pointer) *PageControlSeparationFn {
	return (*PageControlSeparationFn)(ref)
}

//export pageControlSeparationFnA66789C6
func pageControlSeparationFnA66789C6(cctx *C.fz_context, cpage *C.fz_page, cseparation C.int, cdisable C.int) {
	if pageControlSeparationFnA66789C6Func != nil {
		var ctxa66789c6 []Context
		packSContext(ctxa66789c6, cctx)
		var pagea66789c6 []Page
		packSPage(pagea66789c6, cpage)
		separationa66789c6 := (int32)(cseparation)
		disablea66789c6 := (int32)(cdisable)
		pageControlSeparationFnA66789C6Func(ctxa66789c6, pagea66789c6, separationa66789c6, disablea66789c6)
		return
	}
	panic("callback func has not been set (race?)")
}

var pageControlSeparationFnA66789C6Func PageControlSeparationFn

func (x PageSeparationDisabledFn) PassRef() (ref *C.fz_page_separation_disabled_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pageSeparationDisabledFn6286727EFunc == nil {
		pageSeparationDisabledFn6286727EFunc = x
	}
	return (*C.fz_page_separation_disabled_fn)(C.fz_page_separation_disabled_fn_6286727e), nil
}

func NewPageSeparationDisabledFnRef(ref unsafe.Pointer) *PageSeparationDisabledFn {
	return (*PageSeparationDisabledFn)(ref)
}

//export pageSeparationDisabledFn6286727E
func pageSeparationDisabledFn6286727E(cctx *C.fz_context, cpage *C.fz_page, cseparation C.int) C.int {
	if pageSeparationDisabledFn6286727EFunc != nil {
		var ctx6286727e []Context
		packSContext(ctx6286727e, cctx)
		var page6286727e []Page
		packSPage(page6286727e, cpage)
		separation6286727e := (int32)(cseparation)
		ret6286727e := pageSeparationDisabledFn6286727EFunc(ctx6286727e, page6286727e, separation6286727e)
		ret, _ := (C.int)(ret6286727e), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pageSeparationDisabledFn6286727EFunc PageSeparationDisabledFn

func (x PageSeparationsFn) PassRef() (ref *C.fz_page_separations_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pageSeparationsFn854F23A7Func == nil {
		pageSeparationsFn854F23A7Func = x
	}
	return (*C.fz_page_separations_fn)(C.fz_page_separations_fn_854f23a7), nil
}

func NewPageSeparationsFnRef(ref unsafe.Pointer) *PageSeparationsFn {
	return (*PageSeparationsFn)(ref)
}

//export pageSeparationsFn854F23A7
func pageSeparationsFn854F23A7(cctx *C.fz_context, cpage *C.fz_page) *C.fz_separations {
	if pageSeparationsFn854F23A7Func != nil {
		var ctx854f23a7 []Context
		packSContext(ctx854f23a7, cctx)
		var page854f23a7 []Page
		packSPage(page854f23a7, cpage)
		ret854f23a7 := pageSeparationsFn854F23A7Func(ctx854f23a7, page854f23a7)
		ret, _ := (*C.fz_separations)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ret854f23a7)).Data)), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pageSeparationsFn854F23A7Func PageSeparationsFn

// packSAnnot reads sliced Go data structure out from plain C format.
func packSAnnot(v []Annot, ptr0 *C.fz_annot) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAnnotValue]C.fz_annot)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAnnotRef(unsafe.Pointer(&ptr1))
	}
}

func (x AnnotDropFn) PassRef() (ref *C.fz_annot_drop_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if annotDropFn30A53795Func == nil {
		annotDropFn30A53795Func = x
	}
	return (*C.fz_annot_drop_fn)(C.fz_annot_drop_fn_30a53795), nil
}

func NewAnnotDropFnRef(ref unsafe.Pointer) *AnnotDropFn {
	return (*AnnotDropFn)(ref)
}

//export annotDropFn30A53795
func annotDropFn30A53795(cctx *C.fz_context, cannot *C.fz_annot) {
	if annotDropFn30A53795Func != nil {
		var ctx30a53795 []Context
		packSContext(ctx30a53795, cctx)
		var annot30a53795 []Annot
		packSAnnot(annot30a53795, cannot)
		annotDropFn30A53795Func(ctx30a53795, annot30a53795)
		return
	}
	panic("callback func has not been set (race?)")
}

var annotDropFn30A53795Func AnnotDropFn

func (x AnnotNextFn) PassRef() (ref *C.fz_annot_next_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if annotNextFnD7A4863DFunc == nil {
		annotNextFnD7A4863DFunc = x
	}
	return (*C.fz_annot_next_fn)(C.fz_annot_next_fn_d7a4863d), nil
}

func NewAnnotNextFnRef(ref unsafe.Pointer) *AnnotNextFn {
	return (*AnnotNextFn)(ref)
}

//export annotNextFnD7A4863D
func annotNextFnD7A4863D(cctx *C.fz_context, cannot *C.fz_annot) *C.fz_annot {
	if annotNextFnD7A4863DFunc != nil {
		var ctxd7a4863d []Context
		packSContext(ctxd7a4863d, cctx)
		var annotd7a4863d []Annot
		packSAnnot(annotd7a4863d, cannot)
		retd7a4863d := annotNextFnD7A4863DFunc(ctxd7a4863d, annotd7a4863d)
		ret, _ := unpackArgSAnnot(retd7a4863d)
		return ret
	}
	panic("callback func has not been set (race?)")
}

var annotNextFnD7A4863DFunc AnnotNextFn

func (x AnnotBoundFn) PassRef() (ref *C.fz_annot_bound_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if annotBoundFn81EFB60EFunc == nil {
		annotBoundFn81EFB60EFunc = x
	}
	return (*C.fz_annot_bound_fn)(C.fz_annot_bound_fn_81efb60e), nil
}

func NewAnnotBoundFnRef(ref unsafe.Pointer) *AnnotBoundFn {
	return (*AnnotBoundFn)(ref)
}

//export annotBoundFn81EFB60E
func annotBoundFn81EFB60E(cctx *C.fz_context, cannot *C.fz_annot, crect *C.fz_rect) *C.fz_rect {
	if annotBoundFn81EFB60EFunc != nil {
		var ctx81efb60e []Context
		packSContext(ctx81efb60e, cctx)
		var annot81efb60e []Annot
		packSAnnot(annot81efb60e, cannot)
		var rect81efb60e []Rect
		packSRect(rect81efb60e, crect)
		ret81efb60e := annotBoundFn81EFB60EFunc(ctx81efb60e, annot81efb60e, rect81efb60e)
		ret, _ := unpackArgSRect(ret81efb60e)
		return ret
	}
	panic("callback func has not been set (race?)")
}

var annotBoundFn81EFB60EFunc AnnotBoundFn

func (x AnnotRunFn) PassRef() (ref *C.fz_annot_run_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if annotRunFnF3FF5201Func == nil {
		annotRunFnF3FF5201Func = x
	}
	return (*C.fz_annot_run_fn)(C.fz_annot_run_fn_f3ff5201), nil
}

func NewAnnotRunFnRef(ref unsafe.Pointer) *AnnotRunFn {
	return (*AnnotRunFn)(ref)
}

//export annotRunFnF3FF5201
func annotRunFnF3FF5201(cctx *C.fz_context, cannot *C.fz_annot, cdev *C.fz_device, ctransform *C.fz_matrix, ccookie *C.fz_cookie) {
	if annotRunFnF3FF5201Func != nil {
		var ctxf3ff5201 []Context
		packSContext(ctxf3ff5201, cctx)
		var annotf3ff5201 []Annot
		packSAnnot(annotf3ff5201, cannot)
		var devf3ff5201 []Device
		packSDevice(devf3ff5201, cdev)
		var transformf3ff5201 []Matrix
		packSMatrix(transformf3ff5201, ctransform)
		var cookief3ff5201 []Cookie
		packSCookie(cookief3ff5201, ccookie)
		annotRunFnF3FF5201Func(ctxf3ff5201, annotf3ff5201, devf3ff5201, transformf3ff5201, cookief3ff5201)
		return
	}
	panic("callback func has not been set (race?)")
}

var annotRunFnF3FF5201Func AnnotRunFn

// unpackArgSDocument transforms a sliced Go data structure into plain C format.
func unpackArgSDocument(x []Document) (unpacked *C.fz_document, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_document) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDocumentMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_document)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_document)(unsafe.Pointer(h.Data))
	return
}

func (x DocumentOpenFn) PassRef() (ref *C.fz_document_open_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if documentOpenFnAC22541FFunc == nil {
		documentOpenFnAC22541FFunc = x
	}
	return (*C.fz_document_open_fn)(C.fz_document_open_fn_ac22541f), nil
}

func NewDocumentOpenFnRef(ref unsafe.Pointer) *DocumentOpenFn {
	return (*DocumentOpenFn)(ref)
}

//export documentOpenFnAC22541F
func documentOpenFnAC22541F(cctx *C.fz_context, cfilename *C.char) *C.fz_document {
	if documentOpenFnAC22541FFunc != nil {
		var ctxac22541f []Context
		packSContext(ctxac22541f, cctx)
		filenameac22541f := packPCharString(cfilename)
		retac22541f := documentOpenFnAC22541FFunc(ctxac22541f, filenameac22541f)
		ret, _ := unpackArgSDocument(retac22541f)
		return ret
	}
	panic("callback func has not been set (race?)")
}

var documentOpenFnAC22541FFunc DocumentOpenFn

func (x DocumentOpenWithStreamFn) PassRef() (ref *C.fz_document_open_with_stream_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if documentOpenWithStreamFnD625D461Func == nil {
		documentOpenWithStreamFnD625D461Func = x
	}
	return (*C.fz_document_open_with_stream_fn)(C.fz_document_open_with_stream_fn_d625d461), nil
}

func NewDocumentOpenWithStreamFnRef(ref unsafe.Pointer) *DocumentOpenWithStreamFn {
	return (*DocumentOpenWithStreamFn)(ref)
}

//export documentOpenWithStreamFnD625D461
func documentOpenWithStreamFnD625D461(cctx *C.fz_context, cstream *C.fz_stream) *C.fz_document {
	if documentOpenWithStreamFnD625D461Func != nil {
		var ctxd625d461 []Context
		packSContext(ctxd625d461, cctx)
		var streamd625d461 []Stream
		packSStream(streamd625d461, cstream)
		retd625d461 := documentOpenWithStreamFnD625D461Func(ctxd625d461, streamd625d461)
		ret, _ := unpackArgSDocument(retd625d461)
		return ret
	}
	panic("callback func has not been set (race?)")
}

var documentOpenWithStreamFnD625D461Func DocumentOpenWithStreamFn

func (x DocumentRecognizeFn) PassRef() (ref *C.fz_document_recognize_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if documentRecognizeFn37E0CEF4Func == nil {
		documentRecognizeFn37E0CEF4Func = x
	}
	return (*C.fz_document_recognize_fn)(C.fz_document_recognize_fn_37e0cef4), nil
}

func NewDocumentRecognizeFnRef(ref unsafe.Pointer) *DocumentRecognizeFn {
	return (*DocumentRecognizeFn)(ref)
}

//export documentRecognizeFn37E0CEF4
func documentRecognizeFn37E0CEF4(cctx *C.fz_context, cmagic *C.char) C.int {
	if documentRecognizeFn37E0CEF4Func != nil {
		var ctx37e0cef4 []Context
		packSContext(ctx37e0cef4, cctx)
		magic37e0cef4 := packPCharString(cmagic)
		ret37e0cef4 := documentRecognizeFn37E0CEF4Func(ctx37e0cef4, magic37e0cef4)
		ret, _ := (C.int)(ret37e0cef4), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var documentRecognizeFn37E0CEF4Func DocumentRecognizeFn

// allocDocumentWriterMemory allocates memory for type C.fz_document_writer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDocumentWriterMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDocumentWriterValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDocumentWriterValue = unsafe.Sizeof([1]C.fz_document_writer{})

// unpackSDevice transforms a sliced Go data structure into plain C format.
func unpackSDevice(x []Device) (unpacked *C.fz_device, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_device) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDeviceMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_device)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_device)(unsafe.Pointer(h.Data))
	return
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DocumentWriter) Ref() *C.fz_document_writer {
	if x == nil {
		return nil
	}
	return x.ref60966fef
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DocumentWriter) Free() {
	if x != nil && x.allocs60966fef != nil {
		x.allocs60966fef.(*cgoAllocMap).Free()
		x.ref60966fef = nil
	}
}

// NewDocumentWriterRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDocumentWriterRef(ref unsafe.Pointer) *DocumentWriter {
	if ref == nil {
		return nil
	}
	obj := new(DocumentWriter)
	obj.ref60966fef = (*C.fz_document_writer)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DocumentWriter) PassRef() (*C.fz_document_writer, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref60966fef != nil {
		return x.ref60966fef, nil
	}
	mem60966fef := allocDocumentWriterMemory(1)
	ref60966fef := (*C.fz_document_writer)(mem60966fef)
	allocs60966fef := new(cgoAllocMap)
	allocs60966fef.Add(mem60966fef)

	var cbegin_page_allocs *cgoAllocMap
	ref60966fef.begin_page, cbegin_page_allocs = x.BeginPage.PassRef()
	allocs60966fef.Borrow(cbegin_page_allocs)

	var cend_page_allocs *cgoAllocMap
	ref60966fef.end_page, cend_page_allocs = x.EndPage.PassRef()
	allocs60966fef.Borrow(cend_page_allocs)

	var cclose_writer_allocs *cgoAllocMap
	ref60966fef.close_writer, cclose_writer_allocs = x.CloseWriter.PassRef()
	allocs60966fef.Borrow(cclose_writer_allocs)

	var cdrop_writer_allocs *cgoAllocMap
	ref60966fef.drop_writer, cdrop_writer_allocs = x.DropWriter.PassRef()
	allocs60966fef.Borrow(cdrop_writer_allocs)

	var cdev_allocs *cgoAllocMap
	ref60966fef.dev, cdev_allocs = unpackSDevice(x.Dev)
	allocs60966fef.Borrow(cdev_allocs)

	x.ref60966fef = ref60966fef
	x.allocs60966fef = allocs60966fef
	return ref60966fef, allocs60966fef

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DocumentWriter) PassValue() (C.fz_document_writer, *cgoAllocMap) {
	if x.ref60966fef != nil {
		return *x.ref60966fef, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DocumentWriter) Deref() {
	if x.ref60966fef == nil {
		return
	}
	x.BeginPage = NewDocumentWriterBeginPageFnRef(unsafe.Pointer(x.ref60966fef.begin_page))
	x.EndPage = NewDocumentWriterEndPageFnRef(unsafe.Pointer(x.ref60966fef.end_page))
	x.CloseWriter = NewDocumentWriterCloseWriterFnRef(unsafe.Pointer(x.ref60966fef.close_writer))
	x.DropWriter = NewDocumentWriterDropWriterFnRef(unsafe.Pointer(x.ref60966fef.drop_writer))
	packSDevice(x.Dev, x.ref60966fef.dev)
}

// packSDocumentWriter reads sliced Go data structure out from plain C format.
func packSDocumentWriter(v []DocumentWriter, ptr0 *C.fz_document_writer) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDocumentWriterValue]C.fz_document_writer)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDocumentWriterRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDevice transforms a sliced Go data structure into plain C format.
func unpackArgSDevice(x []Device) (unpacked *C.fz_device, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_device) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDeviceMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_device)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_device)(unsafe.Pointer(h.Data))
	return
}

func (x DocumentWriterBeginPageFn) PassRef() (ref *C.fz_document_writer_begin_page_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if documentWriterBeginPageFn67284625Func == nil {
		documentWriterBeginPageFn67284625Func = x
	}
	return (*C.fz_document_writer_begin_page_fn)(C.fz_document_writer_begin_page_fn_67284625), nil
}

func NewDocumentWriterBeginPageFnRef(ref unsafe.Pointer) *DocumentWriterBeginPageFn {
	return (*DocumentWriterBeginPageFn)(ref)
}

//export documentWriterBeginPageFn67284625
func documentWriterBeginPageFn67284625(cctx *C.fz_context, cwri *C.fz_document_writer, cmediabox *C.fz_rect) *C.fz_device {
	if documentWriterBeginPageFn67284625Func != nil {
		var ctx67284625 []Context
		packSContext(ctx67284625, cctx)
		var wri67284625 []DocumentWriter
		packSDocumentWriter(wri67284625, cwri)
		var mediabox67284625 []Rect
		packSRect(mediabox67284625, cmediabox)
		ret67284625 := documentWriterBeginPageFn67284625Func(ctx67284625, wri67284625, mediabox67284625)
		ret, _ := unpackArgSDevice(ret67284625)
		return ret
	}
	panic("callback func has not been set (race?)")
}

var documentWriterBeginPageFn67284625Func DocumentWriterBeginPageFn

func (x DocumentWriterEndPageFn) PassRef() (ref *C.fz_document_writer_end_page_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if documentWriterEndPageFnC982F24FFunc == nil {
		documentWriterEndPageFnC982F24FFunc = x
	}
	return (*C.fz_document_writer_end_page_fn)(C.fz_document_writer_end_page_fn_c982f24f), nil
}

func NewDocumentWriterEndPageFnRef(ref unsafe.Pointer) *DocumentWriterEndPageFn {
	return (*DocumentWriterEndPageFn)(ref)
}

//export documentWriterEndPageFnC982F24F
func documentWriterEndPageFnC982F24F(cctx *C.fz_context, cwri *C.fz_document_writer, cdev *C.fz_device) {
	if documentWriterEndPageFnC982F24FFunc != nil {
		var ctxc982f24f []Context
		packSContext(ctxc982f24f, cctx)
		var wric982f24f []DocumentWriter
		packSDocumentWriter(wric982f24f, cwri)
		var devc982f24f []Device
		packSDevice(devc982f24f, cdev)
		documentWriterEndPageFnC982F24FFunc(ctxc982f24f, wric982f24f, devc982f24f)
		return
	}
	panic("callback func has not been set (race?)")
}

var documentWriterEndPageFnC982F24FFunc DocumentWriterEndPageFn

func (x DocumentWriterCloseWriterFn) PassRef() (ref *C.fz_document_writer_close_writer_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if documentWriterCloseWriterFn383BAADDFunc == nil {
		documentWriterCloseWriterFn383BAADDFunc = x
	}
	return (*C.fz_document_writer_close_writer_fn)(C.fz_document_writer_close_writer_fn_383baadd), nil
}

func NewDocumentWriterCloseWriterFnRef(ref unsafe.Pointer) *DocumentWriterCloseWriterFn {
	return (*DocumentWriterCloseWriterFn)(ref)
}

//export documentWriterCloseWriterFn383BAADD
func documentWriterCloseWriterFn383BAADD(cctx *C.fz_context, cwri *C.fz_document_writer) {
	if documentWriterCloseWriterFn383BAADDFunc != nil {
		var ctx383baadd []Context
		packSContext(ctx383baadd, cctx)
		var wri383baadd []DocumentWriter
		packSDocumentWriter(wri383baadd, cwri)
		documentWriterCloseWriterFn383BAADDFunc(ctx383baadd, wri383baadd)
		return
	}
	panic("callback func has not been set (race?)")
}

var documentWriterCloseWriterFn383BAADDFunc DocumentWriterCloseWriterFn

func (x DocumentWriterDropWriterFn) PassRef() (ref *C.fz_document_writer_drop_writer_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if documentWriterDropWriterFn2AC1EB31Func == nil {
		documentWriterDropWriterFn2AC1EB31Func = x
	}
	return (*C.fz_document_writer_drop_writer_fn)(C.fz_document_writer_drop_writer_fn_2ac1eb31), nil
}

func NewDocumentWriterDropWriterFnRef(ref unsafe.Pointer) *DocumentWriterDropWriterFn {
	return (*DocumentWriterDropWriterFn)(ref)
}

//export documentWriterDropWriterFn2AC1EB31
func documentWriterDropWriterFn2AC1EB31(cctx *C.fz_context, cwri *C.fz_document_writer) {
	if documentWriterDropWriterFn2AC1EB31Func != nil {
		var ctx2ac1eb31 []Context
		packSContext(ctx2ac1eb31, cctx)
		var wri2ac1eb31 []DocumentWriter
		packSDocumentWriter(wri2ac1eb31, cwri)
		documentWriterDropWriterFn2AC1EB31Func(ctx2ac1eb31, wri2ac1eb31)
		return
	}
	panic("callback func has not been set (race?)")
}

var documentWriterDropWriterFn2AC1EB31Func DocumentWriterDropWriterFn

// allocBandWriterMemory allocates memory for type C.fz_band_writer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBandWriterMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBandWriterValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBandWriterValue = unsafe.Sizeof([1]C.fz_band_writer{})

// unpackSOutput transforms a sliced Go data structure into plain C format.
func unpackSOutput(x []Output) (unpacked *C.fz_output, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_output) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocOutputMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_output)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_output)(unsafe.Pointer(h.Data))
	return
}

// packSOutput reads sliced Go data structure out from plain C format.
func packSOutput(v []Output, ptr0 *C.fz_output) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfOutputValue]C.fz_output)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewOutputRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BandWriter) Ref() *C.fz_band_writer {
	if x == nil {
		return nil
	}
	return x.ref6e823638
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BandWriter) Free() {
	if x != nil && x.allocs6e823638 != nil {
		x.allocs6e823638.(*cgoAllocMap).Free()
		x.ref6e823638 = nil
	}
}

// NewBandWriterRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBandWriterRef(ref unsafe.Pointer) *BandWriter {
	if ref == nil {
		return nil
	}
	obj := new(BandWriter)
	obj.ref6e823638 = (*C.fz_band_writer)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BandWriter) PassRef() (*C.fz_band_writer, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6e823638 != nil {
		return x.ref6e823638, nil
	}
	mem6e823638 := allocBandWriterMemory(1)
	ref6e823638 := (*C.fz_band_writer)(mem6e823638)
	allocs6e823638 := new(cgoAllocMap)
	allocs6e823638.Add(mem6e823638)

	var cdrop_allocs *cgoAllocMap
	ref6e823638.drop, cdrop_allocs = x.Drop.PassRef()
	allocs6e823638.Borrow(cdrop_allocs)

	var cheader_allocs *cgoAllocMap
	ref6e823638.header, cheader_allocs = x.Header.PassRef()
	allocs6e823638.Borrow(cheader_allocs)

	var cband_allocs *cgoAllocMap
	ref6e823638.band, cband_allocs = x.Band.PassRef()
	allocs6e823638.Borrow(cband_allocs)

	var ctrailer_allocs *cgoAllocMap
	ref6e823638.trailer, ctrailer_allocs = x.Trailer.PassRef()
	allocs6e823638.Borrow(ctrailer_allocs)

	var cout_allocs *cgoAllocMap
	ref6e823638.out, cout_allocs = unpackSOutput(x.Out)
	allocs6e823638.Borrow(cout_allocs)

	var cw_allocs *cgoAllocMap
	ref6e823638.w, cw_allocs = (C.int)(x.W), cgoAllocsUnknown
	allocs6e823638.Borrow(cw_allocs)

	var ch_allocs *cgoAllocMap
	ref6e823638.h, ch_allocs = (C.int)(x.H), cgoAllocsUnknown
	allocs6e823638.Borrow(ch_allocs)

	var cn_allocs *cgoAllocMap
	ref6e823638.n, cn_allocs = (C.int)(x.N), cgoAllocsUnknown
	allocs6e823638.Borrow(cn_allocs)

	var cs_allocs *cgoAllocMap
	ref6e823638.s, cs_allocs = (C.int)(x.S), cgoAllocsUnknown
	allocs6e823638.Borrow(cs_allocs)

	var calpha_allocs *cgoAllocMap
	ref6e823638.alpha, calpha_allocs = (C.int)(x.Alpha), cgoAllocsUnknown
	allocs6e823638.Borrow(calpha_allocs)

	var cxres_allocs *cgoAllocMap
	ref6e823638.xres, cxres_allocs = (C.int)(x.Xres), cgoAllocsUnknown
	allocs6e823638.Borrow(cxres_allocs)

	var cyres_allocs *cgoAllocMap
	ref6e823638.yres, cyres_allocs = (C.int)(x.Yres), cgoAllocsUnknown
	allocs6e823638.Borrow(cyres_allocs)

	var cpagenum_allocs *cgoAllocMap
	ref6e823638.pagenum, cpagenum_allocs = (C.int)(x.Pagenum), cgoAllocsUnknown
	allocs6e823638.Borrow(cpagenum_allocs)

	var cline_allocs *cgoAllocMap
	ref6e823638.line, cline_allocs = (C.int)(x.Line), cgoAllocsUnknown
	allocs6e823638.Borrow(cline_allocs)

	var cseps_allocs *cgoAllocMap
	ref6e823638.seps, cseps_allocs = (*C.fz_separations)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Seps)).Data)), cgoAllocsUnknown
	allocs6e823638.Borrow(cseps_allocs)

	x.ref6e823638 = ref6e823638
	x.allocs6e823638 = allocs6e823638
	return ref6e823638, allocs6e823638

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BandWriter) PassValue() (C.fz_band_writer, *cgoAllocMap) {
	if x.ref6e823638 != nil {
		return *x.ref6e823638, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BandWriter) Deref() {
	if x.ref6e823638 == nil {
		return
	}
	x.Drop = NewDropBandWriterFnRef(unsafe.Pointer(x.ref6e823638.drop))
	x.Header = NewWriteHeaderFnRef(unsafe.Pointer(x.ref6e823638.header))
	x.Band = NewWriteBandFnRef(unsafe.Pointer(x.ref6e823638.band))
	x.Trailer = NewWriteTrailerFnRef(unsafe.Pointer(x.ref6e823638.trailer))
	packSOutput(x.Out, x.ref6e823638.out)
	x.W = (int32)(x.ref6e823638.w)
	x.H = (int32)(x.ref6e823638.h)
	x.N = (int32)(x.ref6e823638.n)
	x.S = (int32)(x.ref6e823638.s)
	x.Alpha = (int32)(x.ref6e823638.alpha)
	x.Xres = (int32)(x.ref6e823638.xres)
	x.Yres = (int32)(x.ref6e823638.yres)
	x.Pagenum = (int32)(x.ref6e823638.pagenum)
	x.Line = (int32)(x.ref6e823638.line)
	hxfd9261b := (*sliceHeader)(unsafe.Pointer(&x.Seps))
	hxfd9261b.Data = uintptr(unsafe.Pointer(x.ref6e823638.seps))
	hxfd9261b.Cap = 0x7fffffff
	// hxfd9261b.Len = ?

}

// packSBandWriter reads sliced Go data structure out from plain C format.
func packSBandWriter(v []BandWriter, ptr0 *C.fz_band_writer) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBandWriterValue]C.fz_band_writer)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBandWriterRef(unsafe.Pointer(&ptr1))
	}
}

func (x WriteHeaderFn) PassRef() (ref *C.fz_write_header_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if writeHeaderFn60D0D497Func == nil {
		writeHeaderFn60D0D497Func = x
	}
	return (*C.fz_write_header_fn)(C.fz_write_header_fn_60d0d497), nil
}

func NewWriteHeaderFnRef(ref unsafe.Pointer) *WriteHeaderFn {
	return (*WriteHeaderFn)(ref)
}

//export writeHeaderFn60D0D497
func writeHeaderFn60D0D497(cctx *C.fz_context, cwriter *C.fz_band_writer, ccs *C.fz_colorspace) {
	if writeHeaderFn60D0D497Func != nil {
		var ctx60d0d497 []Context
		packSContext(ctx60d0d497, cctx)
		var writer60d0d497 []BandWriter
		packSBandWriter(writer60d0d497, cwriter)
		var cs60d0d497 []Colorspace
		hxf77d2ac := (*sliceHeader)(unsafe.Pointer(&cs60d0d497))
		hxf77d2ac.Data = uintptr(unsafe.Pointer(ccs))
		hxf77d2ac.Cap = 0x7fffffff
		// hxf77d2ac.Len = ?

		writeHeaderFn60D0D497Func(ctx60d0d497, writer60d0d497, cs60d0d497)
		return
	}
	panic("callback func has not been set (race?)")
}

var writeHeaderFn60D0D497Func WriteHeaderFn

// packPUcharString creates a Go string backed by *C.uchar and avoids copying.
func packPUcharString(p *C.uchar) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = uintptr(unsafe.Pointer(p))
		for *p != 0 {
			p = (*C.uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - h.Data)
	}
	return
}

func (x WriteBandFn) PassRef() (ref *C.fz_write_band_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if writeBandFn64127B36Func == nil {
		writeBandFn64127B36Func = x
	}
	return (*C.fz_write_band_fn)(C.fz_write_band_fn_64127b36), nil
}

func NewWriteBandFnRef(ref unsafe.Pointer) *WriteBandFn {
	return (*WriteBandFn)(ref)
}

//export writeBandFn64127B36
func writeBandFn64127B36(cctx *C.fz_context, cwriter *C.fz_band_writer, cstride C.int, cbandStart C.int, cbandHeight C.int, csamples *C.uchar) {
	if writeBandFn64127B36Func != nil {
		var ctx64127b36 []Context
		packSContext(ctx64127b36, cctx)
		var writer64127b36 []BandWriter
		packSBandWriter(writer64127b36, cwriter)
		stride64127b36 := (int32)(cstride)
		bandStart64127b36 := (int32)(cbandStart)
		bandHeight64127b36 := (int32)(cbandHeight)
		samples64127b36 := packPUcharString(csamples)
		writeBandFn64127B36Func(ctx64127b36, writer64127b36, stride64127b36, bandStart64127b36, bandHeight64127b36, samples64127b36)
		return
	}
	panic("callback func has not been set (race?)")
}

var writeBandFn64127B36Func WriteBandFn

func (x WriteTrailerFn) PassRef() (ref *C.fz_write_trailer_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if writeTrailerFnC6136351Func == nil {
		writeTrailerFnC6136351Func = x
	}
	return (*C.fz_write_trailer_fn)(C.fz_write_trailer_fn_c6136351), nil
}

func NewWriteTrailerFnRef(ref unsafe.Pointer) *WriteTrailerFn {
	return (*WriteTrailerFn)(ref)
}

//export writeTrailerFnC6136351
func writeTrailerFnC6136351(cctx *C.fz_context, cwriter *C.fz_band_writer) {
	if writeTrailerFnC6136351Func != nil {
		var ctxc6136351 []Context
		packSContext(ctxc6136351, cctx)
		var writerc6136351 []BandWriter
		packSBandWriter(writerc6136351, cwriter)
		writeTrailerFnC6136351Func(ctxc6136351, writerc6136351)
		return
	}
	panic("callback func has not been set (race?)")
}

var writeTrailerFnC6136351Func WriteTrailerFn

func (x DropBandWriterFn) PassRef() (ref *C.fz_drop_band_writer_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if dropBandWriterFn6B3F033FFunc == nil {
		dropBandWriterFn6B3F033FFunc = x
	}
	return (*C.fz_drop_band_writer_fn)(C.fz_drop_band_writer_fn_6b3f033f), nil
}

func NewDropBandWriterFnRef(ref unsafe.Pointer) *DropBandWriterFn {
	return (*DropBandWriterFn)(ref)
}

//export dropBandWriterFn6B3F033F
func dropBandWriterFn6B3F033F(cctx *C.fz_context, cwriter *C.fz_band_writer) {
	if dropBandWriterFn6B3F033FFunc != nil {
		var ctx6b3f033f []Context
		packSContext(ctx6b3f033f, cctx)
		var writer6b3f033f []BandWriter
		packSBandWriter(writer6b3f033f, cwriter)
		dropBandWriterFn6B3F033FFunc(ctx6b3f033f, writer6b3f033f)
		return
	}
	panic("callback func has not been set (race?)")
}

var dropBandWriterFn6B3F033FFunc DropBandWriterFn

// allocPwgOptionsMemory allocates memory for type C.fz_pwg_options in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPwgOptionsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPwgOptionsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPwgOptionsValue = unsafe.Sizeof([1]C.fz_pwg_options{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PwgOptions) Ref() *C.fz_pwg_options {
	if x == nil {
		return nil
	}
	return x.ref780a866b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PwgOptions) Free() {
	if x != nil && x.allocs780a866b != nil {
		x.allocs780a866b.(*cgoAllocMap).Free()
		x.ref780a866b = nil
	}
}

// NewPwgOptionsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPwgOptionsRef(ref unsafe.Pointer) *PwgOptions {
	if ref == nil {
		return nil
	}
	obj := new(PwgOptions)
	obj.ref780a866b = (*C.fz_pwg_options)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PwgOptions) PassRef() (*C.fz_pwg_options, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref780a866b != nil {
		return x.ref780a866b, nil
	}
	mem780a866b := allocPwgOptionsMemory(1)
	ref780a866b := (*C.fz_pwg_options)(mem780a866b)
	allocs780a866b := new(cgoAllocMap)
	allocs780a866b.Add(mem780a866b)

	var cmedia_class_allocs *cgoAllocMap
	ref780a866b.media_class, cmedia_class_allocs = *(*[64]C.char)(unsafe.Pointer(&x.MediaClass)), cgoAllocsUnknown
	allocs780a866b.Borrow(cmedia_class_allocs)

	var cmedia_color_allocs *cgoAllocMap
	ref780a866b.media_color, cmedia_color_allocs = *(*[64]C.char)(unsafe.Pointer(&x.MediaColor)), cgoAllocsUnknown
	allocs780a866b.Borrow(cmedia_color_allocs)

	var cmedia_type_allocs *cgoAllocMap
	ref780a866b.media_type, cmedia_type_allocs = *(*[64]C.char)(unsafe.Pointer(&x.MediaType)), cgoAllocsUnknown
	allocs780a866b.Borrow(cmedia_type_allocs)

	var coutput_type_allocs *cgoAllocMap
	ref780a866b.output_type, coutput_type_allocs = *(*[64]C.char)(unsafe.Pointer(&x.OutputType)), cgoAllocsUnknown
	allocs780a866b.Borrow(coutput_type_allocs)

	var cadvance_distance_allocs *cgoAllocMap
	ref780a866b.advance_distance, cadvance_distance_allocs = (C.uint)(x.AdvanceDistance), cgoAllocsUnknown
	allocs780a866b.Borrow(cadvance_distance_allocs)

	var cadvance_media_allocs *cgoAllocMap
	ref780a866b.advance_media, cadvance_media_allocs = (C.int)(x.AdvanceMedia), cgoAllocsUnknown
	allocs780a866b.Borrow(cadvance_media_allocs)

	var ccollate_allocs *cgoAllocMap
	ref780a866b.collate, ccollate_allocs = (C.int)(x.Collate), cgoAllocsUnknown
	allocs780a866b.Borrow(ccollate_allocs)

	var ccut_media_allocs *cgoAllocMap
	ref780a866b.cut_media, ccut_media_allocs = (C.int)(x.CutMedia), cgoAllocsUnknown
	allocs780a866b.Borrow(ccut_media_allocs)

	var cduplex_allocs *cgoAllocMap
	ref780a866b.duplex, cduplex_allocs = (C.int)(x.Duplex), cgoAllocsUnknown
	allocs780a866b.Borrow(cduplex_allocs)

	var cinsert_sheet_allocs *cgoAllocMap
	ref780a866b.insert_sheet, cinsert_sheet_allocs = (C.int)(x.InsertSheet), cgoAllocsUnknown
	allocs780a866b.Borrow(cinsert_sheet_allocs)

	var cjog_allocs *cgoAllocMap
	ref780a866b.jog, cjog_allocs = (C.int)(x.Jog), cgoAllocsUnknown
	allocs780a866b.Borrow(cjog_allocs)

	var cleading_edge_allocs *cgoAllocMap
	ref780a866b.leading_edge, cleading_edge_allocs = (C.int)(x.LeadingEdge), cgoAllocsUnknown
	allocs780a866b.Borrow(cleading_edge_allocs)

	var cmanual_feed_allocs *cgoAllocMap
	ref780a866b.manual_feed, cmanual_feed_allocs = (C.int)(x.ManualFeed), cgoAllocsUnknown
	allocs780a866b.Borrow(cmanual_feed_allocs)

	var cmedia_position_allocs *cgoAllocMap
	ref780a866b.media_position, cmedia_position_allocs = (C.uint)(x.MediaPosition), cgoAllocsUnknown
	allocs780a866b.Borrow(cmedia_position_allocs)

	var cmedia_weight_allocs *cgoAllocMap
	ref780a866b.media_weight, cmedia_weight_allocs = (C.uint)(x.MediaWeight), cgoAllocsUnknown
	allocs780a866b.Borrow(cmedia_weight_allocs)

	var cmirror_print_allocs *cgoAllocMap
	ref780a866b.mirror_print, cmirror_print_allocs = (C.int)(x.MirrorPrint), cgoAllocsUnknown
	allocs780a866b.Borrow(cmirror_print_allocs)

	var cnegative_print_allocs *cgoAllocMap
	ref780a866b.negative_print, cnegative_print_allocs = (C.int)(x.NegativePrint), cgoAllocsUnknown
	allocs780a866b.Borrow(cnegative_print_allocs)

	var cnum_copies_allocs *cgoAllocMap
	ref780a866b.num_copies, cnum_copies_allocs = (C.uint)(x.NumCopies), cgoAllocsUnknown
	allocs780a866b.Borrow(cnum_copies_allocs)

	var corientation_allocs *cgoAllocMap
	ref780a866b.orientation, corientation_allocs = (C.int)(x.Orientation), cgoAllocsUnknown
	allocs780a866b.Borrow(corientation_allocs)

	var coutput_face_up_allocs *cgoAllocMap
	ref780a866b.output_face_up, coutput_face_up_allocs = (C.int)(x.OutputFaceUp), cgoAllocsUnknown
	allocs780a866b.Borrow(coutput_face_up_allocs)

	var cPageSize_allocs *cgoAllocMap
	ref780a866b.PageSize, cPageSize_allocs = *(*[2]C.uint)(unsafe.Pointer(&x.Pagesize)), cgoAllocsUnknown
	allocs780a866b.Borrow(cPageSize_allocs)

	var cseparations_allocs *cgoAllocMap
	ref780a866b.separations, cseparations_allocs = (C.int)(x.Separations), cgoAllocsUnknown
	allocs780a866b.Borrow(cseparations_allocs)

	var ctray_switch_allocs *cgoAllocMap
	ref780a866b.tray_switch, ctray_switch_allocs = (C.int)(x.TraySwitch), cgoAllocsUnknown
	allocs780a866b.Borrow(ctray_switch_allocs)

	var ctumble_allocs *cgoAllocMap
	ref780a866b.tumble, ctumble_allocs = (C.int)(x.Tumble), cgoAllocsUnknown
	allocs780a866b.Borrow(ctumble_allocs)

	var cmedia_type_num_allocs *cgoAllocMap
	ref780a866b.media_type_num, cmedia_type_num_allocs = (C.int)(x.MediaTypeNum), cgoAllocsUnknown
	allocs780a866b.Borrow(cmedia_type_num_allocs)

	var ccompression_allocs *cgoAllocMap
	ref780a866b.compression, ccompression_allocs = (C.int)(x.Compression), cgoAllocsUnknown
	allocs780a866b.Borrow(ccompression_allocs)

	var crow_count_allocs *cgoAllocMap
	ref780a866b.row_count, crow_count_allocs = (C.uint)(x.RowCount), cgoAllocsUnknown
	allocs780a866b.Borrow(crow_count_allocs)

	var crow_feed_allocs *cgoAllocMap
	ref780a866b.row_feed, crow_feed_allocs = (C.uint)(x.RowFeed), cgoAllocsUnknown
	allocs780a866b.Borrow(crow_feed_allocs)

	var crow_step_allocs *cgoAllocMap
	ref780a866b.row_step, crow_step_allocs = (C.uint)(x.RowStep), cgoAllocsUnknown
	allocs780a866b.Borrow(crow_step_allocs)

	var crendering_intent_allocs *cgoAllocMap
	ref780a866b.rendering_intent, crendering_intent_allocs = *(*[64]C.char)(unsafe.Pointer(&x.RenderingIntent)), cgoAllocsUnknown
	allocs780a866b.Borrow(crendering_intent_allocs)

	var cpage_size_name_allocs *cgoAllocMap
	ref780a866b.page_size_name, cpage_size_name_allocs = *(*[64]C.char)(unsafe.Pointer(&x.PageSizeName)), cgoAllocsUnknown
	allocs780a866b.Borrow(cpage_size_name_allocs)

	x.ref780a866b = ref780a866b
	x.allocs780a866b = allocs780a866b
	return ref780a866b, allocs780a866b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PwgOptions) PassValue() (C.fz_pwg_options, *cgoAllocMap) {
	if x.ref780a866b != nil {
		return *x.ref780a866b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PwgOptions) Deref() {
	if x.ref780a866b == nil {
		return
	}
	x.MediaClass = *(*[64]byte)(unsafe.Pointer(&x.ref780a866b.media_class))
	x.MediaColor = *(*[64]byte)(unsafe.Pointer(&x.ref780a866b.media_color))
	x.MediaType = *(*[64]byte)(unsafe.Pointer(&x.ref780a866b.media_type))
	x.OutputType = *(*[64]byte)(unsafe.Pointer(&x.ref780a866b.output_type))
	x.AdvanceDistance = (uint32)(x.ref780a866b.advance_distance)
	x.AdvanceMedia = (int32)(x.ref780a866b.advance_media)
	x.Collate = (int32)(x.ref780a866b.collate)
	x.CutMedia = (int32)(x.ref780a866b.cut_media)
	x.Duplex = (int32)(x.ref780a866b.duplex)
	x.InsertSheet = (int32)(x.ref780a866b.insert_sheet)
	x.Jog = (int32)(x.ref780a866b.jog)
	x.LeadingEdge = (int32)(x.ref780a866b.leading_edge)
	x.ManualFeed = (int32)(x.ref780a866b.manual_feed)
	x.MediaPosition = (uint32)(x.ref780a866b.media_position)
	x.MediaWeight = (uint32)(x.ref780a866b.media_weight)
	x.MirrorPrint = (int32)(x.ref780a866b.mirror_print)
	x.NegativePrint = (int32)(x.ref780a866b.negative_print)
	x.NumCopies = (uint32)(x.ref780a866b.num_copies)
	x.Orientation = (int32)(x.ref780a866b.orientation)
	x.OutputFaceUp = (int32)(x.ref780a866b.output_face_up)
	x.Pagesize = *(*[2]uint32)(unsafe.Pointer(&x.ref780a866b.PageSize))
	x.Separations = (int32)(x.ref780a866b.separations)
	x.TraySwitch = (int32)(x.ref780a866b.tray_switch)
	x.Tumble = (int32)(x.ref780a866b.tumble)
	x.MediaTypeNum = (int32)(x.ref780a866b.media_type_num)
	x.Compression = (int32)(x.ref780a866b.compression)
	x.RowCount = (uint32)(x.ref780a866b.row_count)
	x.RowFeed = (uint32)(x.ref780a866b.row_feed)
	x.RowStep = (uint32)(x.ref780a866b.row_step)
	x.RenderingIntent = *(*[64]byte)(unsafe.Pointer(&x.ref780a866b.rendering_intent))
	x.PageSizeName = *(*[64]byte)(unsafe.Pointer(&x.ref780a866b.page_size_name))
}

// allocPclOptionsMemory allocates memory for type C.fz_pcl_options in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPclOptionsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPclOptionsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPclOptionsValue = unsafe.Sizeof([1]C.fz_pcl_options{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PclOptions) Ref() *C.fz_pcl_options {
	if x == nil {
		return nil
	}
	return x.refd41a3924
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PclOptions) Free() {
	if x != nil && x.allocsd41a3924 != nil {
		x.allocsd41a3924.(*cgoAllocMap).Free()
		x.refd41a3924 = nil
	}
}

// NewPclOptionsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPclOptionsRef(ref unsafe.Pointer) *PclOptions {
	if ref == nil {
		return nil
	}
	obj := new(PclOptions)
	obj.refd41a3924 = (*C.fz_pcl_options)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PclOptions) PassRef() (*C.fz_pcl_options, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd41a3924 != nil {
		return x.refd41a3924, nil
	}
	memd41a3924 := allocPclOptionsMemory(1)
	refd41a3924 := (*C.fz_pcl_options)(memd41a3924)
	allocsd41a3924 := new(cgoAllocMap)
	allocsd41a3924.Add(memd41a3924)

	var cfeatures_allocs *cgoAllocMap
	refd41a3924.features, cfeatures_allocs = (C.int)(x.Features), cgoAllocsUnknown
	allocsd41a3924.Borrow(cfeatures_allocs)

	var codd_page_init_allocs *cgoAllocMap
	refd41a3924.odd_page_init, codd_page_init_allocs = unpackPCharString(x.OddPageInit)
	allocsd41a3924.Borrow(codd_page_init_allocs)

	var ceven_page_init_allocs *cgoAllocMap
	refd41a3924.even_page_init, ceven_page_init_allocs = unpackPCharString(x.EvenPageInit)
	allocsd41a3924.Borrow(ceven_page_init_allocs)

	var ctumble_allocs *cgoAllocMap
	refd41a3924.tumble, ctumble_allocs = (C.int)(x.Tumble), cgoAllocsUnknown
	allocsd41a3924.Borrow(ctumble_allocs)

	var cduplex_set_allocs *cgoAllocMap
	refd41a3924.duplex_set, cduplex_set_allocs = (C.int)(x.DuplexSet), cgoAllocsUnknown
	allocsd41a3924.Borrow(cduplex_set_allocs)

	var cduplex_allocs *cgoAllocMap
	refd41a3924.duplex, cduplex_allocs = (C.int)(x.Duplex), cgoAllocsUnknown
	allocsd41a3924.Borrow(cduplex_allocs)

	var cpaper_size_allocs *cgoAllocMap
	refd41a3924.paper_size, cpaper_size_allocs = (C.int)(x.PaperSize), cgoAllocsUnknown
	allocsd41a3924.Borrow(cpaper_size_allocs)

	var cmanual_feed_set_allocs *cgoAllocMap
	refd41a3924.manual_feed_set, cmanual_feed_set_allocs = (C.int)(x.ManualFeedSet), cgoAllocsUnknown
	allocsd41a3924.Borrow(cmanual_feed_set_allocs)

	var cmanual_feed_allocs *cgoAllocMap
	refd41a3924.manual_feed, cmanual_feed_allocs = (C.int)(x.ManualFeed), cgoAllocsUnknown
	allocsd41a3924.Borrow(cmanual_feed_allocs)

	var cmedia_position_set_allocs *cgoAllocMap
	refd41a3924.media_position_set, cmedia_position_set_allocs = (C.int)(x.MediaPositionSet), cgoAllocsUnknown
	allocsd41a3924.Borrow(cmedia_position_set_allocs)

	var cmedia_position_allocs *cgoAllocMap
	refd41a3924.media_position, cmedia_position_allocs = (C.int)(x.MediaPosition), cgoAllocsUnknown
	allocsd41a3924.Borrow(cmedia_position_allocs)

	var corientation_allocs *cgoAllocMap
	refd41a3924.orientation, corientation_allocs = (C.int)(x.Orientation), cgoAllocsUnknown
	allocsd41a3924.Borrow(corientation_allocs)

	var cpage_count_allocs *cgoAllocMap
	refd41a3924.page_count, cpage_count_allocs = (C.int)(x.PageCount), cgoAllocsUnknown
	allocsd41a3924.Borrow(cpage_count_allocs)

	x.refd41a3924 = refd41a3924
	x.allocsd41a3924 = allocsd41a3924
	return refd41a3924, allocsd41a3924

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PclOptions) PassValue() (C.fz_pcl_options, *cgoAllocMap) {
	if x.refd41a3924 != nil {
		return *x.refd41a3924, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PclOptions) Deref() {
	if x.refd41a3924 == nil {
		return
	}
	x.Features = (int32)(x.refd41a3924.features)
	x.OddPageInit = packPCharString(x.refd41a3924.odd_page_init)
	x.EvenPageInit = packPCharString(x.refd41a3924.even_page_init)
	x.Tumble = (int32)(x.refd41a3924.tumble)
	x.DuplexSet = (int32)(x.refd41a3924.duplex_set)
	x.Duplex = (int32)(x.refd41a3924.duplex)
	x.PaperSize = (int32)(x.refd41a3924.paper_size)
	x.ManualFeedSet = (int32)(x.refd41a3924.manual_feed_set)
	x.ManualFeed = (int32)(x.refd41a3924.manual_feed)
	x.MediaPositionSet = (int32)(x.refd41a3924.media_position_set)
	x.MediaPosition = (int32)(x.refd41a3924.media_position)
	x.Orientation = (int32)(x.refd41a3924.orientation)
	x.PageCount = (int32)(x.refd41a3924.page_count)
}

// allocXrefMemory allocates memory for type C.pdf_xref in C.
// The caller is responsible for freeing the this memory via C.free.
func allocXrefMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfXrefValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfXrefValue = unsafe.Sizeof([1]C.pdf_xref{})

// unpackSXref transforms a sliced Go data structure into plain C format.
func unpackSXref(x []Xref) (unpacked *C.pdf_xref, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_xref) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocXrefMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_xref)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_xref)(unsafe.Pointer(h.Data))
	return
}

// allocRevPageMapMemory allocates memory for type C.pdf_rev_page_map in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRevPageMapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRevPageMapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRevPageMapValue = unsafe.Sizeof([1]C.pdf_rev_page_map{})

// unpackSRevPageMap transforms a sliced Go data structure into plain C format.
func unpackSRevPageMap(x []RevPageMap) (unpacked *C.pdf_rev_page_map, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_rev_page_map) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRevPageMapMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_rev_page_map)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_rev_page_map)(unsafe.Pointer(h.Data))
	return
}

// allocPObjMemory allocates memory for type *C.pdf_obj in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPObjMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPObjValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPObjValue = unsafe.Sizeof([1]*C.pdf_obj{})

// unpackSSObj transforms a sliced Go data structure into plain C format.
func unpackSSObj(x [][]Obj) (unpacked **C.pdf_obj, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.pdf_obj) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPObjMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.pdf_obj)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.pdf_obj)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.pdf_obj)(unsafe.Pointer(h.Data))
	return
}

// unpackSAnnot transforms a sliced Go data structure into plain C format.
func unpackSAnnot(x []Annot) (unpacked *C.pdf_annot, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_annot) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocAnnotMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_annot)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_annot)(unsafe.Pointer(h.Data))
	return
}

// allocPFontMemory allocates memory for type *C.fz_font in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPFontMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPFontValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPFontValue = unsafe.Sizeof([1]*C.fz_font{})

// unpackSSFont transforms a sliced Go data structure into plain C format.
func unpackSSFont(x [][]Font) (unpacked **C.fz_font, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.fz_font) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPFontMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.fz_font)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.fz_font)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.fz_font)(unsafe.Pointer(h.Data))
	return
}

// packSXref reads sliced Go data structure out from plain C format.
func packSXref(v []Xref, ptr0 *C.pdf_xref) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfXrefValue]C.pdf_xref)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewXrefRef(unsafe.Pointer(&ptr1))
	}
}

// packSRevPageMap reads sliced Go data structure out from plain C format.
func packSRevPageMap(v []RevPageMap, ptr0 *C.pdf_rev_page_map) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRevPageMapValue]C.pdf_rev_page_map)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRevPageMapRef(unsafe.Pointer(&ptr1))
	}
}

// packSSObj reads sliced Go data structure out from plain C format.
func packSSObj(v [][]Obj, ptr0 **C.pdf_obj) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.pdf_obj)(unsafe.Pointer(ptr0)))[i0]
		hxfbb2d22 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfbb2d22.Data = uintptr(unsafe.Pointer(ptr1))
		hxfbb2d22.Cap = 0x7fffffff
		// hxfbb2d22.Len = ?
	}
}

// packSSFont reads sliced Go data structure out from plain C format.
func packSSFont(v [][]Font, ptr0 **C.fz_font) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.fz_font)(unsafe.Pointer(ptr0)))[i0]
		hxf32b611 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf32b611.Data = uintptr(unsafe.Pointer(ptr1))
		hxf32b611.Cap = 0x7fffffff
		// hxf32b611.Len = ?
	}
}

// Ref returns a reference to C object as it is.
func (x *Obj) Ref() *C.pdf_obj {
	if x == nil {
		return nil
	}
	return (*C.pdf_obj)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Obj) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewObjRef converts the C object reference into a raw struct reference without wrapping.
func NewObjRef(ref unsafe.Pointer) *Obj {
	return (*Obj)(ref)
}

// NewObj allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewObj() *Obj {
	return (*Obj)(allocObjMemory(1))
}

// allocObjMemory allocates memory for type C.pdf_obj in C.
// The caller is responsible for freeing the this memory via C.free.
func allocObjMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfObjValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfObjValue = unsafe.Sizeof([1]C.pdf_obj{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Obj) PassRef() *C.pdf_obj {
	if x == nil {
		x = (*Obj)(allocObjMemory(1))
	}
	return (*C.pdf_obj)(unsafe.Pointer(x))
}

// allocLexbufMemory allocates memory for type C.pdf_lexbuf in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLexbufMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLexbufValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfLexbufValue = unsafe.Sizeof([1]C.pdf_lexbuf{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Lexbuf) Ref() *C.pdf_lexbuf {
	if x == nil {
		return nil
	}
	return x.refeaf0e4db
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Lexbuf) Free() {
	if x != nil && x.allocseaf0e4db != nil {
		x.allocseaf0e4db.(*cgoAllocMap).Free()
		x.refeaf0e4db = nil
	}
}

// NewLexbufRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewLexbufRef(ref unsafe.Pointer) *Lexbuf {
	if ref == nil {
		return nil
	}
	obj := new(Lexbuf)
	obj.refeaf0e4db = (*C.pdf_lexbuf)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Lexbuf) PassRef() (*C.pdf_lexbuf, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeaf0e4db != nil {
		return x.refeaf0e4db, nil
	}
	memeaf0e4db := allocLexbufMemory(1)
	refeaf0e4db := (*C.pdf_lexbuf)(memeaf0e4db)
	allocseaf0e4db := new(cgoAllocMap)
	allocseaf0e4db.Add(memeaf0e4db)

	var csize_allocs *cgoAllocMap
	refeaf0e4db.size, csize_allocs = (C.int)(x.Size), cgoAllocsUnknown
	allocseaf0e4db.Borrow(csize_allocs)

	var cbase_size_allocs *cgoAllocMap
	refeaf0e4db.base_size, cbase_size_allocs = (C.int)(x.BaseSize), cgoAllocsUnknown
	allocseaf0e4db.Borrow(cbase_size_allocs)

	var clen_allocs *cgoAllocMap
	refeaf0e4db.len, clen_allocs = (C.int)(x.Len), cgoAllocsUnknown
	allocseaf0e4db.Borrow(clen_allocs)

	var ci_allocs *cgoAllocMap
	refeaf0e4db.i, ci_allocs = (C.fz_off_t)(x.I), cgoAllocsUnknown
	allocseaf0e4db.Borrow(ci_allocs)

	var cf_allocs *cgoAllocMap
	refeaf0e4db.f, cf_allocs = (C.float)(x.F), cgoAllocsUnknown
	allocseaf0e4db.Borrow(cf_allocs)

	var cscratch_allocs *cgoAllocMap
	refeaf0e4db.scratch, cscratch_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Scratch)).Data)), cgoAllocsUnknown
	allocseaf0e4db.Borrow(cscratch_allocs)

	var cbuffer_allocs *cgoAllocMap
	refeaf0e4db.buffer, cbuffer_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocseaf0e4db.Borrow(cbuffer_allocs)

	x.refeaf0e4db = refeaf0e4db
	x.allocseaf0e4db = allocseaf0e4db
	return refeaf0e4db, allocseaf0e4db

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Lexbuf) PassValue() (C.pdf_lexbuf, *cgoAllocMap) {
	if x.refeaf0e4db != nil {
		return *x.refeaf0e4db, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Lexbuf) Deref() {
	if x.refeaf0e4db == nil {
		return
	}
	x.Size = (int32)(x.refeaf0e4db.size)
	x.BaseSize = (int32)(x.refeaf0e4db.base_size)
	x.Len = (int32)(x.refeaf0e4db.len)
	x.I = (Off)(x.refeaf0e4db.i)
	x.F = (float32)(x.refeaf0e4db.f)
	hxf13e50a := (*sliceHeader)(unsafe.Pointer(&x.Scratch))
	hxf13e50a.Data = uintptr(unsafe.Pointer(x.refeaf0e4db.scratch))
	hxf13e50a.Cap = 0x7fffffff
	// hxf13e50a.Len = ?

	x.Buffer = *(*[256]byte)(unsafe.Pointer(&x.refeaf0e4db.buffer))
}

// allocLexbufLargeMemory allocates memory for type C.pdf_lexbuf_large in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLexbufLargeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLexbufLargeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfLexbufLargeValue = unsafe.Sizeof([1]C.pdf_lexbuf_large{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *LexbufLarge) Ref() *C.pdf_lexbuf_large {
	if x == nil {
		return nil
	}
	return x.ref54ed0b00
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *LexbufLarge) Free() {
	if x != nil && x.allocs54ed0b00 != nil {
		x.allocs54ed0b00.(*cgoAllocMap).Free()
		x.ref54ed0b00 = nil
	}
}

// NewLexbufLargeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewLexbufLargeRef(ref unsafe.Pointer) *LexbufLarge {
	if ref == nil {
		return nil
	}
	obj := new(LexbufLarge)
	obj.ref54ed0b00 = (*C.pdf_lexbuf_large)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *LexbufLarge) PassRef() (*C.pdf_lexbuf_large, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref54ed0b00 != nil {
		return x.ref54ed0b00, nil
	}
	mem54ed0b00 := allocLexbufLargeMemory(1)
	ref54ed0b00 := (*C.pdf_lexbuf_large)(mem54ed0b00)
	allocs54ed0b00 := new(cgoAllocMap)
	allocs54ed0b00.Add(mem54ed0b00)

	var cbase_allocs *cgoAllocMap
	ref54ed0b00.base, cbase_allocs = x.Base.PassValue()
	allocs54ed0b00.Borrow(cbase_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref54ed0b00.buffer, cbuffer_allocs = *(*[65280]C.char)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs54ed0b00.Borrow(cbuffer_allocs)

	x.ref54ed0b00 = ref54ed0b00
	x.allocs54ed0b00 = allocs54ed0b00
	return ref54ed0b00, allocs54ed0b00

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x LexbufLarge) PassValue() (C.pdf_lexbuf_large, *cgoAllocMap) {
	if x.ref54ed0b00 != nil {
		return *x.ref54ed0b00, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *LexbufLarge) Deref() {
	if x.ref54ed0b00 == nil {
		return
	}
	x.Base = *NewLexbufRef(unsafe.Pointer(&x.ref54ed0b00.base))
	x.Buffer = *(*[65280]byte)(unsafe.Pointer(&x.ref54ed0b00.buffer))
}

// allocXrefSubsecMemory allocates memory for type C.pdf_xref_subsec in C.
// The caller is responsible for freeing the this memory via C.free.
func allocXrefSubsecMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfXrefSubsecValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfXrefSubsecValue = unsafe.Sizeof([1]C.pdf_xref_subsec{})

// unpackSXrefSubsec transforms a sliced Go data structure into plain C format.
func unpackSXrefSubsec(x []XrefSubsec) (unpacked *C.pdf_xref_subsec, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_xref_subsec) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocXrefSubsecMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_xref_subsec)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_xref_subsec)(unsafe.Pointer(h.Data))
	return
}

// allocUnsavedSigMemory allocates memory for type C.pdf_unsaved_sig in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUnsavedSigMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUnsavedSigValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfUnsavedSigValue = unsafe.Sizeof([1]C.pdf_unsaved_sig{})

// unpackSUnsavedSig transforms a sliced Go data structure into plain C format.
func unpackSUnsavedSig(x []UnsavedSig) (unpacked *C.pdf_unsaved_sig, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_unsaved_sig) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocUnsavedSigMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_unsaved_sig)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_unsaved_sig)(unsafe.Pointer(h.Data))
	return
}

// allocPUnsavedSigMemory allocates memory for type *C.pdf_unsaved_sig in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPUnsavedSigMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPUnsavedSigValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPUnsavedSigValue = unsafe.Sizeof([1]*C.pdf_unsaved_sig{})

// unpackSSUnsavedSig transforms a sliced Go data structure into plain C format.
func unpackSSUnsavedSig(x [][]UnsavedSig) (unpacked **C.pdf_unsaved_sig, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.pdf_unsaved_sig) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPUnsavedSigMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.pdf_unsaved_sig)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocUnsavedSigMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: uintptr(mem1),
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.pdf_unsaved_sig)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.pdf_unsaved_sig)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.pdf_unsaved_sig)(unsafe.Pointer(h.Data))
	return
}

// packSXrefSubsec reads sliced Go data structure out from plain C format.
func packSXrefSubsec(v []XrefSubsec, ptr0 *C.pdf_xref_subsec) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfXrefSubsecValue]C.pdf_xref_subsec)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewXrefSubsecRef(unsafe.Pointer(&ptr1))
	}
}

// packSUnsavedSig reads sliced Go data structure out from plain C format.
func packSUnsavedSig(v []UnsavedSig, ptr0 *C.pdf_unsaved_sig) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfUnsavedSigValue]C.pdf_unsaved_sig)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewUnsavedSigRef(unsafe.Pointer(&ptr1))
	}
}

// packSSUnsavedSig reads sliced Go data structure out from plain C format.
func packSSUnsavedSig(v [][]UnsavedSig, ptr0 **C.pdf_unsaved_sig) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.pdf_unsaved_sig)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfUnsavedSigValue]C.pdf_unsaved_sig)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewUnsavedSigRef(unsafe.Pointer(&ptr2))
		}
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Xref) Ref() *C.pdf_xref {
	if x == nil {
		return nil
	}
	return x.ref97c0fd90
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Xref) Free() {
	if x != nil && x.allocs97c0fd90 != nil {
		x.allocs97c0fd90.(*cgoAllocMap).Free()
		x.ref97c0fd90 = nil
	}
}

// NewXrefRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewXrefRef(ref unsafe.Pointer) *Xref {
	if ref == nil {
		return nil
	}
	obj := new(Xref)
	obj.ref97c0fd90 = (*C.pdf_xref)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Xref) PassRef() (*C.pdf_xref, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref97c0fd90 != nil {
		return x.ref97c0fd90, nil
	}
	mem97c0fd90 := allocXrefMemory(1)
	ref97c0fd90 := (*C.pdf_xref)(mem97c0fd90)
	allocs97c0fd90 := new(cgoAllocMap)
	allocs97c0fd90.Add(mem97c0fd90)

	var cnum_objects_allocs *cgoAllocMap
	ref97c0fd90.num_objects, cnum_objects_allocs = (C.int)(x.NumObjects), cgoAllocsUnknown
	allocs97c0fd90.Borrow(cnum_objects_allocs)

	var csubsec_allocs *cgoAllocMap
	ref97c0fd90.subsec, csubsec_allocs = unpackSXrefSubsec(x.Subsec)
	allocs97c0fd90.Borrow(csubsec_allocs)

	var ctrailer_allocs *cgoAllocMap
	ref97c0fd90.trailer, ctrailer_allocs = (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Trailer)).Data)), cgoAllocsUnknown
	allocs97c0fd90.Borrow(ctrailer_allocs)

	var cpre_repair_trailer_allocs *cgoAllocMap
	ref97c0fd90.pre_repair_trailer, cpre_repair_trailer_allocs = (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.PreRepairTrailer)).Data)), cgoAllocsUnknown
	allocs97c0fd90.Borrow(cpre_repair_trailer_allocs)

	var cunsaved_sigs_allocs *cgoAllocMap
	ref97c0fd90.unsaved_sigs, cunsaved_sigs_allocs = unpackSUnsavedSig(x.UnsavedSigs)
	allocs97c0fd90.Borrow(cunsaved_sigs_allocs)

	var cunsaved_sigs_end_allocs *cgoAllocMap
	ref97c0fd90.unsaved_sigs_end, cunsaved_sigs_end_allocs = unpackSSUnsavedSig(x.UnsavedSigsEnd)
	allocs97c0fd90.Borrow(cunsaved_sigs_end_allocs)

	var cend_ofs_allocs *cgoAllocMap
	ref97c0fd90.end_ofs, cend_ofs_allocs = (C.fz_off_t)(x.EndOfs), cgoAllocsUnknown
	allocs97c0fd90.Borrow(cend_ofs_allocs)

	x.ref97c0fd90 = ref97c0fd90
	x.allocs97c0fd90 = allocs97c0fd90
	return ref97c0fd90, allocs97c0fd90

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Xref) PassValue() (C.pdf_xref, *cgoAllocMap) {
	if x.ref97c0fd90 != nil {
		return *x.ref97c0fd90, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Xref) Deref() {
	if x.ref97c0fd90 == nil {
		return
	}
	x.NumObjects = (int32)(x.ref97c0fd90.num_objects)
	packSXrefSubsec(x.Subsec, x.ref97c0fd90.subsec)
	hxf9227c2 := (*sliceHeader)(unsafe.Pointer(&x.Trailer))
	hxf9227c2.Data = uintptr(unsafe.Pointer(x.ref97c0fd90.trailer))
	hxf9227c2.Cap = 0x7fffffff
	// hxf9227c2.Len = ?

	hxfa7b2ab := (*sliceHeader)(unsafe.Pointer(&x.PreRepairTrailer))
	hxfa7b2ab.Data = uintptr(unsafe.Pointer(x.ref97c0fd90.pre_repair_trailer))
	hxfa7b2ab.Cap = 0x7fffffff
	// hxfa7b2ab.Len = ?

	packSUnsavedSig(x.UnsavedSigs, x.ref97c0fd90.unsaved_sigs)
	packSSUnsavedSig(x.UnsavedSigsEnd, x.ref97c0fd90.unsaved_sigs_end)
	x.EndOfs = (Off)(x.ref97c0fd90.end_ofs)
}

// Ref returns a reference to C object as it is.
func (x *Crypt) Ref() *C.pdf_crypt {
	if x == nil {
		return nil
	}
	return (*C.pdf_crypt)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Crypt) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCryptRef converts the C object reference into a raw struct reference without wrapping.
func NewCryptRef(ref unsafe.Pointer) *Crypt {
	return (*Crypt)(ref)
}

// NewCrypt allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCrypt() *Crypt {
	return (*Crypt)(allocCryptMemory(1))
}

// allocCryptMemory allocates memory for type C.pdf_crypt in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCryptMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCryptValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCryptValue = unsafe.Sizeof([1]C.pdf_crypt{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Crypt) PassRef() *C.pdf_crypt {
	if x == nil {
		x = (*Crypt)(allocCryptMemory(1))
	}
	return (*C.pdf_crypt)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *OcgDescriptor) Ref() *C.pdf_ocg_descriptor {
	if x == nil {
		return nil
	}
	return (*C.pdf_ocg_descriptor)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *OcgDescriptor) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewOcgDescriptorRef converts the C object reference into a raw struct reference without wrapping.
func NewOcgDescriptorRef(ref unsafe.Pointer) *OcgDescriptor {
	return (*OcgDescriptor)(ref)
}

// NewOcgDescriptor allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewOcgDescriptor() *OcgDescriptor {
	return (*OcgDescriptor)(allocOcgDescriptorMemory(1))
}

// allocOcgDescriptorMemory allocates memory for type C.pdf_ocg_descriptor in C.
// The caller is responsible for freeing the this memory via C.free.
func allocOcgDescriptorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfOcgDescriptorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfOcgDescriptorValue = unsafe.Sizeof([1]C.pdf_ocg_descriptor{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *OcgDescriptor) PassRef() *C.pdf_ocg_descriptor {
	if x == nil {
		x = (*OcgDescriptor)(allocOcgDescriptorMemory(1))
	}
	return (*C.pdf_ocg_descriptor)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Portfolio) Ref() *C.pdf_portfolio {
	if x == nil {
		return nil
	}
	return (*C.pdf_portfolio)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Portfolio) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPortfolioRef converts the C object reference into a raw struct reference without wrapping.
func NewPortfolioRef(ref unsafe.Pointer) *Portfolio {
	return (*Portfolio)(ref)
}

// NewPortfolio allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPortfolio() *Portfolio {
	return (*Portfolio)(allocPortfolioMemory(1))
}

// allocPortfolioMemory allocates memory for type C.pdf_portfolio in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPortfolioMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPortfolioValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPortfolioValue = unsafe.Sizeof([1]C.pdf_portfolio{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Portfolio) PassRef() *C.pdf_portfolio {
	if x == nil {
		x = (*Portfolio)(allocPortfolioMemory(1))
	}
	return (*C.pdf_portfolio)(unsafe.Pointer(x))
}

// unpackSDocument transforms a sliced Go data structure into plain C format.
func unpackSDocument(x []Document) (unpacked *C.pdf_document, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_document) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDocumentMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_document)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_document)(unsafe.Pointer(h.Data))
	return
}

// allocPAnnotMemory allocates memory for type *C.pdf_annot in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPAnnotMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPAnnotValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPAnnotValue = unsafe.Sizeof([1]*C.pdf_annot{})

// unpackSSAnnot transforms a sliced Go data structure into plain C format.
func unpackSSAnnot(x [][]Annot) (unpacked **C.pdf_annot, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.pdf_annot) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPAnnotMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.pdf_annot)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocAnnotMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: uintptr(mem1),
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.pdf_annot)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.pdf_annot)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.pdf_annot)(unsafe.Pointer(h.Data))
	return
}

// packSSAnnot reads sliced Go data structure out from plain C format.
func packSSAnnot(v [][]Annot, ptr0 **C.pdf_annot) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.pdf_annot)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfAnnotValue]C.pdf_annot)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewAnnotRef(unsafe.Pointer(&ptr2))
		}
	}
}

// unpackSPage transforms a sliced Go data structure into plain C format.
func unpackSPage(x []Page) (unpacked *C.pdf_page, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_page) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPageMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_page)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_page)(unsafe.Pointer(h.Data))
	return
}

// allocXobjectMemory allocates memory for type C.pdf_xobject in C.
// The caller is responsible for freeing the this memory via C.free.
func allocXobjectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfXobjectValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfXobjectValue = unsafe.Sizeof([1]C.pdf_xobject{})

// unpackSXobject transforms a sliced Go data structure into plain C format.
func unpackSXobject(x []Xobject) (unpacked *C.pdf_xobject, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_xobject) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocXobjectMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_xobject)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_xobject)(unsafe.Pointer(h.Data))
	return
}

// packSXobject reads sliced Go data structure out from plain C format.
func packSXobject(v []Xobject, ptr0 *C.pdf_xobject) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfXobjectValue]C.pdf_xobject)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewXobjectRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns a reference to C object as it is.
func (x *Widget) Ref() *C.pdf_widget {
	if x == nil {
		return nil
	}
	return (*C.pdf_widget)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Widget) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewWidgetRef converts the C object reference into a raw struct reference without wrapping.
func NewWidgetRef(ref unsafe.Pointer) *Widget {
	return (*Widget)(ref)
}

// NewWidget allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewWidget() *Widget {
	return (*Widget)(allocWidgetMemory(1))
}

// allocWidgetMemory allocates memory for type C.pdf_widget in C.
// The caller is responsible for freeing the this memory via C.free.
func allocWidgetMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfWidgetValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfWidgetValue = unsafe.Sizeof([1]C.pdf_widget{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Widget) PassRef() *C.pdf_widget {
	if x == nil {
		x = (*Widget)(allocWidgetMemory(1))
	}
	return (*C.pdf_widget)(unsafe.Pointer(x))
}

// allocHotspotMemory allocates memory for type C.pdf_hotspot in C.
// The caller is responsible for freeing the this memory via C.free.
func allocHotspotMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfHotspotValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfHotspotValue = unsafe.Sizeof([1]C.pdf_hotspot{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Hotspot) Ref() *C.pdf_hotspot {
	if x == nil {
		return nil
	}
	return x.ref3b09023c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Hotspot) Free() {
	if x != nil && x.allocs3b09023c != nil {
		x.allocs3b09023c.(*cgoAllocMap).Free()
		x.ref3b09023c = nil
	}
}

// NewHotspotRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewHotspotRef(ref unsafe.Pointer) *Hotspot {
	if ref == nil {
		return nil
	}
	obj := new(Hotspot)
	obj.ref3b09023c = (*C.pdf_hotspot)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Hotspot) PassRef() (*C.pdf_hotspot, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3b09023c != nil {
		return x.ref3b09023c, nil
	}
	mem3b09023c := allocHotspotMemory(1)
	ref3b09023c := (*C.pdf_hotspot)(mem3b09023c)
	allocs3b09023c := new(cgoAllocMap)
	allocs3b09023c.Add(mem3b09023c)

	var cnum_allocs *cgoAllocMap
	ref3b09023c.num, cnum_allocs = (C.int)(x.Num), cgoAllocsUnknown
	allocs3b09023c.Borrow(cnum_allocs)

	var cstate_allocs *cgoAllocMap
	ref3b09023c.state, cstate_allocs = (C.int)(x.State), cgoAllocsUnknown
	allocs3b09023c.Borrow(cstate_allocs)

	x.ref3b09023c = ref3b09023c
	x.allocs3b09023c = allocs3b09023c
	return ref3b09023c, allocs3b09023c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Hotspot) PassValue() (C.pdf_hotspot, *cgoAllocMap) {
	if x.ref3b09023c != nil {
		return *x.ref3b09023c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Hotspot) Deref() {
	if x.ref3b09023c == nil {
		return
	}
	x.Num = (int32)(x.ref3b09023c.num)
	x.State = (int32)(x.ref3b09023c.state)
}

// Ref returns a reference to C object as it is.
func (x *Js) Ref() *C.pdf_js {
	if x == nil {
		return nil
	}
	return (*C.pdf_js)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Js) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewJsRef converts the C object reference into a raw struct reference without wrapping.
func NewJsRef(ref unsafe.Pointer) *Js {
	return (*Js)(ref)
}

// NewJs allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewJs() *Js {
	return (*Js)(allocJsMemory(1))
}

// allocJsMemory allocates memory for type C.pdf_js in C.
// The caller is responsible for freeing the this memory via C.free.
func allocJsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfJsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfJsValue = unsafe.Sizeof([1]C.pdf_js{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Js) PassRef() *C.pdf_js {
	if x == nil {
		x = (*Js)(allocJsMemory(1))
	}
	return (*C.pdf_js)(unsafe.Pointer(x))
}

// allocDocEventMemory allocates memory for type C.pdf_doc_event in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDocEventMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDocEventValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDocEventValue = unsafe.Sizeof([1]C.pdf_doc_event{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DocEvent) Ref() *C.pdf_doc_event {
	if x == nil {
		return nil
	}
	return x.refdce49f90
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DocEvent) Free() {
	if x != nil && x.allocsdce49f90 != nil {
		x.allocsdce49f90.(*cgoAllocMap).Free()
		x.refdce49f90 = nil
	}
}

// NewDocEventRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDocEventRef(ref unsafe.Pointer) *DocEvent {
	if ref == nil {
		return nil
	}
	obj := new(DocEvent)
	obj.refdce49f90 = (*C.pdf_doc_event)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DocEvent) PassRef() (*C.pdf_doc_event, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdce49f90 != nil {
		return x.refdce49f90, nil
	}
	memdce49f90 := allocDocEventMemory(1)
	refdce49f90 := (*C.pdf_doc_event)(memdce49f90)
	allocsdce49f90 := new(cgoAllocMap)
	allocsdce49f90.Add(memdce49f90)

	var c_type_allocs *cgoAllocMap
	refdce49f90._type, c_type_allocs = (C.int)(x.Type), cgoAllocsUnknown
	allocsdce49f90.Borrow(c_type_allocs)

	x.refdce49f90 = refdce49f90
	x.allocsdce49f90 = allocsdce49f90
	return refdce49f90, allocsdce49f90

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DocEvent) PassValue() (C.pdf_doc_event, *cgoAllocMap) {
	if x.refdce49f90 != nil {
		return *x.refdce49f90, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DocEvent) Deref() {
	if x.refdce49f90 == nil {
		return
	}
	x.Type = (int32)(x.refdce49f90._type)
}

// packSDocEvent reads sliced Go data structure out from plain C format.
func packSDocEvent(v []DocEvent, ptr0 *C.pdf_doc_event) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDocEventValue]C.pdf_doc_event)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDocEventRef(unsafe.Pointer(&ptr1))
	}
}

func (x DocEventCb) PassRef() (ref *C.pdf_doc_event_cb, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if docEventCbD9608017Func == nil {
		docEventCbD9608017Func = x
	}
	return (*C.pdf_doc_event_cb)(C.pdf_doc_event_cb_d9608017), nil
}

func NewDocEventCbRef(ref unsafe.Pointer) *DocEventCb {
	return (*DocEventCb)(ref)
}

//export docEventCbD9608017
func docEventCbD9608017(cctx *C.fz_context, cdoc *C.pdf_document, cevent *C.pdf_doc_event, cdata unsafe.Pointer) {
	if docEventCbD9608017Func != nil {
		var ctxd9608017 []Context
		packSContext(ctxd9608017, cctx)
		var docd9608017 []Document
		packSDocument(docd9608017, cdoc)
		var eventd9608017 []DocEvent
		packSDocEvent(eventd9608017, cevent)
		datad9608017 := (unsafe.Pointer)(unsafe.Pointer(cdata))
		docEventCbD9608017Func(ctxd9608017, docd9608017, eventd9608017, datad9608017)
		return
	}
	panic("callback func has not been set (race?)")
}

var docEventCbD9608017Func DocEventCb

// allocLayerConfigMemory allocates memory for type C.pdf_layer_config in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLayerConfigMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLayerConfigValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfLayerConfigValue = unsafe.Sizeof([1]C.pdf_layer_config{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *LayerConfig) Ref() *C.pdf_layer_config {
	if x == nil {
		return nil
	}
	return x.ref5f707db3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *LayerConfig) Free() {
	if x != nil && x.allocs5f707db3 != nil {
		x.allocs5f707db3.(*cgoAllocMap).Free()
		x.ref5f707db3 = nil
	}
}

// NewLayerConfigRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewLayerConfigRef(ref unsafe.Pointer) *LayerConfig {
	if ref == nil {
		return nil
	}
	obj := new(LayerConfig)
	obj.ref5f707db3 = (*C.pdf_layer_config)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *LayerConfig) PassRef() (*C.pdf_layer_config, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5f707db3 != nil {
		return x.ref5f707db3, nil
	}
	mem5f707db3 := allocLayerConfigMemory(1)
	ref5f707db3 := (*C.pdf_layer_config)(mem5f707db3)
	allocs5f707db3 := new(cgoAllocMap)
	allocs5f707db3.Add(mem5f707db3)

	var cname_allocs *cgoAllocMap
	ref5f707db3.name, cname_allocs = unpackPCharString(x.Name)
	allocs5f707db3.Borrow(cname_allocs)

	var ccreator_allocs *cgoAllocMap
	ref5f707db3.creator, ccreator_allocs = unpackPCharString(x.Creator)
	allocs5f707db3.Borrow(ccreator_allocs)

	x.ref5f707db3 = ref5f707db3
	x.allocs5f707db3 = allocs5f707db3
	return ref5f707db3, allocs5f707db3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x LayerConfig) PassValue() (C.pdf_layer_config, *cgoAllocMap) {
	if x.ref5f707db3 != nil {
		return *x.ref5f707db3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *LayerConfig) Deref() {
	if x.ref5f707db3 == nil {
		return
	}
	x.Name = packPCharString(x.ref5f707db3.name)
	x.Creator = packPCharString(x.ref5f707db3.creator)
}

// allocLayerConfigUiMemory allocates memory for type C.pdf_layer_config_ui in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLayerConfigUiMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLayerConfigUiValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfLayerConfigUiValue = unsafe.Sizeof([1]C.pdf_layer_config_ui{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *LayerConfigUi) Ref() *C.pdf_layer_config_ui {
	if x == nil {
		return nil
	}
	return x.reff30bd241
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *LayerConfigUi) Free() {
	if x != nil && x.allocsf30bd241 != nil {
		x.allocsf30bd241.(*cgoAllocMap).Free()
		x.reff30bd241 = nil
	}
}

// NewLayerConfigUiRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewLayerConfigUiRef(ref unsafe.Pointer) *LayerConfigUi {
	if ref == nil {
		return nil
	}
	obj := new(LayerConfigUi)
	obj.reff30bd241 = (*C.pdf_layer_config_ui)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *LayerConfigUi) PassRef() (*C.pdf_layer_config_ui, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff30bd241 != nil {
		return x.reff30bd241, nil
	}
	memf30bd241 := allocLayerConfigUiMemory(1)
	reff30bd241 := (*C.pdf_layer_config_ui)(memf30bd241)
	allocsf30bd241 := new(cgoAllocMap)
	allocsf30bd241.Add(memf30bd241)

	var ctext_allocs *cgoAllocMap
	reff30bd241.text, ctext_allocs = unpackPCharString(x.Text)
	allocsf30bd241.Borrow(ctext_allocs)

	var cdepth_allocs *cgoAllocMap
	reff30bd241.depth, cdepth_allocs = (C.int)(x.Depth), cgoAllocsUnknown
	allocsf30bd241.Borrow(cdepth_allocs)

	var c_type_allocs *cgoAllocMap
	reff30bd241._type, c_type_allocs = (C.pdf_layer_config_ui_type)(x.Type), cgoAllocsUnknown
	allocsf30bd241.Borrow(c_type_allocs)

	var cselected_allocs *cgoAllocMap
	reff30bd241.selected, cselected_allocs = (C.int)(x.Selected), cgoAllocsUnknown
	allocsf30bd241.Borrow(cselected_allocs)

	var clocked_allocs *cgoAllocMap
	reff30bd241.locked, clocked_allocs = (C.int)(x.Locked), cgoAllocsUnknown
	allocsf30bd241.Borrow(clocked_allocs)

	x.reff30bd241 = reff30bd241
	x.allocsf30bd241 = allocsf30bd241
	return reff30bd241, allocsf30bd241

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x LayerConfigUi) PassValue() (C.pdf_layer_config_ui, *cgoAllocMap) {
	if x.reff30bd241 != nil {
		return *x.reff30bd241, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *LayerConfigUi) Deref() {
	if x.reff30bd241 == nil {
		return
	}
	x.Text = packPCharString(x.reff30bd241.text)
	x.Depth = (int32)(x.reff30bd241.depth)
	x.Type = (LayerConfigUiType)(x.reff30bd241._type)
	x.Selected = (int32)(x.reff30bd241.selected)
	x.Locked = (int32)(x.reff30bd241.locked)
}

// allocPortfolioSchemaMemory allocates memory for type C.pdf_portfolio_schema in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPortfolioSchemaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPortfolioSchemaValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPortfolioSchemaValue = unsafe.Sizeof([1]C.pdf_portfolio_schema{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PortfolioSchema) Ref() *C.pdf_portfolio_schema {
	if x == nil {
		return nil
	}
	return x.ref750f0bd0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PortfolioSchema) Free() {
	if x != nil && x.allocs750f0bd0 != nil {
		x.allocs750f0bd0.(*cgoAllocMap).Free()
		x.ref750f0bd0 = nil
	}
}

// NewPortfolioSchemaRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPortfolioSchemaRef(ref unsafe.Pointer) *PortfolioSchema {
	if ref == nil {
		return nil
	}
	obj := new(PortfolioSchema)
	obj.ref750f0bd0 = (*C.pdf_portfolio_schema)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PortfolioSchema) PassRef() (*C.pdf_portfolio_schema, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref750f0bd0 != nil {
		return x.ref750f0bd0, nil
	}
	mem750f0bd0 := allocPortfolioSchemaMemory(1)
	ref750f0bd0 := (*C.pdf_portfolio_schema)(mem750f0bd0)
	allocs750f0bd0 := new(cgoAllocMap)
	allocs750f0bd0.Add(mem750f0bd0)

	var c_type_allocs *cgoAllocMap
	ref750f0bd0._type, c_type_allocs = (C.pdf_portfolio_schema_type)(x.Type), cgoAllocsUnknown
	allocs750f0bd0.Borrow(c_type_allocs)

	var cvisible_allocs *cgoAllocMap
	ref750f0bd0.visible, cvisible_allocs = (C.int)(x.Visible), cgoAllocsUnknown
	allocs750f0bd0.Borrow(cvisible_allocs)

	var ceditable_allocs *cgoAllocMap
	ref750f0bd0.editable, ceditable_allocs = (C.int)(x.Editable), cgoAllocsUnknown
	allocs750f0bd0.Borrow(ceditable_allocs)

	var cname_allocs *cgoAllocMap
	ref750f0bd0.name, cname_allocs = (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Name)).Data)), cgoAllocsUnknown
	allocs750f0bd0.Borrow(cname_allocs)

	x.ref750f0bd0 = ref750f0bd0
	x.allocs750f0bd0 = allocs750f0bd0
	return ref750f0bd0, allocs750f0bd0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PortfolioSchema) PassValue() (C.pdf_portfolio_schema, *cgoAllocMap) {
	if x.ref750f0bd0 != nil {
		return *x.ref750f0bd0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PortfolioSchema) Deref() {
	if x.ref750f0bd0 == nil {
		return
	}
	x.Type = (PortfolioSchemaType)(x.ref750f0bd0._type)
	x.Visible = (int32)(x.ref750f0bd0.visible)
	x.Editable = (int32)(x.ref750f0bd0.editable)
	hxfe8267c := (*sliceHeader)(unsafe.Pointer(&x.Name))
	hxfe8267c.Data = uintptr(unsafe.Pointer(x.ref750f0bd0.name))
	hxfe8267c.Cap = 0x7fffffff
	// hxfe8267c.Len = ?

}

// Ref returns a reference to C object as it is.
func (x *Signer) Ref() *C.pdf_signer {
	if x == nil {
		return nil
	}
	return (*C.pdf_signer)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Signer) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewSignerRef converts the C object reference into a raw struct reference without wrapping.
func NewSignerRef(ref unsafe.Pointer) *Signer {
	return (*Signer)(ref)
}

// NewSigner allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewSigner() *Signer {
	return (*Signer)(allocSignerMemory(1))
}

// allocSignerMemory allocates memory for type C.pdf_signer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSignerMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSignerValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSignerValue = unsafe.Sizeof([1]C.pdf_signer{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Signer) PassRef() *C.pdf_signer {
	if x == nil {
		x = (*Signer)(allocSignerMemory(1))
	}
	return (*C.pdf_signer)(unsafe.Pointer(x))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *UnsavedSig) Ref() *C.pdf_unsaved_sig {
	if x == nil {
		return nil
	}
	return x.ref2830cb5d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *UnsavedSig) Free() {
	if x != nil && x.allocs2830cb5d != nil {
		x.allocs2830cb5d.(*cgoAllocMap).Free()
		x.ref2830cb5d = nil
	}
}

// NewUnsavedSigRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUnsavedSigRef(ref unsafe.Pointer) *UnsavedSig {
	if ref == nil {
		return nil
	}
	obj := new(UnsavedSig)
	obj.ref2830cb5d = (*C.pdf_unsaved_sig)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *UnsavedSig) PassRef() (*C.pdf_unsaved_sig, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2830cb5d != nil {
		return x.ref2830cb5d, nil
	}
	mem2830cb5d := allocUnsavedSigMemory(1)
	ref2830cb5d := (*C.pdf_unsaved_sig)(mem2830cb5d)
	allocs2830cb5d := new(cgoAllocMap)
	allocs2830cb5d.Add(mem2830cb5d)

	var cfield_allocs *cgoAllocMap
	ref2830cb5d.field, cfield_allocs = (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Field)).Data)), cgoAllocsUnknown
	allocs2830cb5d.Borrow(cfield_allocs)

	var cbyte_range_start_allocs *cgoAllocMap
	ref2830cb5d.byte_range_start, cbyte_range_start_allocs = (C.int)(x.ByteRangeStart), cgoAllocsUnknown
	allocs2830cb5d.Borrow(cbyte_range_start_allocs)

	var cbyte_range_end_allocs *cgoAllocMap
	ref2830cb5d.byte_range_end, cbyte_range_end_allocs = (C.int)(x.ByteRangeEnd), cgoAllocsUnknown
	allocs2830cb5d.Borrow(cbyte_range_end_allocs)

	var ccontents_start_allocs *cgoAllocMap
	ref2830cb5d.contents_start, ccontents_start_allocs = (C.int)(x.ContentsStart), cgoAllocsUnknown
	allocs2830cb5d.Borrow(ccontents_start_allocs)

	var ccontents_end_allocs *cgoAllocMap
	ref2830cb5d.contents_end, ccontents_end_allocs = (C.int)(x.ContentsEnd), cgoAllocsUnknown
	allocs2830cb5d.Borrow(ccontents_end_allocs)

	var csigner_allocs *cgoAllocMap
	ref2830cb5d.signer, csigner_allocs = (*C.pdf_signer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Signer)).Data)), cgoAllocsUnknown
	allocs2830cb5d.Borrow(csigner_allocs)

	var cnext_allocs *cgoAllocMap
	ref2830cb5d.next, cnext_allocs = unpackSUnsavedSig(x.Next)
	allocs2830cb5d.Borrow(cnext_allocs)

	x.ref2830cb5d = ref2830cb5d
	x.allocs2830cb5d = allocs2830cb5d
	return ref2830cb5d, allocs2830cb5d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x UnsavedSig) PassValue() (C.pdf_unsaved_sig, *cgoAllocMap) {
	if x.ref2830cb5d != nil {
		return *x.ref2830cb5d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *UnsavedSig) Deref() {
	if x.ref2830cb5d == nil {
		return
	}
	hxf9143ee := (*sliceHeader)(unsafe.Pointer(&x.Field))
	hxf9143ee.Data = uintptr(unsafe.Pointer(x.ref2830cb5d.field))
	hxf9143ee.Cap = 0x7fffffff
	// hxf9143ee.Len = ?

	x.ByteRangeStart = (int32)(x.ref2830cb5d.byte_range_start)
	x.ByteRangeEnd = (int32)(x.ref2830cb5d.byte_range_end)
	x.ContentsStart = (int32)(x.ref2830cb5d.contents_start)
	x.ContentsEnd = (int32)(x.ref2830cb5d.contents_end)
	hxf27a8c5 := (*sliceHeader)(unsafe.Pointer(&x.Signer))
	hxf27a8c5.Data = uintptr(unsafe.Pointer(x.ref2830cb5d.signer))
	hxf27a8c5.Cap = 0x7fffffff
	// hxf27a8c5.Len = ?

	packSUnsavedSig(x.Next, x.ref2830cb5d.next)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RevPageMap) Ref() *C.pdf_rev_page_map {
	if x == nil {
		return nil
	}
	return x.ref2404dd3d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RevPageMap) Free() {
	if x != nil && x.allocs2404dd3d != nil {
		x.allocs2404dd3d.(*cgoAllocMap).Free()
		x.ref2404dd3d = nil
	}
}

// NewRevPageMapRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRevPageMapRef(ref unsafe.Pointer) *RevPageMap {
	if ref == nil {
		return nil
	}
	obj := new(RevPageMap)
	obj.ref2404dd3d = (*C.pdf_rev_page_map)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RevPageMap) PassRef() (*C.pdf_rev_page_map, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2404dd3d != nil {
		return x.ref2404dd3d, nil
	}
	mem2404dd3d := allocRevPageMapMemory(1)
	ref2404dd3d := (*C.pdf_rev_page_map)(mem2404dd3d)
	allocs2404dd3d := new(cgoAllocMap)
	allocs2404dd3d.Add(mem2404dd3d)

	var cpage_allocs *cgoAllocMap
	ref2404dd3d.page, cpage_allocs = (C.int)(x.Page), cgoAllocsUnknown
	allocs2404dd3d.Borrow(cpage_allocs)

	var cobject_allocs *cgoAllocMap
	ref2404dd3d.object, cobject_allocs = (C.int)(x.Object), cgoAllocsUnknown
	allocs2404dd3d.Borrow(cobject_allocs)

	x.ref2404dd3d = ref2404dd3d
	x.allocs2404dd3d = allocs2404dd3d
	return ref2404dd3d, allocs2404dd3d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RevPageMap) PassValue() (C.pdf_rev_page_map, *cgoAllocMap) {
	if x.ref2404dd3d != nil {
		return *x.ref2404dd3d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RevPageMap) Deref() {
	if x.ref2404dd3d == nil {
		return
	}
	x.Page = (int32)(x.ref2404dd3d.page)
	x.Object = (int32)(x.ref2404dd3d.object)
}

// Ref returns a reference to C object as it is.
func (x *GraftMap) Ref() *C.pdf_graft_map {
	if x == nil {
		return nil
	}
	return (*C.pdf_graft_map)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *GraftMap) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewGraftMapRef converts the C object reference into a raw struct reference without wrapping.
func NewGraftMapRef(ref unsafe.Pointer) *GraftMap {
	return (*GraftMap)(ref)
}

// NewGraftMap allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewGraftMap() *GraftMap {
	return (*GraftMap)(allocGraftMapMemory(1))
}

// allocGraftMapMemory allocates memory for type C.pdf_graft_map in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGraftMapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGraftMapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfGraftMapValue = unsafe.Sizeof([1]C.pdf_graft_map{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *GraftMap) PassRef() *C.pdf_graft_map {
	if x == nil {
		x = (*GraftMap)(allocGraftMapMemory(1))
	}
	return (*C.pdf_graft_map)(unsafe.Pointer(x))
}

// allocWriteOptionsMemory allocates memory for type C.pdf_write_options in C.
// The caller is responsible for freeing the this memory via C.free.
func allocWriteOptionsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfWriteOptionsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfWriteOptionsValue = unsafe.Sizeof([1]C.pdf_write_options{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *WriteOptions) Ref() *C.pdf_write_options {
	if x == nil {
		return nil
	}
	return x.ref5d16f824
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *WriteOptions) Free() {
	if x != nil && x.allocs5d16f824 != nil {
		x.allocs5d16f824.(*cgoAllocMap).Free()
		x.ref5d16f824 = nil
	}
}

// NewWriteOptionsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewWriteOptionsRef(ref unsafe.Pointer) *WriteOptions {
	if ref == nil {
		return nil
	}
	obj := new(WriteOptions)
	obj.ref5d16f824 = (*C.pdf_write_options)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *WriteOptions) PassRef() (*C.pdf_write_options, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5d16f824 != nil {
		return x.ref5d16f824, nil
	}
	mem5d16f824 := allocWriteOptionsMemory(1)
	ref5d16f824 := (*C.pdf_write_options)(mem5d16f824)
	allocs5d16f824 := new(cgoAllocMap)
	allocs5d16f824.Add(mem5d16f824)

	var cdo_incremental_allocs *cgoAllocMap
	ref5d16f824.do_incremental, cdo_incremental_allocs = (C.int)(x.DoIncremental), cgoAllocsUnknown
	allocs5d16f824.Borrow(cdo_incremental_allocs)

	var cdo_pretty_allocs *cgoAllocMap
	ref5d16f824.do_pretty, cdo_pretty_allocs = (C.int)(x.DoPretty), cgoAllocsUnknown
	allocs5d16f824.Borrow(cdo_pretty_allocs)

	var cdo_ascii_allocs *cgoAllocMap
	ref5d16f824.do_ascii, cdo_ascii_allocs = (C.int)(x.DoAscii), cgoAllocsUnknown
	allocs5d16f824.Borrow(cdo_ascii_allocs)

	var cdo_compress_allocs *cgoAllocMap
	ref5d16f824.do_compress, cdo_compress_allocs = (C.int)(x.DoCompress), cgoAllocsUnknown
	allocs5d16f824.Borrow(cdo_compress_allocs)

	var cdo_compress_images_allocs *cgoAllocMap
	ref5d16f824.do_compress_images, cdo_compress_images_allocs = (C.int)(x.DoCompressImages), cgoAllocsUnknown
	allocs5d16f824.Borrow(cdo_compress_images_allocs)

	var cdo_compress_fonts_allocs *cgoAllocMap
	ref5d16f824.do_compress_fonts, cdo_compress_fonts_allocs = (C.int)(x.DoCompressFonts), cgoAllocsUnknown
	allocs5d16f824.Borrow(cdo_compress_fonts_allocs)

	var cdo_decompress_allocs *cgoAllocMap
	ref5d16f824.do_decompress, cdo_decompress_allocs = (C.int)(x.DoDecompress), cgoAllocsUnknown
	allocs5d16f824.Borrow(cdo_decompress_allocs)

	var cdo_garbage_allocs *cgoAllocMap
	ref5d16f824.do_garbage, cdo_garbage_allocs = (C.int)(x.DoGarbage), cgoAllocsUnknown
	allocs5d16f824.Borrow(cdo_garbage_allocs)

	var cdo_linear_allocs *cgoAllocMap
	ref5d16f824.do_linear, cdo_linear_allocs = (C.int)(x.DoLinear), cgoAllocsUnknown
	allocs5d16f824.Borrow(cdo_linear_allocs)

	var cdo_clean_allocs *cgoAllocMap
	ref5d16f824.do_clean, cdo_clean_allocs = (C.int)(x.DoClean), cgoAllocsUnknown
	allocs5d16f824.Borrow(cdo_clean_allocs)

	var ccontinue_on_error_allocs *cgoAllocMap
	ref5d16f824.continue_on_error, ccontinue_on_error_allocs = (C.int)(x.ContinueOnError), cgoAllocsUnknown
	allocs5d16f824.Borrow(ccontinue_on_error_allocs)

	var cerrors_allocs *cgoAllocMap
	ref5d16f824.errors, cerrors_allocs = (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Errors)).Data)), cgoAllocsUnknown
	allocs5d16f824.Borrow(cerrors_allocs)

	x.ref5d16f824 = ref5d16f824
	x.allocs5d16f824 = allocs5d16f824
	return ref5d16f824, allocs5d16f824

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x WriteOptions) PassValue() (C.pdf_write_options, *cgoAllocMap) {
	if x.ref5d16f824 != nil {
		return *x.ref5d16f824, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *WriteOptions) Deref() {
	if x.ref5d16f824 == nil {
		return
	}
	x.DoIncremental = (int32)(x.ref5d16f824.do_incremental)
	x.DoPretty = (int32)(x.ref5d16f824.do_pretty)
	x.DoAscii = (int32)(x.ref5d16f824.do_ascii)
	x.DoCompress = (int32)(x.ref5d16f824.do_compress)
	x.DoCompressImages = (int32)(x.ref5d16f824.do_compress_images)
	x.DoCompressFonts = (int32)(x.ref5d16f824.do_compress_fonts)
	x.DoDecompress = (int32)(x.ref5d16f824.do_decompress)
	x.DoGarbage = (int32)(x.ref5d16f824.do_garbage)
	x.DoLinear = (int32)(x.ref5d16f824.do_linear)
	x.DoClean = (int32)(x.ref5d16f824.do_clean)
	x.ContinueOnError = (int32)(x.ref5d16f824.continue_on_error)
	hxf349858 := (*sliceHeader)(unsafe.Pointer(&x.Errors))
	hxf349858.Data = uintptr(unsafe.Pointer(x.ref5d16f824.errors))
	hxf349858.Cap = 0x7fffffff
	// hxf349858.Len = ?

}

// allocXrefEntryMemory allocates memory for type C.pdf_xref_entry in C.
// The caller is responsible for freeing the this memory via C.free.
func allocXrefEntryMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfXrefEntryValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfXrefEntryValue = unsafe.Sizeof([1]C.pdf_xref_entry{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *XrefEntry) Ref() *C.pdf_xref_entry {
	if x == nil {
		return nil
	}
	return x.ref82cab330
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *XrefEntry) Free() {
	if x != nil && x.allocs82cab330 != nil {
		x.allocs82cab330.(*cgoAllocMap).Free()
		x.ref82cab330 = nil
	}
}

// NewXrefEntryRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewXrefEntryRef(ref unsafe.Pointer) *XrefEntry {
	if ref == nil {
		return nil
	}
	obj := new(XrefEntry)
	obj.ref82cab330 = (*C.pdf_xref_entry)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *XrefEntry) PassRef() (*C.pdf_xref_entry, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref82cab330 != nil {
		return x.ref82cab330, nil
	}
	mem82cab330 := allocXrefEntryMemory(1)
	ref82cab330 := (*C.pdf_xref_entry)(mem82cab330)
	allocs82cab330 := new(cgoAllocMap)
	allocs82cab330.Add(mem82cab330)

	var c_type_allocs *cgoAllocMap
	ref82cab330._type, c_type_allocs = (C.char)(x.Type), cgoAllocsUnknown
	allocs82cab330.Borrow(c_type_allocs)

	var cflags_allocs *cgoAllocMap
	ref82cab330.flags, cflags_allocs = (C.uchar)(x.Flags), cgoAllocsUnknown
	allocs82cab330.Borrow(cflags_allocs)

	var cgen_allocs *cgoAllocMap
	ref82cab330.gen, cgen_allocs = (C.ushort)(x.Gen), cgoAllocsUnknown
	allocs82cab330.Borrow(cgen_allocs)

	var cnum_allocs *cgoAllocMap
	ref82cab330.num, cnum_allocs = (C.int)(x.Num), cgoAllocsUnknown
	allocs82cab330.Borrow(cnum_allocs)

	var cofs_allocs *cgoAllocMap
	ref82cab330.ofs, cofs_allocs = (C.fz_off_t)(x.Ofs), cgoAllocsUnknown
	allocs82cab330.Borrow(cofs_allocs)

	var cstm_ofs_allocs *cgoAllocMap
	ref82cab330.stm_ofs, cstm_ofs_allocs = (C.fz_off_t)(x.StmOfs), cgoAllocsUnknown
	allocs82cab330.Borrow(cstm_ofs_allocs)

	var cstm_buf_allocs *cgoAllocMap
	ref82cab330.stm_buf, cstm_buf_allocs = (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.StmBuf)).Data)), cgoAllocsUnknown
	allocs82cab330.Borrow(cstm_buf_allocs)

	var cobj_allocs *cgoAllocMap
	ref82cab330.obj, cobj_allocs = (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Obj)).Data)), cgoAllocsUnknown
	allocs82cab330.Borrow(cobj_allocs)

	x.ref82cab330 = ref82cab330
	x.allocs82cab330 = allocs82cab330
	return ref82cab330, allocs82cab330

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x XrefEntry) PassValue() (C.pdf_xref_entry, *cgoAllocMap) {
	if x.ref82cab330 != nil {
		return *x.ref82cab330, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *XrefEntry) Deref() {
	if x.ref82cab330 == nil {
		return
	}
	x.Type = (byte)(x.ref82cab330._type)
	x.Flags = (byte)(x.ref82cab330.flags)
	x.Gen = (uint16)(x.ref82cab330.gen)
	x.Num = (int32)(x.ref82cab330.num)
	x.Ofs = (Off)(x.ref82cab330.ofs)
	x.StmOfs = (Off)(x.ref82cab330.stm_ofs)
	hxf7c2645 := (*sliceHeader)(unsafe.Pointer(&x.StmBuf))
	hxf7c2645.Data = uintptr(unsafe.Pointer(x.ref82cab330.stm_buf))
	hxf7c2645.Cap = 0x7fffffff
	// hxf7c2645.Len = ?

	hxfc83749 := (*sliceHeader)(unsafe.Pointer(&x.Obj))
	hxfc83749.Data = uintptr(unsafe.Pointer(x.ref82cab330.obj))
	hxfc83749.Cap = 0x7fffffff
	// hxfc83749.Len = ?

}

// unpackSXrefEntry transforms a sliced Go data structure into plain C format.
func unpackSXrefEntry(x []XrefEntry) (unpacked *C.pdf_xref_entry, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_xref_entry) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocXrefEntryMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_xref_entry)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_xref_entry)(unsafe.Pointer(h.Data))
	return
}

// packSXrefEntry reads sliced Go data structure out from plain C format.
func packSXrefEntry(v []XrefEntry, ptr0 *C.pdf_xref_entry) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfXrefEntryValue]C.pdf_xref_entry)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewXrefEntryRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *XrefSubsec) Ref() *C.pdf_xref_subsec {
	if x == nil {
		return nil
	}
	return x.ref709a5d4c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *XrefSubsec) Free() {
	if x != nil && x.allocs709a5d4c != nil {
		x.allocs709a5d4c.(*cgoAllocMap).Free()
		x.ref709a5d4c = nil
	}
}

// NewXrefSubsecRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewXrefSubsecRef(ref unsafe.Pointer) *XrefSubsec {
	if ref == nil {
		return nil
	}
	obj := new(XrefSubsec)
	obj.ref709a5d4c = (*C.pdf_xref_subsec)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *XrefSubsec) PassRef() (*C.pdf_xref_subsec, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref709a5d4c != nil {
		return x.ref709a5d4c, nil
	}
	mem709a5d4c := allocXrefSubsecMemory(1)
	ref709a5d4c := (*C.pdf_xref_subsec)(mem709a5d4c)
	allocs709a5d4c := new(cgoAllocMap)
	allocs709a5d4c.Add(mem709a5d4c)

	var cnext_allocs *cgoAllocMap
	ref709a5d4c.next, cnext_allocs = unpackSXrefSubsec(x.Next)
	allocs709a5d4c.Borrow(cnext_allocs)

	var clen_allocs *cgoAllocMap
	ref709a5d4c.len, clen_allocs = (C.int)(x.Len), cgoAllocsUnknown
	allocs709a5d4c.Borrow(clen_allocs)

	var cstart_allocs *cgoAllocMap
	ref709a5d4c.start, cstart_allocs = (C.fz_off_t)(x.Start), cgoAllocsUnknown
	allocs709a5d4c.Borrow(cstart_allocs)

	var ctable_allocs *cgoAllocMap
	ref709a5d4c.table, ctable_allocs = unpackSXrefEntry(x.Table)
	allocs709a5d4c.Borrow(ctable_allocs)

	x.ref709a5d4c = ref709a5d4c
	x.allocs709a5d4c = allocs709a5d4c
	return ref709a5d4c, allocs709a5d4c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x XrefSubsec) PassValue() (C.pdf_xref_subsec, *cgoAllocMap) {
	if x.ref709a5d4c != nil {
		return *x.ref709a5d4c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *XrefSubsec) Deref() {
	if x.ref709a5d4c == nil {
		return
	}
	packSXrefSubsec(x.Next, x.ref709a5d4c.next)
	x.Len = (int32)(x.ref709a5d4c.len)
	x.Start = (Off)(x.ref709a5d4c.start)
	packSXrefEntry(x.Table, x.ref709a5d4c.table)
}

// allocDesignatedNameMemory allocates memory for type C.pdf_designated_name in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDesignatedNameMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDesignatedNameValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDesignatedNameValue = unsafe.Sizeof([1]C.pdf_designated_name{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DesignatedName) Ref() *C.pdf_designated_name {
	if x == nil {
		return nil
	}
	return x.reff432d5bb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DesignatedName) Free() {
	if x != nil && x.allocsf432d5bb != nil {
		x.allocsf432d5bb.(*cgoAllocMap).Free()
		x.reff432d5bb = nil
	}
}

// NewDesignatedNameRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDesignatedNameRef(ref unsafe.Pointer) *DesignatedName {
	if ref == nil {
		return nil
	}
	obj := new(DesignatedName)
	obj.reff432d5bb = (*C.pdf_designated_name)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DesignatedName) PassRef() (*C.pdf_designated_name, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff432d5bb != nil {
		return x.reff432d5bb, nil
	}
	memf432d5bb := allocDesignatedNameMemory(1)
	reff432d5bb := (*C.pdf_designated_name)(memf432d5bb)
	allocsf432d5bb := new(cgoAllocMap)
	allocsf432d5bb.Add(memf432d5bb)

	var ccn_allocs *cgoAllocMap
	reff432d5bb.cn, ccn_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Cn)).Data)), cgoAllocsUnknown
	allocsf432d5bb.Borrow(ccn_allocs)

	var co_allocs *cgoAllocMap
	reff432d5bb.o, co_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.O)).Data)), cgoAllocsUnknown
	allocsf432d5bb.Borrow(co_allocs)

	var cou_allocs *cgoAllocMap
	reff432d5bb.ou, cou_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Ou)).Data)), cgoAllocsUnknown
	allocsf432d5bb.Borrow(cou_allocs)

	var cemail_allocs *cgoAllocMap
	reff432d5bb.email, cemail_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Email)).Data)), cgoAllocsUnknown
	allocsf432d5bb.Borrow(cemail_allocs)

	var cc_allocs *cgoAllocMap
	reff432d5bb.c, cc_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.C)).Data)), cgoAllocsUnknown
	allocsf432d5bb.Borrow(cc_allocs)

	x.reff432d5bb = reff432d5bb
	x.allocsf432d5bb = allocsf432d5bb
	return reff432d5bb, allocsf432d5bb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DesignatedName) PassValue() (C.pdf_designated_name, *cgoAllocMap) {
	if x.reff432d5bb != nil {
		return *x.reff432d5bb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DesignatedName) Deref() {
	if x.reff432d5bb == nil {
		return
	}
	hxfa45f91 := (*sliceHeader)(unsafe.Pointer(&x.Cn))
	hxfa45f91.Data = uintptr(unsafe.Pointer(x.reff432d5bb.cn))
	hxfa45f91.Cap = 0x7fffffff
	// hxfa45f91.Len = ?

	hxf59053c := (*sliceHeader)(unsafe.Pointer(&x.O))
	hxf59053c.Data = uintptr(unsafe.Pointer(x.reff432d5bb.o))
	hxf59053c.Cap = 0x7fffffff
	// hxf59053c.Len = ?

	hxf6301b1 := (*sliceHeader)(unsafe.Pointer(&x.Ou))
	hxf6301b1.Data = uintptr(unsafe.Pointer(x.reff432d5bb.ou))
	hxf6301b1.Cap = 0x7fffffff
	// hxf6301b1.Len = ?

	hxfb2b86e := (*sliceHeader)(unsafe.Pointer(&x.Email))
	hxfb2b86e.Data = uintptr(unsafe.Pointer(x.reff432d5bb.email))
	hxfb2b86e.Cap = 0x7fffffff
	// hxfb2b86e.Len = ?

	hxfe8254a := (*sliceHeader)(unsafe.Pointer(&x.C))
	hxfe8254a.Data = uintptr(unsafe.Pointer(x.reff432d5bb.c))
	hxfe8254a.Cap = 0x7fffffff
	// hxfe8254a.Len = ?

}

func (x PageContentsProcessFn) PassRef() (ref *C.pdf_page_contents_process_fn, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pageContentsProcessFn7F179711Func == nil {
		pageContentsProcessFn7F179711Func = x
	}
	return (*C.pdf_page_contents_process_fn)(C.pdf_page_contents_process_fn_7f179711), nil
}

func NewPageContentsProcessFnRef(ref unsafe.Pointer) *PageContentsProcessFn {
	return (*PageContentsProcessFn)(ref)
}

//export pageContentsProcessFn7F179711
func pageContentsProcessFn7F179711(cctx *C.fz_context, cbuffer *C.fz_buffer, cres *C.pdf_obj, carg unsafe.Pointer) {
	if pageContentsProcessFn7F179711Func != nil {
		var ctx7f179711 []Context
		packSContext(ctx7f179711, cctx)
		var buffer7f179711 []Buffer
		hxf1c615c := (*sliceHeader)(unsafe.Pointer(&buffer7f179711))
		hxf1c615c.Data = uintptr(unsafe.Pointer(cbuffer))
		hxf1c615c.Cap = 0x7fffffff
		// hxf1c615c.Len = ?

		var res7f179711 []Obj
		hxf1ab1b2 := (*sliceHeader)(unsafe.Pointer(&res7f179711))
		hxf1ab1b2.Data = uintptr(unsafe.Pointer(cres))
		hxf1ab1b2.Cap = 0x7fffffff
		// hxf1ab1b2.Len = ?

		arg7f179711 := (unsafe.Pointer)(unsafe.Pointer(carg))
		pageContentsProcessFn7F179711Func(ctx7f179711, buffer7f179711, res7f179711, arg7f179711)
		return
	}
	panic("callback func has not been set (race?)")
}

var pageContentsProcessFn7F179711Func PageContentsProcessFn

// Ref returns a reference to C object as it is.
func (x *Function) Ref() *C.pdf_function {
	if x == nil {
		return nil
	}
	return (*C.pdf_function)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Function) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFunctionRef converts the C object reference into a raw struct reference without wrapping.
func NewFunctionRef(ref unsafe.Pointer) *Function {
	return (*Function)(ref)
}

// NewFunction allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFunction() *Function {
	return (*Function)(allocFunctionMemory(1))
}

// allocFunctionMemory allocates memory for type C.pdf_function in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFunctionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFunctionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFunctionValue = unsafe.Sizeof([1]C.pdf_function{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Function) PassRef() *C.pdf_function {
	if x == nil {
		x = (*Function)(allocFunctionMemory(1))
	}
	return (*C.pdf_function)(unsafe.Pointer(x))
}

// allocPatternMemory allocates memory for type C.pdf_pattern in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPatternMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPatternValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPatternValue = unsafe.Sizeof([1]C.pdf_pattern{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Pattern) Ref() *C.pdf_pattern {
	if x == nil {
		return nil
	}
	return x.refd0067da1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Pattern) Free() {
	if x != nil && x.allocsd0067da1 != nil {
		x.allocsd0067da1.(*cgoAllocMap).Free()
		x.refd0067da1 = nil
	}
}

// NewPatternRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPatternRef(ref unsafe.Pointer) *Pattern {
	if ref == nil {
		return nil
	}
	obj := new(Pattern)
	obj.refd0067da1 = (*C.pdf_pattern)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Pattern) PassRef() (*C.pdf_pattern, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd0067da1 != nil {
		return x.refd0067da1, nil
	}
	memd0067da1 := allocPatternMemory(1)
	refd0067da1 := (*C.pdf_pattern)(memd0067da1)
	allocsd0067da1 := new(cgoAllocMap)
	allocsd0067da1.Add(memd0067da1)

	var cstorable_allocs *cgoAllocMap
	refd0067da1.storable, cstorable_allocs = x.Storable.PassValue()
	allocsd0067da1.Borrow(cstorable_allocs)

	var cismask_allocs *cgoAllocMap
	refd0067da1.ismask, cismask_allocs = (C.int)(x.Ismask), cgoAllocsUnknown
	allocsd0067da1.Borrow(cismask_allocs)

	var cxstep_allocs *cgoAllocMap
	refd0067da1.xstep, cxstep_allocs = (C.float)(x.Xstep), cgoAllocsUnknown
	allocsd0067da1.Borrow(cxstep_allocs)

	var cystep_allocs *cgoAllocMap
	refd0067da1.ystep, cystep_allocs = (C.float)(x.Ystep), cgoAllocsUnknown
	allocsd0067da1.Borrow(cystep_allocs)

	var cmatrix_allocs *cgoAllocMap
	refd0067da1.matrix, cmatrix_allocs = x.Matrix.PassValue()
	allocsd0067da1.Borrow(cmatrix_allocs)

	var cbbox_allocs *cgoAllocMap
	refd0067da1.bbox, cbbox_allocs = x.Bbox.PassValue()
	allocsd0067da1.Borrow(cbbox_allocs)

	var cdocument_allocs *cgoAllocMap
	refd0067da1.document, cdocument_allocs = unpackSDocument(x.Document)
	allocsd0067da1.Borrow(cdocument_allocs)

	var cresources_allocs *cgoAllocMap
	refd0067da1.resources, cresources_allocs = (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Resources)).Data)), cgoAllocsUnknown
	allocsd0067da1.Borrow(cresources_allocs)

	var ccontents_allocs *cgoAllocMap
	refd0067da1.contents, ccontents_allocs = (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Contents)).Data)), cgoAllocsUnknown
	allocsd0067da1.Borrow(ccontents_allocs)

	var cid_allocs *cgoAllocMap
	refd0067da1.id, cid_allocs = (C.int)(x.Id), cgoAllocsUnknown
	allocsd0067da1.Borrow(cid_allocs)

	x.refd0067da1 = refd0067da1
	x.allocsd0067da1 = allocsd0067da1
	return refd0067da1, allocsd0067da1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Pattern) PassValue() (C.pdf_pattern, *cgoAllocMap) {
	if x.refd0067da1 != nil {
		return *x.refd0067da1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Pattern) Deref() {
	if x.refd0067da1 == nil {
		return
	}
	x.Storable = *NewStorableRef(unsafe.Pointer(&x.refd0067da1.storable))
	x.Ismask = (int32)(x.refd0067da1.ismask)
	x.Xstep = (float32)(x.refd0067da1.xstep)
	x.Ystep = (float32)(x.refd0067da1.ystep)
	x.Matrix = *NewMatrixRef(unsafe.Pointer(&x.refd0067da1.matrix))
	x.Bbox = *NewRectRef(unsafe.Pointer(&x.refd0067da1.bbox))
	packSDocument(x.Document, x.refd0067da1.document)
	hxfbbed48 := (*sliceHeader)(unsafe.Pointer(&x.Resources))
	hxfbbed48.Data = uintptr(unsafe.Pointer(x.refd0067da1.resources))
	hxfbbed48.Cap = 0x7fffffff
	// hxfbbed48.Len = ?

	hxf9cdd70 := (*sliceHeader)(unsafe.Pointer(&x.Contents))
	hxf9cdd70.Data = uintptr(unsafe.Pointer(x.refd0067da1.contents))
	hxf9cdd70.Cap = 0x7fffffff
	// hxf9cdd70.Len = ?

	x.Id = (int32)(x.refd0067da1.id)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Xobject) Ref() *C.pdf_xobject {
	if x == nil {
		return nil
	}
	return x.ref283eca52
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Xobject) Free() {
	if x != nil && x.allocs283eca52 != nil {
		x.allocs283eca52.(*cgoAllocMap).Free()
		x.ref283eca52 = nil
	}
}

// NewXobjectRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewXobjectRef(ref unsafe.Pointer) *Xobject {
	if ref == nil {
		return nil
	}
	obj := new(Xobject)
	obj.ref283eca52 = (*C.pdf_xobject)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Xobject) PassRef() (*C.pdf_xobject, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref283eca52 != nil {
		return x.ref283eca52, nil
	}
	mem283eca52 := allocXobjectMemory(1)
	ref283eca52 := (*C.pdf_xobject)(mem283eca52)
	allocs283eca52 := new(cgoAllocMap)
	allocs283eca52.Add(mem283eca52)

	var cstorable_allocs *cgoAllocMap
	ref283eca52.storable, cstorable_allocs = x.Storable.PassValue()
	allocs283eca52.Borrow(cstorable_allocs)

	var cobj_allocs *cgoAllocMap
	ref283eca52.obj, cobj_allocs = (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Obj)).Data)), cgoAllocsUnknown
	allocs283eca52.Borrow(cobj_allocs)

	var citeration_allocs *cgoAllocMap
	ref283eca52.iteration, citeration_allocs = (C.int)(x.Iteration), cgoAllocsUnknown
	allocs283eca52.Borrow(citeration_allocs)

	x.ref283eca52 = ref283eca52
	x.allocs283eca52 = allocs283eca52
	return ref283eca52, allocs283eca52

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Xobject) PassValue() (C.pdf_xobject, *cgoAllocMap) {
	if x.ref283eca52 != nil {
		return *x.ref283eca52, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Xobject) Deref() {
	if x.ref283eca52 == nil {
		return
	}
	x.Storable = *NewStorableRef(unsafe.Pointer(&x.ref283eca52.storable))
	hxf84a54f := (*sliceHeader)(unsafe.Pointer(&x.Obj))
	hxf84a54f.Data = uintptr(unsafe.Pointer(x.ref283eca52.obj))
	hxf84a54f.Cap = 0x7fffffff
	// hxf84a54f.Len = ?

	x.Iteration = (int32)(x.ref283eca52.iteration)
}

// allocCmapMemory allocates memory for type C.pdf_cmap in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCmapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCmapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCmapValue = unsafe.Sizeof([1]C.pdf_cmap{})

// unpackSCmap transforms a sliced Go data structure into plain C format.
func unpackSCmap(x []Cmap) (unpacked *C.pdf_cmap, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_cmap) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCmapMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_cmap)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_cmap)(unsafe.Pointer(h.Data))
	return
}

// allocRangeMemory allocates memory for type C.pdf_range in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRangeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRangeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRangeValue = unsafe.Sizeof([1]C.pdf_range{})

// unpackSRange transforms a sliced Go data structure into plain C format.
func unpackSRange(x []Range) (unpacked *C.pdf_range, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_range) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRangeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_range)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_range)(unsafe.Pointer(h.Data))
	return
}

// allocXrangeMemory allocates memory for type C.pdf_xrange in C.
// The caller is responsible for freeing the this memory via C.free.
func allocXrangeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfXrangeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfXrangeValue = unsafe.Sizeof([1]C.pdf_xrange{})

// unpackSXrange transforms a sliced Go data structure into plain C format.
func unpackSXrange(x []Xrange) (unpacked *C.pdf_xrange, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_xrange) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocXrangeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_xrange)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_xrange)(unsafe.Pointer(h.Data))
	return
}

// allocMrangeMemory allocates memory for type C.pdf_mrange in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMrangeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMrangeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMrangeValue = unsafe.Sizeof([1]C.pdf_mrange{})

// unpackSMrange transforms a sliced Go data structure into plain C format.
func unpackSMrange(x []Mrange) (unpacked *C.pdf_mrange, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_mrange) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMrangeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_mrange)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_mrange)(unsafe.Pointer(h.Data))
	return
}

// packSCmap reads sliced Go data structure out from plain C format.
func packSCmap(v []Cmap, ptr0 *C.pdf_cmap) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCmapValue]C.pdf_cmap)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCmapRef(unsafe.Pointer(&ptr1))
	}
}

// packSRange reads sliced Go data structure out from plain C format.
func packSRange(v []Range, ptr0 *C.pdf_range) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRangeValue]C.pdf_range)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRangeRef(unsafe.Pointer(&ptr1))
	}
}

// packSXrange reads sliced Go data structure out from plain C format.
func packSXrange(v []Xrange, ptr0 *C.pdf_xrange) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfXrangeValue]C.pdf_xrange)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewXrangeRef(unsafe.Pointer(&ptr1))
	}
}

// packSMrange reads sliced Go data structure out from plain C format.
func packSMrange(v []Mrange, ptr0 *C.pdf_mrange) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMrangeValue]C.pdf_mrange)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMrangeRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Cmap) Ref() *C.pdf_cmap {
	if x == nil {
		return nil
	}
	return x.ref971ab916
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Cmap) Free() {
	if x != nil && x.allocs971ab916 != nil {
		x.allocs971ab916.(*cgoAllocMap).Free()
		x.ref971ab916 = nil
	}
}

// NewCmapRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCmapRef(ref unsafe.Pointer) *Cmap {
	if ref == nil {
		return nil
	}
	obj := new(Cmap)
	obj.ref971ab916 = (*C.pdf_cmap)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Cmap) PassRef() (*C.pdf_cmap, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref971ab916 != nil {
		return x.ref971ab916, nil
	}
	mem971ab916 := allocCmapMemory(1)
	ref971ab916 := (*C.pdf_cmap)(mem971ab916)
	allocs971ab916 := new(cgoAllocMap)
	allocs971ab916.Add(mem971ab916)

	var cstorable_allocs *cgoAllocMap
	ref971ab916.storable, cstorable_allocs = x.Storable.PassValue()
	allocs971ab916.Borrow(cstorable_allocs)

	var ccmap_name_allocs *cgoAllocMap
	ref971ab916.cmap_name, ccmap_name_allocs = *(*[32]C.char)(unsafe.Pointer(&x.CmapName)), cgoAllocsUnknown
	allocs971ab916.Borrow(ccmap_name_allocs)

	var cusecmap_name_allocs *cgoAllocMap
	ref971ab916.usecmap_name, cusecmap_name_allocs = *(*[32]C.char)(unsafe.Pointer(&x.UsecmapName)), cgoAllocsUnknown
	allocs971ab916.Borrow(cusecmap_name_allocs)

	var cusecmap_allocs *cgoAllocMap
	ref971ab916.usecmap, cusecmap_allocs = unpackSCmap(x.Usecmap)
	allocs971ab916.Borrow(cusecmap_allocs)

	var cwmode_allocs *cgoAllocMap
	ref971ab916.wmode, cwmode_allocs = (C.int)(x.Wmode), cgoAllocsUnknown
	allocs971ab916.Borrow(cwmode_allocs)

	var ccodespace_len_allocs *cgoAllocMap
	ref971ab916.codespace_len, ccodespace_len_allocs = (C.int)(x.CodespaceLen), cgoAllocsUnknown
	allocs971ab916.Borrow(ccodespace_len_allocs)

	var crlen_allocs *cgoAllocMap
	ref971ab916.rlen, crlen_allocs = (C.int)(x.Rlen), cgoAllocsUnknown
	allocs971ab916.Borrow(crlen_allocs)

	var crcap_allocs *cgoAllocMap
	ref971ab916.rcap, crcap_allocs = (C.int)(x.Rcap), cgoAllocsUnknown
	allocs971ab916.Borrow(crcap_allocs)

	var cranges_allocs *cgoAllocMap
	ref971ab916.ranges, cranges_allocs = unpackSRange(x.Ranges)
	allocs971ab916.Borrow(cranges_allocs)

	var cxlen_allocs *cgoAllocMap
	ref971ab916.xlen, cxlen_allocs = (C.int)(x.Xlen), cgoAllocsUnknown
	allocs971ab916.Borrow(cxlen_allocs)

	var cxcap_allocs *cgoAllocMap
	ref971ab916.xcap, cxcap_allocs = (C.int)(x.Xcap), cgoAllocsUnknown
	allocs971ab916.Borrow(cxcap_allocs)

	var cxranges_allocs *cgoAllocMap
	ref971ab916.xranges, cxranges_allocs = unpackSXrange(x.Xranges)
	allocs971ab916.Borrow(cxranges_allocs)

	var cmlen_allocs *cgoAllocMap
	ref971ab916.mlen, cmlen_allocs = (C.int)(x.Mlen), cgoAllocsUnknown
	allocs971ab916.Borrow(cmlen_allocs)

	var cmcap_allocs *cgoAllocMap
	ref971ab916.mcap, cmcap_allocs = (C.int)(x.Mcap), cgoAllocsUnknown
	allocs971ab916.Borrow(cmcap_allocs)

	var cmranges_allocs *cgoAllocMap
	ref971ab916.mranges, cmranges_allocs = unpackSMrange(x.Mranges)
	allocs971ab916.Borrow(cmranges_allocs)

	var cdlen_allocs *cgoAllocMap
	ref971ab916.dlen, cdlen_allocs = (C.int)(x.Dlen), cgoAllocsUnknown
	allocs971ab916.Borrow(cdlen_allocs)

	var cdcap_allocs *cgoAllocMap
	ref971ab916.dcap, cdcap_allocs = (C.int)(x.Dcap), cgoAllocsUnknown
	allocs971ab916.Borrow(cdcap_allocs)

	var cdict_allocs *cgoAllocMap
	ref971ab916.dict, cdict_allocs = (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Dict)).Data)), cgoAllocsUnknown
	allocs971ab916.Borrow(cdict_allocs)

	var ctlen_allocs *cgoAllocMap
	ref971ab916.tlen, ctlen_allocs = (C.int)(x.Tlen), cgoAllocsUnknown
	allocs971ab916.Borrow(ctlen_allocs)

	var ctcap_allocs *cgoAllocMap
	ref971ab916.tcap, ctcap_allocs = (C.int)(x.Tcap), cgoAllocsUnknown
	allocs971ab916.Borrow(ctcap_allocs)

	var cttop_allocs *cgoAllocMap
	ref971ab916.ttop, cttop_allocs = (C.int)(x.Ttop), cgoAllocsUnknown
	allocs971ab916.Borrow(cttop_allocs)

	x.ref971ab916 = ref971ab916
	x.allocs971ab916 = allocs971ab916
	return ref971ab916, allocs971ab916

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Cmap) PassValue() (C.pdf_cmap, *cgoAllocMap) {
	if x.ref971ab916 != nil {
		return *x.ref971ab916, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Cmap) Deref() {
	if x.ref971ab916 == nil {
		return
	}
	x.Storable = *NewStorableRef(unsafe.Pointer(&x.ref971ab916.storable))
	x.CmapName = *(*[32]byte)(unsafe.Pointer(&x.ref971ab916.cmap_name))
	x.UsecmapName = *(*[32]byte)(unsafe.Pointer(&x.ref971ab916.usecmap_name))
	packSCmap(x.Usecmap, x.ref971ab916.usecmap)
	x.Wmode = (int32)(x.ref971ab916.wmode)
	x.CodespaceLen = (int32)(x.ref971ab916.codespace_len)
	x.Rlen = (int32)(x.ref971ab916.rlen)
	x.Rcap = (int32)(x.ref971ab916.rcap)
	packSRange(x.Ranges, x.ref971ab916.ranges)
	x.Xlen = (int32)(x.ref971ab916.xlen)
	x.Xcap = (int32)(x.ref971ab916.xcap)
	packSXrange(x.Xranges, x.ref971ab916.xranges)
	x.Mlen = (int32)(x.ref971ab916.mlen)
	x.Mcap = (int32)(x.ref971ab916.mcap)
	packSMrange(x.Mranges, x.ref971ab916.mranges)
	x.Dlen = (int32)(x.ref971ab916.dlen)
	x.Dcap = (int32)(x.ref971ab916.dcap)
	hxf6a06fa := (*sliceHeader)(unsafe.Pointer(&x.Dict))
	hxf6a06fa.Data = uintptr(unsafe.Pointer(x.ref971ab916.dict))
	hxf6a06fa.Cap = 0x7fffffff
	// hxf6a06fa.Len = ?

	x.Tlen = (int32)(x.ref971ab916.tlen)
	x.Tcap = (int32)(x.ref971ab916.tcap)
	x.Ttop = (int32)(x.ref971ab916.ttop)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Range) Ref() *C.pdf_range {
	if x == nil {
		return nil
	}
	return x.ref2101793
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Range) Free() {
	if x != nil && x.allocs2101793 != nil {
		x.allocs2101793.(*cgoAllocMap).Free()
		x.ref2101793 = nil
	}
}

// NewRangeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRangeRef(ref unsafe.Pointer) *Range {
	if ref == nil {
		return nil
	}
	obj := new(Range)
	obj.ref2101793 = (*C.pdf_range)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Range) PassRef() (*C.pdf_range, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2101793 != nil {
		return x.ref2101793, nil
	}
	mem2101793 := allocRangeMemory(1)
	ref2101793 := (*C.pdf_range)(mem2101793)
	allocs2101793 := new(cgoAllocMap)
	allocs2101793.Add(mem2101793)

	var clow_allocs *cgoAllocMap
	ref2101793.low, clow_allocs = (C.ushort)(x.Low), cgoAllocsUnknown
	allocs2101793.Borrow(clow_allocs)

	var chigh_allocs *cgoAllocMap
	ref2101793.high, chigh_allocs = (C.ushort)(x.High), cgoAllocsUnknown
	allocs2101793.Borrow(chigh_allocs)

	var cout_allocs *cgoAllocMap
	ref2101793.out, cout_allocs = (C.ushort)(x.Out), cgoAllocsUnknown
	allocs2101793.Borrow(cout_allocs)

	x.ref2101793 = ref2101793
	x.allocs2101793 = allocs2101793
	return ref2101793, allocs2101793

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Range) PassValue() (C.pdf_range, *cgoAllocMap) {
	if x.ref2101793 != nil {
		return *x.ref2101793, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Range) Deref() {
	if x.ref2101793 == nil {
		return
	}
	x.Low = (uint16)(x.ref2101793.low)
	x.High = (uint16)(x.ref2101793.high)
	x.Out = (uint16)(x.ref2101793.out)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Xrange) Ref() *C.pdf_xrange {
	if x == nil {
		return nil
	}
	return x.ref65812fdc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Xrange) Free() {
	if x != nil && x.allocs65812fdc != nil {
		x.allocs65812fdc.(*cgoAllocMap).Free()
		x.ref65812fdc = nil
	}
}

// NewXrangeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewXrangeRef(ref unsafe.Pointer) *Xrange {
	if ref == nil {
		return nil
	}
	obj := new(Xrange)
	obj.ref65812fdc = (*C.pdf_xrange)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Xrange) PassRef() (*C.pdf_xrange, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref65812fdc != nil {
		return x.ref65812fdc, nil
	}
	mem65812fdc := allocXrangeMemory(1)
	ref65812fdc := (*C.pdf_xrange)(mem65812fdc)
	allocs65812fdc := new(cgoAllocMap)
	allocs65812fdc.Add(mem65812fdc)

	var clow_allocs *cgoAllocMap
	ref65812fdc.low, clow_allocs = (C.uint)(x.Low), cgoAllocsUnknown
	allocs65812fdc.Borrow(clow_allocs)

	var chigh_allocs *cgoAllocMap
	ref65812fdc.high, chigh_allocs = (C.uint)(x.High), cgoAllocsUnknown
	allocs65812fdc.Borrow(chigh_allocs)

	var cout_allocs *cgoAllocMap
	ref65812fdc.out, cout_allocs = (C.uint)(x.Out), cgoAllocsUnknown
	allocs65812fdc.Borrow(cout_allocs)

	x.ref65812fdc = ref65812fdc
	x.allocs65812fdc = allocs65812fdc
	return ref65812fdc, allocs65812fdc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Xrange) PassValue() (C.pdf_xrange, *cgoAllocMap) {
	if x.ref65812fdc != nil {
		return *x.ref65812fdc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Xrange) Deref() {
	if x.ref65812fdc == nil {
		return
	}
	x.Low = (uint32)(x.ref65812fdc.low)
	x.High = (uint32)(x.ref65812fdc.high)
	x.Out = (uint32)(x.ref65812fdc.out)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Mrange) Ref() *C.pdf_mrange {
	if x == nil {
		return nil
	}
	return x.ref369abcf4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Mrange) Free() {
	if x != nil && x.allocs369abcf4 != nil {
		x.allocs369abcf4.(*cgoAllocMap).Free()
		x.ref369abcf4 = nil
	}
}

// NewMrangeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMrangeRef(ref unsafe.Pointer) *Mrange {
	if ref == nil {
		return nil
	}
	obj := new(Mrange)
	obj.ref369abcf4 = (*C.pdf_mrange)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Mrange) PassRef() (*C.pdf_mrange, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref369abcf4 != nil {
		return x.ref369abcf4, nil
	}
	mem369abcf4 := allocMrangeMemory(1)
	ref369abcf4 := (*C.pdf_mrange)(mem369abcf4)
	allocs369abcf4 := new(cgoAllocMap)
	allocs369abcf4.Add(mem369abcf4)

	var clow_allocs *cgoAllocMap
	ref369abcf4.low, clow_allocs = (C.uint)(x.Low), cgoAllocsUnknown
	allocs369abcf4.Borrow(clow_allocs)

	var cout_allocs *cgoAllocMap
	ref369abcf4.out, cout_allocs = (C.uint)(x.Out), cgoAllocsUnknown
	allocs369abcf4.Borrow(cout_allocs)

	x.ref369abcf4 = ref369abcf4
	x.allocs369abcf4 = allocs369abcf4
	return ref369abcf4, allocs369abcf4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Mrange) PassValue() (C.pdf_mrange, *cgoAllocMap) {
	if x.ref369abcf4 != nil {
		return *x.ref369abcf4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Mrange) Deref() {
	if x.ref369abcf4 == nil {
		return
	}
	x.Low = (uint32)(x.ref369abcf4.low)
	x.Out = (uint32)(x.ref369abcf4.out)
}

// allocFontDescMemory allocates memory for type C.pdf_font_desc in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFontDescMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFontDescValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFontDescValue = unsafe.Sizeof([1]C.pdf_font_desc{})

// allocHmtxMemory allocates memory for type C.pdf_hmtx in C.
// The caller is responsible for freeing the this memory via C.free.
func allocHmtxMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfHmtxValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfHmtxValue = unsafe.Sizeof([1]C.pdf_hmtx{})

// unpackSHmtx transforms a sliced Go data structure into plain C format.
func unpackSHmtx(x []Hmtx) (unpacked *C.pdf_hmtx, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_hmtx) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocHmtxMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_hmtx)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_hmtx)(unsafe.Pointer(h.Data))
	return
}

// allocVmtxMemory allocates memory for type C.pdf_vmtx in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVmtxMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVmtxValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVmtxValue = unsafe.Sizeof([1]C.pdf_vmtx{})

// unpackSVmtx transforms a sliced Go data structure into plain C format.
func unpackSVmtx(x []Vmtx) (unpacked *C.pdf_vmtx, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_vmtx) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocVmtxMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_vmtx)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_vmtx)(unsafe.Pointer(h.Data))
	return
}

// packSHmtx reads sliced Go data structure out from plain C format.
func packSHmtx(v []Hmtx, ptr0 *C.pdf_hmtx) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfHmtxValue]C.pdf_hmtx)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewHmtxRef(unsafe.Pointer(&ptr1))
	}
}

// packSVmtx reads sliced Go data structure out from plain C format.
func packSVmtx(v []Vmtx, ptr0 *C.pdf_vmtx) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfVmtxValue]C.pdf_vmtx)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewVmtxRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FontDesc) Ref() *C.pdf_font_desc {
	if x == nil {
		return nil
	}
	return x.ref9390f5cb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FontDesc) Free() {
	if x != nil && x.allocs9390f5cb != nil {
		x.allocs9390f5cb.(*cgoAllocMap).Free()
		x.ref9390f5cb = nil
	}
}

// NewFontDescRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFontDescRef(ref unsafe.Pointer) *FontDesc {
	if ref == nil {
		return nil
	}
	obj := new(FontDesc)
	obj.ref9390f5cb = (*C.pdf_font_desc)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FontDesc) PassRef() (*C.pdf_font_desc, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9390f5cb != nil {
		return x.ref9390f5cb, nil
	}
	mem9390f5cb := allocFontDescMemory(1)
	ref9390f5cb := (*C.pdf_font_desc)(mem9390f5cb)
	allocs9390f5cb := new(cgoAllocMap)
	allocs9390f5cb.Add(mem9390f5cb)

	var cstorable_allocs *cgoAllocMap
	ref9390f5cb.storable, cstorable_allocs = x.Storable.PassValue()
	allocs9390f5cb.Borrow(cstorable_allocs)

	var csize_allocs *cgoAllocMap
	ref9390f5cb.size, csize_allocs = (C.size_t)(x.Size), cgoAllocsUnknown
	allocs9390f5cb.Borrow(csize_allocs)

	var cfont_allocs *cgoAllocMap
	ref9390f5cb.font, cfont_allocs = (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Font)).Data)), cgoAllocsUnknown
	allocs9390f5cb.Borrow(cfont_allocs)

	var cflags_allocs *cgoAllocMap
	ref9390f5cb.flags, cflags_allocs = (C.int)(x.Flags), cgoAllocsUnknown
	allocs9390f5cb.Borrow(cflags_allocs)

	var citalic_angle_allocs *cgoAllocMap
	ref9390f5cb.italic_angle, citalic_angle_allocs = (C.float)(x.ItalicAngle), cgoAllocsUnknown
	allocs9390f5cb.Borrow(citalic_angle_allocs)

	var cascent_allocs *cgoAllocMap
	ref9390f5cb.ascent, cascent_allocs = (C.float)(x.Ascent), cgoAllocsUnknown
	allocs9390f5cb.Borrow(cascent_allocs)

	var cdescent_allocs *cgoAllocMap
	ref9390f5cb.descent, cdescent_allocs = (C.float)(x.Descent), cgoAllocsUnknown
	allocs9390f5cb.Borrow(cdescent_allocs)

	var ccap_height_allocs *cgoAllocMap
	ref9390f5cb.cap_height, ccap_height_allocs = (C.float)(x.CapHeight), cgoAllocsUnknown
	allocs9390f5cb.Borrow(ccap_height_allocs)

	var cx_height_allocs *cgoAllocMap
	ref9390f5cb.x_height, cx_height_allocs = (C.float)(x.XHeight), cgoAllocsUnknown
	allocs9390f5cb.Borrow(cx_height_allocs)

	var cmissing_width_allocs *cgoAllocMap
	ref9390f5cb.missing_width, cmissing_width_allocs = (C.float)(x.MissingWidth), cgoAllocsUnknown
	allocs9390f5cb.Borrow(cmissing_width_allocs)

	var cencoding_allocs *cgoAllocMap
	ref9390f5cb.encoding, cencoding_allocs = unpackSCmap(x.Encoding)
	allocs9390f5cb.Borrow(cencoding_allocs)

	var cto_ttf_cmap_allocs *cgoAllocMap
	ref9390f5cb.to_ttf_cmap, cto_ttf_cmap_allocs = unpackSCmap(x.ToTtfCmap)
	allocs9390f5cb.Borrow(cto_ttf_cmap_allocs)

	var ccid_to_gid_len_allocs *cgoAllocMap
	ref9390f5cb.cid_to_gid_len, ccid_to_gid_len_allocs = (C.size_t)(x.CidToGidLen), cgoAllocsUnknown
	allocs9390f5cb.Borrow(ccid_to_gid_len_allocs)

	var ccid_to_gid_allocs *cgoAllocMap
	ref9390f5cb.cid_to_gid, ccid_to_gid_allocs = (*C.ushort)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.CidToGid)).Data)), cgoAllocsUnknown
	allocs9390f5cb.Borrow(ccid_to_gid_allocs)

	var cto_unicode_allocs *cgoAllocMap
	ref9390f5cb.to_unicode, cto_unicode_allocs = unpackSCmap(x.ToUnicode)
	allocs9390f5cb.Borrow(cto_unicode_allocs)

	var ccid_to_ucs_len_allocs *cgoAllocMap
	ref9390f5cb.cid_to_ucs_len, ccid_to_ucs_len_allocs = (C.size_t)(x.CidToUcsLen), cgoAllocsUnknown
	allocs9390f5cb.Borrow(ccid_to_ucs_len_allocs)

	var ccid_to_ucs_allocs *cgoAllocMap
	ref9390f5cb.cid_to_ucs, ccid_to_ucs_allocs = (*C.ushort)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.CidToUcs)).Data)), cgoAllocsUnknown
	allocs9390f5cb.Borrow(ccid_to_ucs_allocs)

	var cwmode_allocs *cgoAllocMap
	ref9390f5cb.wmode, cwmode_allocs = (C.int)(x.Wmode), cgoAllocsUnknown
	allocs9390f5cb.Borrow(cwmode_allocs)

	var chmtx_len_allocs *cgoAllocMap
	ref9390f5cb.hmtx_len, chmtx_len_allocs = (C.int)(x.HmtxLen), cgoAllocsUnknown
	allocs9390f5cb.Borrow(chmtx_len_allocs)

	var chmtx_cap_allocs *cgoAllocMap
	ref9390f5cb.hmtx_cap, chmtx_cap_allocs = (C.int)(x.HmtxCap), cgoAllocsUnknown
	allocs9390f5cb.Borrow(chmtx_cap_allocs)

	var cdhmtx_allocs *cgoAllocMap
	ref9390f5cb.dhmtx, cdhmtx_allocs = x.Dhmtx.PassValue()
	allocs9390f5cb.Borrow(cdhmtx_allocs)

	var chmtx_allocs *cgoAllocMap
	ref9390f5cb.hmtx, chmtx_allocs = unpackSHmtx(x.Hmtx)
	allocs9390f5cb.Borrow(chmtx_allocs)

	var cvmtx_len_allocs *cgoAllocMap
	ref9390f5cb.vmtx_len, cvmtx_len_allocs = (C.int)(x.VmtxLen), cgoAllocsUnknown
	allocs9390f5cb.Borrow(cvmtx_len_allocs)

	var cvmtx_cap_allocs *cgoAllocMap
	ref9390f5cb.vmtx_cap, cvmtx_cap_allocs = (C.int)(x.VmtxCap), cgoAllocsUnknown
	allocs9390f5cb.Borrow(cvmtx_cap_allocs)

	var cdvmtx_allocs *cgoAllocMap
	ref9390f5cb.dvmtx, cdvmtx_allocs = x.Dvmtx.PassValue()
	allocs9390f5cb.Borrow(cdvmtx_allocs)

	var cvmtx_allocs *cgoAllocMap
	ref9390f5cb.vmtx, cvmtx_allocs = unpackSVmtx(x.Vmtx)
	allocs9390f5cb.Borrow(cvmtx_allocs)

	var cis_embedded_allocs *cgoAllocMap
	ref9390f5cb.is_embedded, cis_embedded_allocs = (C.int)(x.IsEmbedded), cgoAllocsUnknown
	allocs9390f5cb.Borrow(cis_embedded_allocs)

	x.ref9390f5cb = ref9390f5cb
	x.allocs9390f5cb = allocs9390f5cb
	return ref9390f5cb, allocs9390f5cb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FontDesc) PassValue() (C.pdf_font_desc, *cgoAllocMap) {
	if x.ref9390f5cb != nil {
		return *x.ref9390f5cb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FontDesc) Deref() {
	if x.ref9390f5cb == nil {
		return
	}
	x.Storable = *NewStorableRef(unsafe.Pointer(&x.ref9390f5cb.storable))
	x.Size = (uint)(x.ref9390f5cb.size)
	hxf5ba44e := (*sliceHeader)(unsafe.Pointer(&x.Font))
	hxf5ba44e.Data = uintptr(unsafe.Pointer(x.ref9390f5cb.font))
	hxf5ba44e.Cap = 0x7fffffff
	// hxf5ba44e.Len = ?

	x.Flags = (int32)(x.ref9390f5cb.flags)
	x.ItalicAngle = (float32)(x.ref9390f5cb.italic_angle)
	x.Ascent = (float32)(x.ref9390f5cb.ascent)
	x.Descent = (float32)(x.ref9390f5cb.descent)
	x.CapHeight = (float32)(x.ref9390f5cb.cap_height)
	x.XHeight = (float32)(x.ref9390f5cb.x_height)
	x.MissingWidth = (float32)(x.ref9390f5cb.missing_width)
	packSCmap(x.Encoding, x.ref9390f5cb.encoding)
	packSCmap(x.ToTtfCmap, x.ref9390f5cb.to_ttf_cmap)
	x.CidToGidLen = (uint)(x.ref9390f5cb.cid_to_gid_len)
	hxf1ae993 := (*sliceHeader)(unsafe.Pointer(&x.CidToGid))
	hxf1ae993.Data = uintptr(unsafe.Pointer(x.ref9390f5cb.cid_to_gid))
	hxf1ae993.Cap = 0x7fffffff
	// hxf1ae993.Len = ?

	packSCmap(x.ToUnicode, x.ref9390f5cb.to_unicode)
	x.CidToUcsLen = (uint)(x.ref9390f5cb.cid_to_ucs_len)
	hxf250a52 := (*sliceHeader)(unsafe.Pointer(&x.CidToUcs))
	hxf250a52.Data = uintptr(unsafe.Pointer(x.ref9390f5cb.cid_to_ucs))
	hxf250a52.Cap = 0x7fffffff
	// hxf250a52.Len = ?

	x.Wmode = (int32)(x.ref9390f5cb.wmode)
	x.HmtxLen = (int32)(x.ref9390f5cb.hmtx_len)
	x.HmtxCap = (int32)(x.ref9390f5cb.hmtx_cap)
	x.Dhmtx = *NewHmtxRef(unsafe.Pointer(&x.ref9390f5cb.dhmtx))
	packSHmtx(x.Hmtx, x.ref9390f5cb.hmtx)
	x.VmtxLen = (int32)(x.ref9390f5cb.vmtx_len)
	x.VmtxCap = (int32)(x.ref9390f5cb.vmtx_cap)
	x.Dvmtx = *NewVmtxRef(unsafe.Pointer(&x.ref9390f5cb.dvmtx))
	packSVmtx(x.Vmtx, x.ref9390f5cb.vmtx)
	x.IsEmbedded = (int32)(x.ref9390f5cb.is_embedded)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Hmtx) Ref() *C.pdf_hmtx {
	if x == nil {
		return nil
	}
	return x.ref79755031
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Hmtx) Free() {
	if x != nil && x.allocs79755031 != nil {
		x.allocs79755031.(*cgoAllocMap).Free()
		x.ref79755031 = nil
	}
}

// NewHmtxRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewHmtxRef(ref unsafe.Pointer) *Hmtx {
	if ref == nil {
		return nil
	}
	obj := new(Hmtx)
	obj.ref79755031 = (*C.pdf_hmtx)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Hmtx) PassRef() (*C.pdf_hmtx, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref79755031 != nil {
		return x.ref79755031, nil
	}
	mem79755031 := allocHmtxMemory(1)
	ref79755031 := (*C.pdf_hmtx)(mem79755031)
	allocs79755031 := new(cgoAllocMap)
	allocs79755031.Add(mem79755031)

	var clo_allocs *cgoAllocMap
	ref79755031.lo, clo_allocs = (C.ushort)(x.Lo), cgoAllocsUnknown
	allocs79755031.Borrow(clo_allocs)

	var chi_allocs *cgoAllocMap
	ref79755031.hi, chi_allocs = (C.ushort)(x.Hi), cgoAllocsUnknown
	allocs79755031.Borrow(chi_allocs)

	var cw_allocs *cgoAllocMap
	ref79755031.w, cw_allocs = (C.int)(x.W), cgoAllocsUnknown
	allocs79755031.Borrow(cw_allocs)

	x.ref79755031 = ref79755031
	x.allocs79755031 = allocs79755031
	return ref79755031, allocs79755031

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Hmtx) PassValue() (C.pdf_hmtx, *cgoAllocMap) {
	if x.ref79755031 != nil {
		return *x.ref79755031, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Hmtx) Deref() {
	if x.ref79755031 == nil {
		return
	}
	x.Lo = (uint16)(x.ref79755031.lo)
	x.Hi = (uint16)(x.ref79755031.hi)
	x.W = (int32)(x.ref79755031.w)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Vmtx) Ref() *C.pdf_vmtx {
	if x == nil {
		return nil
	}
	return x.refc9b3709d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Vmtx) Free() {
	if x != nil && x.allocsc9b3709d != nil {
		x.allocsc9b3709d.(*cgoAllocMap).Free()
		x.refc9b3709d = nil
	}
}

// NewVmtxRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVmtxRef(ref unsafe.Pointer) *Vmtx {
	if ref == nil {
		return nil
	}
	obj := new(Vmtx)
	obj.refc9b3709d = (*C.pdf_vmtx)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Vmtx) PassRef() (*C.pdf_vmtx, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc9b3709d != nil {
		return x.refc9b3709d, nil
	}
	memc9b3709d := allocVmtxMemory(1)
	refc9b3709d := (*C.pdf_vmtx)(memc9b3709d)
	allocsc9b3709d := new(cgoAllocMap)
	allocsc9b3709d.Add(memc9b3709d)

	var clo_allocs *cgoAllocMap
	refc9b3709d.lo, clo_allocs = (C.ushort)(x.Lo), cgoAllocsUnknown
	allocsc9b3709d.Borrow(clo_allocs)

	var chi_allocs *cgoAllocMap
	refc9b3709d.hi, chi_allocs = (C.ushort)(x.Hi), cgoAllocsUnknown
	allocsc9b3709d.Borrow(chi_allocs)

	var cx_allocs *cgoAllocMap
	refc9b3709d.x, cx_allocs = (C.short)(x.X), cgoAllocsUnknown
	allocsc9b3709d.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refc9b3709d.y, cy_allocs = (C.short)(x.Y), cgoAllocsUnknown
	allocsc9b3709d.Borrow(cy_allocs)

	var cw_allocs *cgoAllocMap
	refc9b3709d.w, cw_allocs = (C.short)(x.W), cgoAllocsUnknown
	allocsc9b3709d.Borrow(cw_allocs)

	x.refc9b3709d = refc9b3709d
	x.allocsc9b3709d = allocsc9b3709d
	return refc9b3709d, allocsc9b3709d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Vmtx) PassValue() (C.pdf_vmtx, *cgoAllocMap) {
	if x.refc9b3709d != nil {
		return *x.refc9b3709d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Vmtx) Deref() {
	if x.refc9b3709d == nil {
		return
	}
	x.Lo = (uint16)(x.refc9b3709d.lo)
	x.Hi = (uint16)(x.refc9b3709d.hi)
	x.X = (int16)(x.refc9b3709d.x)
	x.Y = (int16)(x.refc9b3709d.y)
	x.W = (int16)(x.refc9b3709d.w)
}

// allocCsiMemory allocates memory for type C.pdf_csi in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCsiMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCsiValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCsiValue = unsafe.Sizeof([1]C.pdf_csi{})

// unpackSLexbuf transforms a sliced Go data structure into plain C format.
func unpackSLexbuf(x []Lexbuf) (unpacked *C.pdf_lexbuf, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_lexbuf) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocLexbufMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_lexbuf)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_lexbuf)(unsafe.Pointer(h.Data))
	return
}

// unpackSCookie transforms a sliced Go data structure into plain C format.
func unpackSCookie(x []Cookie) (unpacked *C.fz_cookie, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_cookie) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCookieMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_cookie)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_cookie)(unsafe.Pointer(h.Data))
	return
}

// packSLexbuf reads sliced Go data structure out from plain C format.
func packSLexbuf(v []Lexbuf, ptr0 *C.pdf_lexbuf) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfLexbufValue]C.pdf_lexbuf)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewLexbufRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Csi) Ref() *C.pdf_csi {
	if x == nil {
		return nil
	}
	return x.ref1d9059b0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Csi) Free() {
	if x != nil && x.allocs1d9059b0 != nil {
		x.allocs1d9059b0.(*cgoAllocMap).Free()
		x.ref1d9059b0 = nil
	}
}

// NewCsiRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCsiRef(ref unsafe.Pointer) *Csi {
	if ref == nil {
		return nil
	}
	obj := new(Csi)
	obj.ref1d9059b0 = (*C.pdf_csi)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Csi) PassRef() (*C.pdf_csi, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1d9059b0 != nil {
		return x.ref1d9059b0, nil
	}
	mem1d9059b0 := allocCsiMemory(1)
	ref1d9059b0 := (*C.pdf_csi)(mem1d9059b0)
	allocs1d9059b0 := new(cgoAllocMap)
	allocs1d9059b0.Add(mem1d9059b0)

	var cdoc_allocs *cgoAllocMap
	ref1d9059b0.doc, cdoc_allocs = unpackSDocument(x.Doc)
	allocs1d9059b0.Borrow(cdoc_allocs)

	var crdb_allocs *cgoAllocMap
	ref1d9059b0.rdb, crdb_allocs = (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Rdb)).Data)), cgoAllocsUnknown
	allocs1d9059b0.Borrow(crdb_allocs)

	var cbuf_allocs *cgoAllocMap
	ref1d9059b0.buf, cbuf_allocs = unpackSLexbuf(x.Buf)
	allocs1d9059b0.Borrow(cbuf_allocs)

	var ccookie_allocs *cgoAllocMap
	ref1d9059b0.cookie, ccookie_allocs = unpackSCookie(x.Cookie)
	allocs1d9059b0.Borrow(ccookie_allocs)

	var cgstate_allocs *cgoAllocMap
	ref1d9059b0.gstate, cgstate_allocs = (C.int)(x.Gstate), cgoAllocsUnknown
	allocs1d9059b0.Borrow(cgstate_allocs)

	var cxbalance_allocs *cgoAllocMap
	ref1d9059b0.xbalance, cxbalance_allocs = (C.int)(x.Xbalance), cgoAllocsUnknown
	allocs1d9059b0.Borrow(cxbalance_allocs)

	var cin_text_allocs *cgoAllocMap
	ref1d9059b0.in_text, cin_text_allocs = (C.int)(x.InText), cgoAllocsUnknown
	allocs1d9059b0.Borrow(cin_text_allocs)

	var cd1_rect_allocs *cgoAllocMap
	ref1d9059b0.d1_rect, cd1_rect_allocs = x.D1Rect.PassValue()
	allocs1d9059b0.Borrow(cd1_rect_allocs)

	var cobj_allocs *cgoAllocMap
	ref1d9059b0.obj, cobj_allocs = (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Obj)).Data)), cgoAllocsUnknown
	allocs1d9059b0.Borrow(cobj_allocs)

	var cname_allocs *cgoAllocMap
	ref1d9059b0.name, cname_allocs = *(*[256]C.char)(unsafe.Pointer(&x.Name)), cgoAllocsUnknown
	allocs1d9059b0.Borrow(cname_allocs)

	var cstring_allocs *cgoAllocMap
	ref1d9059b0.string, cstring_allocs = *(*[256]C.char)(unsafe.Pointer(&x.String)), cgoAllocsUnknown
	allocs1d9059b0.Borrow(cstring_allocs)

	var cstring_len_allocs *cgoAllocMap
	ref1d9059b0.string_len, cstring_len_allocs = (C.int)(x.StringLen), cgoAllocsUnknown
	allocs1d9059b0.Borrow(cstring_len_allocs)

	var ctop_allocs *cgoAllocMap
	ref1d9059b0.top, ctop_allocs = (C.int)(x.Top), cgoAllocsUnknown
	allocs1d9059b0.Borrow(ctop_allocs)

	var cstack_allocs *cgoAllocMap
	ref1d9059b0.stack, cstack_allocs = *(*[32]C.float)(unsafe.Pointer(&x.Stack)), cgoAllocsUnknown
	allocs1d9059b0.Borrow(cstack_allocs)

	x.ref1d9059b0 = ref1d9059b0
	x.allocs1d9059b0 = allocs1d9059b0
	return ref1d9059b0, allocs1d9059b0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Csi) PassValue() (C.pdf_csi, *cgoAllocMap) {
	if x.ref1d9059b0 != nil {
		return *x.ref1d9059b0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Csi) Deref() {
	if x.ref1d9059b0 == nil {
		return
	}
	packSDocument(x.Doc, x.ref1d9059b0.doc)
	hxfe21083 := (*sliceHeader)(unsafe.Pointer(&x.Rdb))
	hxfe21083.Data = uintptr(unsafe.Pointer(x.ref1d9059b0.rdb))
	hxfe21083.Cap = 0x7fffffff
	// hxfe21083.Len = ?

	packSLexbuf(x.Buf, x.ref1d9059b0.buf)
	packSCookie(x.Cookie, x.ref1d9059b0.cookie)
	x.Gstate = (int32)(x.ref1d9059b0.gstate)
	x.Xbalance = (int32)(x.ref1d9059b0.xbalance)
	x.InText = (int32)(x.ref1d9059b0.in_text)
	x.D1Rect = *NewRectRef(unsafe.Pointer(&x.ref1d9059b0.d1_rect))
	hxf9c9c15 := (*sliceHeader)(unsafe.Pointer(&x.Obj))
	hxf9c9c15.Data = uintptr(unsafe.Pointer(x.ref1d9059b0.obj))
	hxf9c9c15.Cap = 0x7fffffff
	// hxf9c9c15.Len = ?

	x.Name = *(*[256]byte)(unsafe.Pointer(&x.ref1d9059b0.name))
	x.String = *(*[256]byte)(unsafe.Pointer(&x.ref1d9059b0.string))
	x.StringLen = (int32)(x.ref1d9059b0.string_len)
	x.Top = (int32)(x.ref1d9059b0.top)
	x.Stack = *(*[32]float32)(unsafe.Pointer(&x.ref1d9059b0.stack))
}

// Ref returns a reference to C object as it is.
func (x *Gstate) Ref() *C.pdf_gstate {
	if x == nil {
		return nil
	}
	return (*C.pdf_gstate)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Gstate) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewGstateRef converts the C object reference into a raw struct reference without wrapping.
func NewGstateRef(ref unsafe.Pointer) *Gstate {
	return (*Gstate)(ref)
}

// NewGstate allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewGstate() *Gstate {
	return (*Gstate)(allocGstateMemory(1))
}

// allocGstateMemory allocates memory for type C.pdf_gstate in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGstateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGstateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfGstateValue = unsafe.Sizeof([1]C.pdf_gstate{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Gstate) PassRef() *C.pdf_gstate {
	if x == nil {
		x = (*Gstate)(allocGstateMemory(1))
	}
	return (*C.pdf_gstate)(unsafe.Pointer(x))
}

// allocProcessorMemory allocates memory for type C.pdf_processor in C.
// The caller is responsible for freeing the this memory via C.free.
func allocProcessorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfProcessorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfProcessorValue = unsafe.Sizeof([1]C.pdf_processor{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Processor) Ref() *C.pdf_processor {
	if x == nil {
		return nil
	}
	return x.refa163be31
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Processor) Free() {
	if x != nil && x.allocsa163be31 != nil {
		x.allocsa163be31.(*cgoAllocMap).Free()
		x.refa163be31 = nil
	}
}

// NewProcessorRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewProcessorRef(ref unsafe.Pointer) *Processor {
	if ref == nil {
		return nil
	}
	obj := new(Processor)
	obj.refa163be31 = (*C.pdf_processor)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Processor) PassRef() (*C.pdf_processor, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa163be31 != nil {
		return x.refa163be31, nil
	}
	mema163be31 := allocProcessorMemory(1)
	refa163be31 := (*C.pdf_processor)(mema163be31)
	allocsa163be31 := new(cgoAllocMap)
	allocsa163be31.Add(mema163be31)

	var cclose_processor_allocs *cgoAllocMap
	refa163be31.close_processor, cclose_processor_allocs = x.CloseProcessor.PassRef()
	allocsa163be31.Borrow(cclose_processor_allocs)

	var cdrop_processor_allocs *cgoAllocMap
	refa163be31.drop_processor, cdrop_processor_allocs = x.DropProcessor.PassRef()
	allocsa163be31.Borrow(cdrop_processor_allocs)

	var cop_w_allocs *cgoAllocMap
	refa163be31.op_w, cop_w_allocs = x.OpW.PassRef()
	allocsa163be31.Borrow(cop_w_allocs)

	var cop_j_allocs *cgoAllocMap
	refa163be31.op_j, cop_j_allocs = x.OpJ.PassRef()
	allocsa163be31.Borrow(cop_j_allocs)

	var cop_J_allocs *cgoAllocMap
	refa163be31.op_J, cop_J_allocs = x.OpJ.PassRef()
	allocsa163be31.Borrow(cop_J_allocs)

	var cop_M_allocs *cgoAllocMap
	refa163be31.op_M, cop_M_allocs = x.OpM.PassRef()
	allocsa163be31.Borrow(cop_M_allocs)

	var cop_d_allocs *cgoAllocMap
	refa163be31.op_d, cop_d_allocs = x.OpD.PassRef()
	allocsa163be31.Borrow(cop_d_allocs)

	var cop_ri_allocs *cgoAllocMap
	refa163be31.op_ri, cop_ri_allocs = x.OpRi.PassRef()
	allocsa163be31.Borrow(cop_ri_allocs)

	var cop_i_allocs *cgoAllocMap
	refa163be31.op_i, cop_i_allocs = x.OpI.PassRef()
	allocsa163be31.Borrow(cop_i_allocs)

	var cop_gs_begin_allocs *cgoAllocMap
	refa163be31.op_gs_begin, cop_gs_begin_allocs = x.OpGsBegin.PassRef()
	allocsa163be31.Borrow(cop_gs_begin_allocs)

	var cop_gs_BM_allocs *cgoAllocMap
	refa163be31.op_gs_BM, cop_gs_BM_allocs = x.OpGsBm.PassRef()
	allocsa163be31.Borrow(cop_gs_BM_allocs)

	var cop_gs_ca_allocs *cgoAllocMap
	refa163be31.op_gs_ca, cop_gs_ca_allocs = x.OpGsCa.PassRef()
	allocsa163be31.Borrow(cop_gs_ca_allocs)

	var cop_gs_CA_allocs *cgoAllocMap
	refa163be31.op_gs_CA, cop_gs_CA_allocs = x.OpGsCa.PassRef()
	allocsa163be31.Borrow(cop_gs_CA_allocs)

	var cop_gs_SMask_allocs *cgoAllocMap
	refa163be31.op_gs_SMask, cop_gs_SMask_allocs = x.OpGsSmask.PassRef()
	allocsa163be31.Borrow(cop_gs_SMask_allocs)

	var cop_gs_end_allocs *cgoAllocMap
	refa163be31.op_gs_end, cop_gs_end_allocs = x.OpGsEnd.PassRef()
	allocsa163be31.Borrow(cop_gs_end_allocs)

	var cop_q_allocs *cgoAllocMap
	refa163be31.op_q, cop_q_allocs = x.OpQ.PassRef()
	allocsa163be31.Borrow(cop_q_allocs)

	var cop_Q_allocs *cgoAllocMap
	refa163be31.op_Q, cop_Q_allocs = x.OpQ.PassRef()
	allocsa163be31.Borrow(cop_Q_allocs)

	var cop_cm_allocs *cgoAllocMap
	refa163be31.op_cm, cop_cm_allocs = x.OpCm.PassRef()
	allocsa163be31.Borrow(cop_cm_allocs)

	var cop_m_allocs *cgoAllocMap
	refa163be31.op_m, cop_m_allocs = x.OpM.PassRef()
	allocsa163be31.Borrow(cop_m_allocs)

	var cop_l_allocs *cgoAllocMap
	refa163be31.op_l, cop_l_allocs = x.OpL.PassRef()
	allocsa163be31.Borrow(cop_l_allocs)

	var cop_c_allocs *cgoAllocMap
	refa163be31.op_c, cop_c_allocs = x.OpC.PassRef()
	allocsa163be31.Borrow(cop_c_allocs)

	var cop_v_allocs *cgoAllocMap
	refa163be31.op_v, cop_v_allocs = x.OpV.PassRef()
	allocsa163be31.Borrow(cop_v_allocs)

	var cop_y_allocs *cgoAllocMap
	refa163be31.op_y, cop_y_allocs = x.OpY.PassRef()
	allocsa163be31.Borrow(cop_y_allocs)

	var cop_h_allocs *cgoAllocMap
	refa163be31.op_h, cop_h_allocs = x.OpH.PassRef()
	allocsa163be31.Borrow(cop_h_allocs)

	var cop_re_allocs *cgoAllocMap
	refa163be31.op_re, cop_re_allocs = x.OpRe.PassRef()
	allocsa163be31.Borrow(cop_re_allocs)

	var cop_S_allocs *cgoAllocMap
	refa163be31.op_S, cop_S_allocs = x.OpS.PassRef()
	allocsa163be31.Borrow(cop_S_allocs)

	var cop_s_allocs *cgoAllocMap
	refa163be31.op_s, cop_s_allocs = x.OpS.PassRef()
	allocsa163be31.Borrow(cop_s_allocs)

	var cop_F_allocs *cgoAllocMap
	refa163be31.op_F, cop_F_allocs = x.OpF.PassRef()
	allocsa163be31.Borrow(cop_F_allocs)

	var cop_f_allocs *cgoAllocMap
	refa163be31.op_f, cop_f_allocs = x.OpF.PassRef()
	allocsa163be31.Borrow(cop_f_allocs)

	var cop_fstar_allocs *cgoAllocMap
	refa163be31.op_fstar, cop_fstar_allocs = x.OpFstar.PassRef()
	allocsa163be31.Borrow(cop_fstar_allocs)

	var cop_B_allocs *cgoAllocMap
	refa163be31.op_B, cop_B_allocs = x.OpB.PassRef()
	allocsa163be31.Borrow(cop_B_allocs)

	var cop_Bstar_allocs *cgoAllocMap
	refa163be31.op_Bstar, cop_Bstar_allocs = x.OpBstar.PassRef()
	allocsa163be31.Borrow(cop_Bstar_allocs)

	var cop_b_allocs *cgoAllocMap
	refa163be31.op_b, cop_b_allocs = x.OpB.PassRef()
	allocsa163be31.Borrow(cop_b_allocs)

	var cop_bstar_allocs *cgoAllocMap
	refa163be31.op_bstar, cop_bstar_allocs = x.OpBstar.PassRef()
	allocsa163be31.Borrow(cop_bstar_allocs)

	var cop_n_allocs *cgoAllocMap
	refa163be31.op_n, cop_n_allocs = x.OpN.PassRef()
	allocsa163be31.Borrow(cop_n_allocs)

	var cop_W_allocs *cgoAllocMap
	refa163be31.op_W, cop_W_allocs = x.OpW.PassRef()
	allocsa163be31.Borrow(cop_W_allocs)

	var cop_Wstar_allocs *cgoAllocMap
	refa163be31.op_Wstar, cop_Wstar_allocs = x.OpWstar.PassRef()
	allocsa163be31.Borrow(cop_Wstar_allocs)

	var cop_BT_allocs *cgoAllocMap
	refa163be31.op_BT, cop_BT_allocs = x.OpBt.PassRef()
	allocsa163be31.Borrow(cop_BT_allocs)

	var cop_ET_allocs *cgoAllocMap
	refa163be31.op_ET, cop_ET_allocs = x.OpEt.PassRef()
	allocsa163be31.Borrow(cop_ET_allocs)

	var cop_Tc_allocs *cgoAllocMap
	refa163be31.op_Tc, cop_Tc_allocs = x.OpTc.PassRef()
	allocsa163be31.Borrow(cop_Tc_allocs)

	var cop_Tw_allocs *cgoAllocMap
	refa163be31.op_Tw, cop_Tw_allocs = x.OpTw.PassRef()
	allocsa163be31.Borrow(cop_Tw_allocs)

	var cop_Tz_allocs *cgoAllocMap
	refa163be31.op_Tz, cop_Tz_allocs = x.OpTz.PassRef()
	allocsa163be31.Borrow(cop_Tz_allocs)

	var cop_TL_allocs *cgoAllocMap
	refa163be31.op_TL, cop_TL_allocs = x.OpTl.PassRef()
	allocsa163be31.Borrow(cop_TL_allocs)

	var cop_Tf_allocs *cgoAllocMap
	refa163be31.op_Tf, cop_Tf_allocs = x.OpTf.PassRef()
	allocsa163be31.Borrow(cop_Tf_allocs)

	var cop_Tr_allocs *cgoAllocMap
	refa163be31.op_Tr, cop_Tr_allocs = x.OpTr.PassRef()
	allocsa163be31.Borrow(cop_Tr_allocs)

	var cop_Ts_allocs *cgoAllocMap
	refa163be31.op_Ts, cop_Ts_allocs = x.OpTs.PassRef()
	allocsa163be31.Borrow(cop_Ts_allocs)

	var cop_Td_allocs *cgoAllocMap
	refa163be31.op_Td, cop_Td_allocs = x.OpTd.PassRef()
	allocsa163be31.Borrow(cop_Td_allocs)

	var cop_TD_allocs *cgoAllocMap
	refa163be31.op_TD, cop_TD_allocs = x.OpTd.PassRef()
	allocsa163be31.Borrow(cop_TD_allocs)

	var cop_Tm_allocs *cgoAllocMap
	refa163be31.op_Tm, cop_Tm_allocs = x.OpTm.PassRef()
	allocsa163be31.Borrow(cop_Tm_allocs)

	var cop_Tstar_allocs *cgoAllocMap
	refa163be31.op_Tstar, cop_Tstar_allocs = x.OpTstar.PassRef()
	allocsa163be31.Borrow(cop_Tstar_allocs)

	var cop_TJ_allocs *cgoAllocMap
	refa163be31.op_TJ, cop_TJ_allocs = x.OpTj.PassRef()
	allocsa163be31.Borrow(cop_TJ_allocs)

	var cop_Tj_allocs *cgoAllocMap
	refa163be31.op_Tj, cop_Tj_allocs = x.OpTj.PassRef()
	allocsa163be31.Borrow(cop_Tj_allocs)

	var cop_squote_allocs *cgoAllocMap
	refa163be31.op_squote, cop_squote_allocs = x.OpSquote.PassRef()
	allocsa163be31.Borrow(cop_squote_allocs)

	var cop_dquote_allocs *cgoAllocMap
	refa163be31.op_dquote, cop_dquote_allocs = x.OpDquote.PassRef()
	allocsa163be31.Borrow(cop_dquote_allocs)

	var cop_d0_allocs *cgoAllocMap
	refa163be31.op_d0, cop_d0_allocs = x.OpD0.PassRef()
	allocsa163be31.Borrow(cop_d0_allocs)

	var cop_d1_allocs *cgoAllocMap
	refa163be31.op_d1, cop_d1_allocs = x.OpD1.PassRef()
	allocsa163be31.Borrow(cop_d1_allocs)

	var cop_CS_allocs *cgoAllocMap
	refa163be31.op_CS, cop_CS_allocs = x.OpCs.PassRef()
	allocsa163be31.Borrow(cop_CS_allocs)

	var cop_cs_allocs *cgoAllocMap
	refa163be31.op_cs, cop_cs_allocs = x.OpCs.PassRef()
	allocsa163be31.Borrow(cop_cs_allocs)

	var cop_SC_pattern_allocs *cgoAllocMap
	refa163be31.op_SC_pattern, cop_SC_pattern_allocs = x.OpScPattern.PassRef()
	allocsa163be31.Borrow(cop_SC_pattern_allocs)

	var cop_sc_pattern_allocs *cgoAllocMap
	refa163be31.op_sc_pattern, cop_sc_pattern_allocs = x.OpScPattern.PassRef()
	allocsa163be31.Borrow(cop_sc_pattern_allocs)

	var cop_SC_shade_allocs *cgoAllocMap
	refa163be31.op_SC_shade, cop_SC_shade_allocs = x.OpScShade.PassRef()
	allocsa163be31.Borrow(cop_SC_shade_allocs)

	var cop_sc_shade_allocs *cgoAllocMap
	refa163be31.op_sc_shade, cop_sc_shade_allocs = x.OpScShade.PassRef()
	allocsa163be31.Borrow(cop_sc_shade_allocs)

	var cop_SC_color_allocs *cgoAllocMap
	refa163be31.op_SC_color, cop_SC_color_allocs = x.OpScColor.PassRef()
	allocsa163be31.Borrow(cop_SC_color_allocs)

	var cop_sc_color_allocs *cgoAllocMap
	refa163be31.op_sc_color, cop_sc_color_allocs = x.OpScColor.PassRef()
	allocsa163be31.Borrow(cop_sc_color_allocs)

	var cop_G_allocs *cgoAllocMap
	refa163be31.op_G, cop_G_allocs = x.OpG.PassRef()
	allocsa163be31.Borrow(cop_G_allocs)

	var cop_g_allocs *cgoAllocMap
	refa163be31.op_g, cop_g_allocs = x.OpG.PassRef()
	allocsa163be31.Borrow(cop_g_allocs)

	var cop_RG_allocs *cgoAllocMap
	refa163be31.op_RG, cop_RG_allocs = x.OpRg.PassRef()
	allocsa163be31.Borrow(cop_RG_allocs)

	var cop_rg_allocs *cgoAllocMap
	refa163be31.op_rg, cop_rg_allocs = x.OpRg.PassRef()
	allocsa163be31.Borrow(cop_rg_allocs)

	var cop_K_allocs *cgoAllocMap
	refa163be31.op_K, cop_K_allocs = x.OpK.PassRef()
	allocsa163be31.Borrow(cop_K_allocs)

	var cop_k_allocs *cgoAllocMap
	refa163be31.op_k, cop_k_allocs = x.OpK.PassRef()
	allocsa163be31.Borrow(cop_k_allocs)

	var cop_BI_allocs *cgoAllocMap
	refa163be31.op_BI, cop_BI_allocs = x.OpBi.PassRef()
	allocsa163be31.Borrow(cop_BI_allocs)

	var cop_sh_allocs *cgoAllocMap
	refa163be31.op_sh, cop_sh_allocs = x.OpSh.PassRef()
	allocsa163be31.Borrow(cop_sh_allocs)

	var cop_Do_image_allocs *cgoAllocMap
	refa163be31.op_Do_image, cop_Do_image_allocs = x.OpDoImage.PassRef()
	allocsa163be31.Borrow(cop_Do_image_allocs)

	var cop_Do_form_allocs *cgoAllocMap
	refa163be31.op_Do_form, cop_Do_form_allocs = x.OpDoForm.PassRef()
	allocsa163be31.Borrow(cop_Do_form_allocs)

	var cop_MP_allocs *cgoAllocMap
	refa163be31.op_MP, cop_MP_allocs = x.OpMp.PassRef()
	allocsa163be31.Borrow(cop_MP_allocs)

	var cop_DP_allocs *cgoAllocMap
	refa163be31.op_DP, cop_DP_allocs = x.OpDp.PassRef()
	allocsa163be31.Borrow(cop_DP_allocs)

	var cop_BMC_allocs *cgoAllocMap
	refa163be31.op_BMC, cop_BMC_allocs = x.OpBmc.PassRef()
	allocsa163be31.Borrow(cop_BMC_allocs)

	var cop_BDC_allocs *cgoAllocMap
	refa163be31.op_BDC, cop_BDC_allocs = x.OpBdc.PassRef()
	allocsa163be31.Borrow(cop_BDC_allocs)

	var cop_EMC_allocs *cgoAllocMap
	refa163be31.op_EMC, cop_EMC_allocs = x.OpEmc.PassRef()
	allocsa163be31.Borrow(cop_EMC_allocs)

	var cop_BX_allocs *cgoAllocMap
	refa163be31.op_BX, cop_BX_allocs = x.OpBx.PassRef()
	allocsa163be31.Borrow(cop_BX_allocs)

	var cop_EX_allocs *cgoAllocMap
	refa163be31.op_EX, cop_EX_allocs = x.OpEx.PassRef()
	allocsa163be31.Borrow(cop_EX_allocs)

	var cop_gs_OP_allocs *cgoAllocMap
	refa163be31.op_gs_OP, cop_gs_OP_allocs = x.OpGsOp.PassRef()
	allocsa163be31.Borrow(cop_gs_OP_allocs)

	var cop_gs_op_allocs *cgoAllocMap
	refa163be31.op_gs_op, cop_gs_op_allocs = x.OpGsOp.PassRef()
	allocsa163be31.Borrow(cop_gs_op_allocs)

	var cop_gs_OPM_allocs *cgoAllocMap
	refa163be31.op_gs_OPM, cop_gs_OPM_allocs = x.OpGsOpm.PassRef()
	allocsa163be31.Borrow(cop_gs_OPM_allocs)

	var cop_gs_UseBlackPtComp_allocs *cgoAllocMap
	refa163be31.op_gs_UseBlackPtComp, cop_gs_UseBlackPtComp_allocs = x.OpGsUseblackptcomp.PassRef()
	allocsa163be31.Borrow(cop_gs_UseBlackPtComp_allocs)

	var cop_END_allocs *cgoAllocMap
	refa163be31.op_END, cop_END_allocs = x.OpEnd.PassRef()
	allocsa163be31.Borrow(cop_END_allocs)

	var cusage_allocs *cgoAllocMap
	refa163be31.usage, cusage_allocs = unpackPCharString(x.Usage)
	allocsa163be31.Borrow(cusage_allocs)

	var chidden_allocs *cgoAllocMap
	refa163be31.hidden, chidden_allocs = (C.int)(x.Hidden), cgoAllocsUnknown
	allocsa163be31.Borrow(chidden_allocs)

	x.refa163be31 = refa163be31
	x.allocsa163be31 = allocsa163be31
	return refa163be31, allocsa163be31

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Processor) PassValue() (C.pdf_processor, *cgoAllocMap) {
	if x.refa163be31 != nil {
		return *x.refa163be31, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Processor) Deref() {
	if x.refa163be31 == nil {
		return
	}
	x.CloseProcessor = NewRef(unsafe.Pointer(x.refa163be31.close_processor))
	x.DropProcessor = NewRef(unsafe.Pointer(x.refa163be31.drop_processor))
	x.OpW = NewRef(unsafe.Pointer(x.refa163be31.op_w))
	x.OpJ = NewRef(unsafe.Pointer(x.refa163be31.op_j))
	x.OpJ = NewRef(unsafe.Pointer(x.refa163be31.op_J))
	x.OpM = NewRef(unsafe.Pointer(x.refa163be31.op_M))
	x.OpD = NewRef(unsafe.Pointer(x.refa163be31.op_d))
	x.OpRi = NewRef(unsafe.Pointer(x.refa163be31.op_ri))
	x.OpI = NewRef(unsafe.Pointer(x.refa163be31.op_i))
	x.OpGsBegin = NewRef(unsafe.Pointer(x.refa163be31.op_gs_begin))
	x.OpGsBm = NewRef(unsafe.Pointer(x.refa163be31.op_gs_BM))
	x.OpGsCa = NewRef(unsafe.Pointer(x.refa163be31.op_gs_ca))
	x.OpGsCa = NewRef(unsafe.Pointer(x.refa163be31.op_gs_CA))
	x.OpGsSmask = NewRef(unsafe.Pointer(x.refa163be31.op_gs_SMask))
	x.OpGsEnd = NewRef(unsafe.Pointer(x.refa163be31.op_gs_end))
	x.OpQ = NewRef(unsafe.Pointer(x.refa163be31.op_q))
	x.OpQ = NewRef(unsafe.Pointer(x.refa163be31.op_Q))
	x.OpCm = NewRef(unsafe.Pointer(x.refa163be31.op_cm))
	x.OpM = NewRef(unsafe.Pointer(x.refa163be31.op_m))
	x.OpL = NewRef(unsafe.Pointer(x.refa163be31.op_l))
	x.OpC = NewRef(unsafe.Pointer(x.refa163be31.op_c))
	x.OpV = NewRef(unsafe.Pointer(x.refa163be31.op_v))
	x.OpY = NewRef(unsafe.Pointer(x.refa163be31.op_y))
	x.OpH = NewRef(unsafe.Pointer(x.refa163be31.op_h))
	x.OpRe = NewRef(unsafe.Pointer(x.refa163be31.op_re))
	x.OpS = NewRef(unsafe.Pointer(x.refa163be31.op_S))
	x.OpS = NewRef(unsafe.Pointer(x.refa163be31.op_s))
	x.OpF = NewRef(unsafe.Pointer(x.refa163be31.op_F))
	x.OpF = NewRef(unsafe.Pointer(x.refa163be31.op_f))
	x.OpFstar = NewRef(unsafe.Pointer(x.refa163be31.op_fstar))
	x.OpB = NewRef(unsafe.Pointer(x.refa163be31.op_B))
	x.OpBstar = NewRef(unsafe.Pointer(x.refa163be31.op_Bstar))
	x.OpB = NewRef(unsafe.Pointer(x.refa163be31.op_b))
	x.OpBstar = NewRef(unsafe.Pointer(x.refa163be31.op_bstar))
	x.OpN = NewRef(unsafe.Pointer(x.refa163be31.op_n))
	x.OpW = NewRef(unsafe.Pointer(x.refa163be31.op_W))
	x.OpWstar = NewRef(unsafe.Pointer(x.refa163be31.op_Wstar))
	x.OpBt = NewRef(unsafe.Pointer(x.refa163be31.op_BT))
	x.OpEt = NewRef(unsafe.Pointer(x.refa163be31.op_ET))
	x.OpTc = NewRef(unsafe.Pointer(x.refa163be31.op_Tc))
	x.OpTw = NewRef(unsafe.Pointer(x.refa163be31.op_Tw))
	x.OpTz = NewRef(unsafe.Pointer(x.refa163be31.op_Tz))
	x.OpTl = NewRef(unsafe.Pointer(x.refa163be31.op_TL))
	x.OpTf = NewRef(unsafe.Pointer(x.refa163be31.op_Tf))
	x.OpTr = NewRef(unsafe.Pointer(x.refa163be31.op_Tr))
	x.OpTs = NewRef(unsafe.Pointer(x.refa163be31.op_Ts))
	x.OpTd = NewRef(unsafe.Pointer(x.refa163be31.op_Td))
	x.OpTd = NewRef(unsafe.Pointer(x.refa163be31.op_TD))
	x.OpTm = NewRef(unsafe.Pointer(x.refa163be31.op_Tm))
	x.OpTstar = NewRef(unsafe.Pointer(x.refa163be31.op_Tstar))
	x.OpTj = NewRef(unsafe.Pointer(x.refa163be31.op_TJ))
	x.OpTj = NewRef(unsafe.Pointer(x.refa163be31.op_Tj))
	x.OpSquote = NewRef(unsafe.Pointer(x.refa163be31.op_squote))
	x.OpDquote = NewRef(unsafe.Pointer(x.refa163be31.op_dquote))
	x.OpD0 = NewRef(unsafe.Pointer(x.refa163be31.op_d0))
	x.OpD1 = NewRef(unsafe.Pointer(x.refa163be31.op_d1))
	x.OpCs = NewRef(unsafe.Pointer(x.refa163be31.op_CS))
	x.OpCs = NewRef(unsafe.Pointer(x.refa163be31.op_cs))
	x.OpScPattern = NewRef(unsafe.Pointer(x.refa163be31.op_SC_pattern))
	x.OpScPattern = NewRef(unsafe.Pointer(x.refa163be31.op_sc_pattern))
	x.OpScShade = NewRef(unsafe.Pointer(x.refa163be31.op_SC_shade))
	x.OpScShade = NewRef(unsafe.Pointer(x.refa163be31.op_sc_shade))
	x.OpScColor = NewRef(unsafe.Pointer(x.refa163be31.op_SC_color))
	x.OpScColor = NewRef(unsafe.Pointer(x.refa163be31.op_sc_color))
	x.OpG = NewRef(unsafe.Pointer(x.refa163be31.op_G))
	x.OpG = NewRef(unsafe.Pointer(x.refa163be31.op_g))
	x.OpRg = NewRef(unsafe.Pointer(x.refa163be31.op_RG))
	x.OpRg = NewRef(unsafe.Pointer(x.refa163be31.op_rg))
	x.OpK = NewRef(unsafe.Pointer(x.refa163be31.op_K))
	x.OpK = NewRef(unsafe.Pointer(x.refa163be31.op_k))
	x.OpBi = NewRef(unsafe.Pointer(x.refa163be31.op_BI))
	x.OpSh = NewRef(unsafe.Pointer(x.refa163be31.op_sh))
	x.OpDoImage = NewRef(unsafe.Pointer(x.refa163be31.op_Do_image))
	x.OpDoForm = NewRef(unsafe.Pointer(x.refa163be31.op_Do_form))
	x.OpMp = NewRef(unsafe.Pointer(x.refa163be31.op_MP))
	x.OpDp = NewRef(unsafe.Pointer(x.refa163be31.op_DP))
	x.OpBmc = NewRef(unsafe.Pointer(x.refa163be31.op_BMC))
	x.OpBdc = NewRef(unsafe.Pointer(x.refa163be31.op_BDC))
	x.OpEmc = NewRef(unsafe.Pointer(x.refa163be31.op_EMC))
	x.OpBx = NewRef(unsafe.Pointer(x.refa163be31.op_BX))
	x.OpEx = NewRef(unsafe.Pointer(x.refa163be31.op_EX))
	x.OpGsOp = NewRef(unsafe.Pointer(x.refa163be31.op_gs_OP))
	x.OpGsOp = NewRef(unsafe.Pointer(x.refa163be31.op_gs_op))
	x.OpGsOpm = NewRef(unsafe.Pointer(x.refa163be31.op_gs_OPM))
	x.OpGsUseblackptcomp = NewRef(unsafe.Pointer(x.refa163be31.op_gs_UseBlackPtComp))
	x.OpEnd = NewRef(unsafe.Pointer(x.refa163be31.op_END))
	x.Usage = packPCharString(x.refa163be31.usage)
	x.Hidden = (int32)(x.refa163be31.hidden)
}

// allocDaInfoMemory allocates memory for type C.pdf_da_info in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDaInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDaInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDaInfoValue = unsafe.Sizeof([1]C.pdf_da_info{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DaInfo) Ref() *C.pdf_da_info {
	if x == nil {
		return nil
	}
	return x.ref2095c09
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DaInfo) Free() {
	if x != nil && x.allocs2095c09 != nil {
		x.allocs2095c09.(*cgoAllocMap).Free()
		x.ref2095c09 = nil
	}
}

// NewDaInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDaInfoRef(ref unsafe.Pointer) *DaInfo {
	if ref == nil {
		return nil
	}
	obj := new(DaInfo)
	obj.ref2095c09 = (*C.pdf_da_info)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DaInfo) PassRef() (*C.pdf_da_info, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2095c09 != nil {
		return x.ref2095c09, nil
	}
	mem2095c09 := allocDaInfoMemory(1)
	ref2095c09 := (*C.pdf_da_info)(mem2095c09)
	allocs2095c09 := new(cgoAllocMap)
	allocs2095c09.Add(mem2095c09)

	var cfont_name_allocs *cgoAllocMap
	ref2095c09.font_name, cfont_name_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.FontName)).Data)), cgoAllocsUnknown
	allocs2095c09.Borrow(cfont_name_allocs)

	var cfont_size_allocs *cgoAllocMap
	ref2095c09.font_size, cfont_size_allocs = (C.int)(x.FontSize), cgoAllocsUnknown
	allocs2095c09.Borrow(cfont_size_allocs)

	var ccol_allocs *cgoAllocMap
	ref2095c09.col, ccol_allocs = *(*[4]C.float)(unsafe.Pointer(&x.Col)), cgoAllocsUnknown
	allocs2095c09.Borrow(ccol_allocs)

	var ccol_size_allocs *cgoAllocMap
	ref2095c09.col_size, ccol_size_allocs = (C.int)(x.ColSize), cgoAllocsUnknown
	allocs2095c09.Borrow(ccol_size_allocs)

	x.ref2095c09 = ref2095c09
	x.allocs2095c09 = allocs2095c09
	return ref2095c09, allocs2095c09

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DaInfo) PassValue() (C.pdf_da_info, *cgoAllocMap) {
	if x.ref2095c09 != nil {
		return *x.ref2095c09, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DaInfo) Deref() {
	if x.ref2095c09 == nil {
		return
	}
	hxfa3a85e := (*sliceHeader)(unsafe.Pointer(&x.FontName))
	hxfa3a85e.Data = uintptr(unsafe.Pointer(x.ref2095c09.font_name))
	hxfa3a85e.Cap = 0x7fffffff
	// hxfa3a85e.Len = ?

	x.FontSize = (int32)(x.ref2095c09.font_size)
	x.Col = *(*[4]float32)(unsafe.Pointer(&x.ref2095c09.col))
	x.ColSize = (int32)(x.ref2095c09.col_size)
}

// allocUiEventMemory allocates memory for type C.pdf_ui_event in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUiEventMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUiEventValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfUiEventValue = unsafe.Sizeof([1]C.pdf_ui_event{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *UiEvent) Ref() *C.pdf_ui_event {
	if x == nil {
		return nil
	}
	return x.ref344a89eb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *UiEvent) Free() {
	if x != nil && x.allocs344a89eb != nil {
		x.allocs344a89eb.(*cgoAllocMap).Free()
		x.ref344a89eb = nil
	}
}

// NewUiEventRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUiEventRef(ref unsafe.Pointer) *UiEvent {
	if ref == nil {
		return nil
	}
	obj := new(UiEvent)
	obj.ref344a89eb = (*C.pdf_ui_event)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *UiEvent) PassRef() (*C.pdf_ui_event, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref344a89eb != nil {
		return x.ref344a89eb, nil
	}
	mem344a89eb := allocUiEventMemory(1)
	ref344a89eb := (*C.pdf_ui_event)(mem344a89eb)
	allocs344a89eb := new(cgoAllocMap)
	allocs344a89eb.Add(mem344a89eb)

	var cetype_allocs *cgoAllocMap
	ref344a89eb.etype, cetype_allocs = (C.int)(x.Etype), cgoAllocsUnknown
	allocs344a89eb.Borrow(cetype_allocs)

	x.ref344a89eb = ref344a89eb
	x.allocs344a89eb = allocs344a89eb
	return ref344a89eb, allocs344a89eb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x UiEvent) PassValue() (C.pdf_ui_event, *cgoAllocMap) {
	if x.ref344a89eb != nil {
		return *x.ref344a89eb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *UiEvent) Deref() {
	if x.ref344a89eb == nil {
		return
	}
	x.Etype = (int32)(x.ref344a89eb.etype)
}

// allocAlertEventMemory allocates memory for type C.pdf_alert_event in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAlertEventMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAlertEventValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAlertEventValue = unsafe.Sizeof([1]C.pdf_alert_event{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AlertEvent) Ref() *C.pdf_alert_event {
	if x == nil {
		return nil
	}
	return x.ref1e745527
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AlertEvent) Free() {
	if x != nil && x.allocs1e745527 != nil {
		x.allocs1e745527.(*cgoAllocMap).Free()
		x.ref1e745527 = nil
	}
}

// NewAlertEventRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAlertEventRef(ref unsafe.Pointer) *AlertEvent {
	if ref == nil {
		return nil
	}
	obj := new(AlertEvent)
	obj.ref1e745527 = (*C.pdf_alert_event)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AlertEvent) PassRef() (*C.pdf_alert_event, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1e745527 != nil {
		return x.ref1e745527, nil
	}
	mem1e745527 := allocAlertEventMemory(1)
	ref1e745527 := (*C.pdf_alert_event)(mem1e745527)
	allocs1e745527 := new(cgoAllocMap)
	allocs1e745527.Add(mem1e745527)

	var cmessage_allocs *cgoAllocMap
	ref1e745527.message, cmessage_allocs = unpackPCharString(x.Message)
	allocs1e745527.Borrow(cmessage_allocs)

	var cicon_type_allocs *cgoAllocMap
	ref1e745527.icon_type, cicon_type_allocs = (C.int)(x.IconType), cgoAllocsUnknown
	allocs1e745527.Borrow(cicon_type_allocs)

	var cbutton_group_type_allocs *cgoAllocMap
	ref1e745527.button_group_type, cbutton_group_type_allocs = (C.int)(x.ButtonGroupType), cgoAllocsUnknown
	allocs1e745527.Borrow(cbutton_group_type_allocs)

	var ctitle_allocs *cgoAllocMap
	ref1e745527.title, ctitle_allocs = unpackPCharString(x.Title)
	allocs1e745527.Borrow(ctitle_allocs)

	var ccheck_box_message_allocs *cgoAllocMap
	ref1e745527.check_box_message, ccheck_box_message_allocs = unpackPCharString(x.CheckBoxMessage)
	allocs1e745527.Borrow(ccheck_box_message_allocs)

	var cinitially_checked_allocs *cgoAllocMap
	ref1e745527.initially_checked, cinitially_checked_allocs = (C.int)(x.InitiallyChecked), cgoAllocsUnknown
	allocs1e745527.Borrow(cinitially_checked_allocs)

	var cfinally_checked_allocs *cgoAllocMap
	ref1e745527.finally_checked, cfinally_checked_allocs = (C.int)(x.FinallyChecked), cgoAllocsUnknown
	allocs1e745527.Borrow(cfinally_checked_allocs)

	var cbutton_pressed_allocs *cgoAllocMap
	ref1e745527.button_pressed, cbutton_pressed_allocs = (C.int)(x.ButtonPressed), cgoAllocsUnknown
	allocs1e745527.Borrow(cbutton_pressed_allocs)

	x.ref1e745527 = ref1e745527
	x.allocs1e745527 = allocs1e745527
	return ref1e745527, allocs1e745527

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AlertEvent) PassValue() (C.pdf_alert_event, *cgoAllocMap) {
	if x.ref1e745527 != nil {
		return *x.ref1e745527, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AlertEvent) Deref() {
	if x.ref1e745527 == nil {
		return
	}
	x.Message = packPCharString(x.ref1e745527.message)
	x.IconType = (int32)(x.ref1e745527.icon_type)
	x.ButtonGroupType = (int32)(x.ref1e745527.button_group_type)
	x.Title = packPCharString(x.ref1e745527.title)
	x.CheckBoxMessage = packPCharString(x.ref1e745527.check_box_message)
	x.InitiallyChecked = (int32)(x.ref1e745527.initially_checked)
	x.FinallyChecked = (int32)(x.ref1e745527.finally_checked)
	x.ButtonPressed = (int32)(x.ref1e745527.button_pressed)
}

// allocSubmitEventMemory allocates memory for type C.pdf_submit_event in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSubmitEventMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSubmitEventValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSubmitEventValue = unsafe.Sizeof([1]C.pdf_submit_event{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SubmitEvent) Ref() *C.pdf_submit_event {
	if x == nil {
		return nil
	}
	return x.refd232e92c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SubmitEvent) Free() {
	if x != nil && x.allocsd232e92c != nil {
		x.allocsd232e92c.(*cgoAllocMap).Free()
		x.refd232e92c = nil
	}
}

// NewSubmitEventRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSubmitEventRef(ref unsafe.Pointer) *SubmitEvent {
	if ref == nil {
		return nil
	}
	obj := new(SubmitEvent)
	obj.refd232e92c = (*C.pdf_submit_event)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SubmitEvent) PassRef() (*C.pdf_submit_event, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd232e92c != nil {
		return x.refd232e92c, nil
	}
	memd232e92c := allocSubmitEventMemory(1)
	refd232e92c := (*C.pdf_submit_event)(memd232e92c)
	allocsd232e92c := new(cgoAllocMap)
	allocsd232e92c.Add(memd232e92c)

	var curl_allocs *cgoAllocMap
	refd232e92c.url, curl_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Url)).Data)), cgoAllocsUnknown
	allocsd232e92c.Borrow(curl_allocs)

	var cdata_allocs *cgoAllocMap
	refd232e92c.data, cdata_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Data)).Data)), cgoAllocsUnknown
	allocsd232e92c.Borrow(cdata_allocs)

	var cdata_len_allocs *cgoAllocMap
	refd232e92c.data_len, cdata_len_allocs = (C.int)(x.DataLen), cgoAllocsUnknown
	allocsd232e92c.Borrow(cdata_len_allocs)

	var cget_allocs *cgoAllocMap
	refd232e92c.get, cget_allocs = (C.int)(x.Get), cgoAllocsUnknown
	allocsd232e92c.Borrow(cget_allocs)

	x.refd232e92c = refd232e92c
	x.allocsd232e92c = allocsd232e92c
	return refd232e92c, allocsd232e92c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SubmitEvent) PassValue() (C.pdf_submit_event, *cgoAllocMap) {
	if x.refd232e92c != nil {
		return *x.refd232e92c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SubmitEvent) Deref() {
	if x.refd232e92c == nil {
		return
	}
	hxf2b7090 := (*sliceHeader)(unsafe.Pointer(&x.Url))
	hxf2b7090.Data = uintptr(unsafe.Pointer(x.refd232e92c.url))
	hxf2b7090.Cap = 0x7fffffff
	// hxf2b7090.Len = ?

	hxf000188 := (*sliceHeader)(unsafe.Pointer(&x.Data))
	hxf000188.Data = uintptr(unsafe.Pointer(x.refd232e92c.data))
	hxf000188.Cap = 0x7fffffff
	// hxf000188.Len = ?

	x.DataLen = (int32)(x.refd232e92c.data_len)
	x.Get = (int32)(x.refd232e92c.get)
}

// allocLaunchUrlEventMemory allocates memory for type C.pdf_launch_url_event in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLaunchUrlEventMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLaunchUrlEventValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfLaunchUrlEventValue = unsafe.Sizeof([1]C.pdf_launch_url_event{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *LaunchUrlEvent) Ref() *C.pdf_launch_url_event {
	if x == nil {
		return nil
	}
	return x.ref3d69425e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *LaunchUrlEvent) Free() {
	if x != nil && x.allocs3d69425e != nil {
		x.allocs3d69425e.(*cgoAllocMap).Free()
		x.ref3d69425e = nil
	}
}

// NewLaunchUrlEventRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewLaunchUrlEventRef(ref unsafe.Pointer) *LaunchUrlEvent {
	if ref == nil {
		return nil
	}
	obj := new(LaunchUrlEvent)
	obj.ref3d69425e = (*C.pdf_launch_url_event)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *LaunchUrlEvent) PassRef() (*C.pdf_launch_url_event, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3d69425e != nil {
		return x.ref3d69425e, nil
	}
	mem3d69425e := allocLaunchUrlEventMemory(1)
	ref3d69425e := (*C.pdf_launch_url_event)(mem3d69425e)
	allocs3d69425e := new(cgoAllocMap)
	allocs3d69425e.Add(mem3d69425e)

	var curl_allocs *cgoAllocMap
	ref3d69425e.url, curl_allocs = unpackPCharString(x.Url)
	allocs3d69425e.Borrow(curl_allocs)

	var cnew_frame_allocs *cgoAllocMap
	ref3d69425e.new_frame, cnew_frame_allocs = (C.int)(x.NewFrame), cgoAllocsUnknown
	allocs3d69425e.Borrow(cnew_frame_allocs)

	x.ref3d69425e = ref3d69425e
	x.allocs3d69425e = allocs3d69425e
	return ref3d69425e, allocs3d69425e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x LaunchUrlEvent) PassValue() (C.pdf_launch_url_event, *cgoAllocMap) {
	if x.ref3d69425e != nil {
		return *x.ref3d69425e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *LaunchUrlEvent) Deref() {
	if x.ref3d69425e == nil {
		return
	}
	x.Url = packPCharString(x.ref3d69425e.url)
	x.NewFrame = (int32)(x.ref3d69425e.new_frame)
}

// allocMailDocEventMemory allocates memory for type C.pdf_mail_doc_event in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMailDocEventMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMailDocEventValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMailDocEventValue = unsafe.Sizeof([1]C.pdf_mail_doc_event{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MailDocEvent) Ref() *C.pdf_mail_doc_event {
	if x == nil {
		return nil
	}
	return x.refe379e85d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MailDocEvent) Free() {
	if x != nil && x.allocse379e85d != nil {
		x.allocse379e85d.(*cgoAllocMap).Free()
		x.refe379e85d = nil
	}
}

// NewMailDocEventRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMailDocEventRef(ref unsafe.Pointer) *MailDocEvent {
	if ref == nil {
		return nil
	}
	obj := new(MailDocEvent)
	obj.refe379e85d = (*C.pdf_mail_doc_event)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MailDocEvent) PassRef() (*C.pdf_mail_doc_event, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe379e85d != nil {
		return x.refe379e85d, nil
	}
	meme379e85d := allocMailDocEventMemory(1)
	refe379e85d := (*C.pdf_mail_doc_event)(meme379e85d)
	allocse379e85d := new(cgoAllocMap)
	allocse379e85d.Add(meme379e85d)

	var cask_user_allocs *cgoAllocMap
	refe379e85d.ask_user, cask_user_allocs = (C.int)(x.AskUser), cgoAllocsUnknown
	allocse379e85d.Borrow(cask_user_allocs)

	var cto_allocs *cgoAllocMap
	refe379e85d.to, cto_allocs = unpackPCharString(x.To)
	allocse379e85d.Borrow(cto_allocs)

	var ccc_allocs *cgoAllocMap
	refe379e85d.cc, ccc_allocs = unpackPCharString(x.Cc)
	allocse379e85d.Borrow(ccc_allocs)

	var cbcc_allocs *cgoAllocMap
	refe379e85d.bcc, cbcc_allocs = unpackPCharString(x.Bcc)
	allocse379e85d.Borrow(cbcc_allocs)

	var csubject_allocs *cgoAllocMap
	refe379e85d.subject, csubject_allocs = unpackPCharString(x.Subject)
	allocse379e85d.Borrow(csubject_allocs)

	var cmessage_allocs *cgoAllocMap
	refe379e85d.message, cmessage_allocs = unpackPCharString(x.Message)
	allocse379e85d.Borrow(cmessage_allocs)

	x.refe379e85d = refe379e85d
	x.allocse379e85d = allocse379e85d
	return refe379e85d, allocse379e85d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MailDocEvent) PassValue() (C.pdf_mail_doc_event, *cgoAllocMap) {
	if x.refe379e85d != nil {
		return *x.refe379e85d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *MailDocEvent) Deref() {
	if x.refe379e85d == nil {
		return
	}
	x.AskUser = (int32)(x.refe379e85d.ask_user)
	x.To = packPCharString(x.refe379e85d.to)
	x.Cc = packPCharString(x.refe379e85d.cc)
	x.Bcc = packPCharString(x.refe379e85d.bcc)
	x.Subject = packPCharString(x.refe379e85d.subject)
	x.Message = packPCharString(x.refe379e85d.message)
}

// allocJsEventMemory allocates memory for type C.pdf_js_event in C.
// The caller is responsible for freeing the this memory via C.free.
func allocJsEventMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfJsEventValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfJsEventValue = unsafe.Sizeof([1]C.pdf_js_event{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *JsEvent) Ref() *C.pdf_js_event {
	if x == nil {
		return nil
	}
	return x.ref527f69ec
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *JsEvent) Free() {
	if x != nil && x.allocs527f69ec != nil {
		x.allocs527f69ec.(*cgoAllocMap).Free()
		x.ref527f69ec = nil
	}
}

// NewJsEventRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewJsEventRef(ref unsafe.Pointer) *JsEvent {
	if ref == nil {
		return nil
	}
	obj := new(JsEvent)
	obj.ref527f69ec = (*C.pdf_js_event)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *JsEvent) PassRef() (*C.pdf_js_event, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref527f69ec != nil {
		return x.ref527f69ec, nil
	}
	mem527f69ec := allocJsEventMemory(1)
	ref527f69ec := (*C.pdf_js_event)(mem527f69ec)
	allocs527f69ec := new(cgoAllocMap)
	allocs527f69ec.Add(mem527f69ec)

	var ctarget_allocs *cgoAllocMap
	ref527f69ec.target, ctarget_allocs = (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Target)).Data)), cgoAllocsUnknown
	allocs527f69ec.Borrow(ctarget_allocs)

	var cvalue_allocs *cgoAllocMap
	ref527f69ec.value, cvalue_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Value)).Data)), cgoAllocsUnknown
	allocs527f69ec.Borrow(cvalue_allocs)

	var crc_allocs *cgoAllocMap
	ref527f69ec.rc, crc_allocs = (C.int)(x.Rc), cgoAllocsUnknown
	allocs527f69ec.Borrow(crc_allocs)

	x.ref527f69ec = ref527f69ec
	x.allocs527f69ec = allocs527f69ec
	return ref527f69ec, allocs527f69ec

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x JsEvent) PassValue() (C.pdf_js_event, *cgoAllocMap) {
	if x.ref527f69ec != nil {
		return *x.ref527f69ec, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *JsEvent) Deref() {
	if x.ref527f69ec == nil {
		return
	}
	hxf23c7f0 := (*sliceHeader)(unsafe.Pointer(&x.Target))
	hxf23c7f0.Data = uintptr(unsafe.Pointer(x.ref527f69ec.target))
	hxf23c7f0.Cap = 0x7fffffff
	// hxf23c7f0.Len = ?

	hxf750b42 := (*sliceHeader)(unsafe.Pointer(&x.Value))
	hxf750b42.Data = uintptr(unsafe.Pointer(x.ref527f69ec.value))
	hxf750b42.Cap = 0x7fffffff
	// hxf750b42.Len = ?

	x.Rc = (int32)(x.ref527f69ec.rc)
}

// unpackArgSContext transforms a sliced Go data structure into plain C format.
func unpackArgSContext(x []Context) (unpacked *C.fz_context, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_context) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocContextMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_context)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_context)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSAllocContext transforms a sliced Go data structure into plain C format.
func unpackArgSAllocContext(x []AllocContext) (unpacked *C.fz_alloc_context, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_alloc_context) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocAllocContextMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_alloc_context)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_alloc_context)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSLocksContext transforms a sliced Go data structure into plain C format.
func unpackArgSLocksContext(x []LocksContext) (unpacked *C.fz_locks_context, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_locks_context) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocLocksContextMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_locks_context)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_locks_context)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSIrect transforms a sliced Go data structure into plain C format.
func unpackArgSIrect(x []Irect) (unpacked *C.fz_irect, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_irect) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocIrectMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_irect)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_irect)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSMatrix transforms a sliced Go data structure into plain C format.
func unpackArgSMatrix(x []Matrix) (unpacked *C.fz_matrix, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_matrix) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMatrixMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_matrix)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_matrix)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSPoint transforms a sliced Go data structure into plain C format.
func unpackArgSPoint(x []Point) (unpacked *C.fz_point, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_point) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPointMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_point)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_point)(unsafe.Pointer(h.Data))
	return
}

// packSPoint reads sliced Go data structure out from plain C format.
func packSPoint(v []Point, ptr0 *C.fz_point) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPointValue]C.fz_point)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPointRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSMd5 transforms a sliced Go data structure into plain C format.
func unpackArgSMd5(x []Md5) (unpacked *C.fz_md5, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_md5) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMd5Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_md5)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_md5)(unsafe.Pointer(h.Data))
	return
}

// packSMd5 reads sliced Go data structure out from plain C format.
func packSMd5(v []Md5, ptr0 *C.fz_md5) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMd5Value]C.fz_md5)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMd5Ref(unsafe.Pointer(&ptr1))
	}
}

// unpackPUcharString represents the data from Go string as *C.uchar and avoids copying.
func unpackPUcharString(str string) (*C.uchar, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.uchar)(unsafe.Pointer(h.Data)), cgoAllocsUnknown
}

// unpackArgSSha256 transforms a sliced Go data structure into plain C format.
func unpackArgSSha256(x []Sha256) (unpacked *C.fz_sha256, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_sha256) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSha256Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_sha256)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_sha256)(unsafe.Pointer(h.Data))
	return
}

// packSSha256 reads sliced Go data structure out from plain C format.
func packSSha256(v []Sha256, ptr0 *C.fz_sha256) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSha256Value]C.fz_sha256)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSha256Ref(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSha512 transforms a sliced Go data structure into plain C format.
func unpackArgSSha512(x []Sha512) (unpacked *C.fz_sha512, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_sha512) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSha512Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_sha512)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_sha512)(unsafe.Pointer(h.Data))
	return
}

// packSSha512 reads sliced Go data structure out from plain C format.
func packSSha512(v []Sha512, ptr0 *C.fz_sha512) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSha512Value]C.fz_sha512)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSha512Ref(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSha384 transforms a sliced Go data structure into plain C format.
func unpackArgSSha384(x []Sha384) (unpacked *C.fz_sha384, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_sha384) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocSha384Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_sha384)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_sha384)(unsafe.Pointer(h.Data))
	return
}

// packSSha384 reads sliced Go data structure out from plain C format.
func packSSha384(v []Sha384, ptr0 *C.fz_sha384) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfSha384Value]C.fz_sha384)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewSha384Ref(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSArc4 transforms a sliced Go data structure into plain C format.
func unpackArgSArc4(x []Arc4) (unpacked *C.fz_arc4, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_arc4) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocArc4Memory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_arc4)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_arc4)(unsafe.Pointer(h.Data))
	return
}

// packSArc4 reads sliced Go data structure out from plain C format.
func packSArc4(v []Arc4, ptr0 *C.fz_arc4) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfArc4Value]C.fz_arc4)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewArc4Ref(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSAes transforms a sliced Go data structure into plain C format.
func unpackArgSAes(x []Aes) (unpacked *C.fz_aes, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_aes) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocAesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_aes)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_aes)(unsafe.Pointer(h.Data))
	return
}

// packSAes reads sliced Go data structure out from plain C format.
func packSAes(v []Aes, ptr0 *C.fz_aes) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAesValue]C.fz_aes)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSByte transforms a sliced Go data structure into plain C format.
func unpackArgSSByte(x [][]byte) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.char)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(unsafe.Pointer(h.Data))
	return
}

// packSSByte reads sliced Go data structure out from plain C format.
func packSSByte(v [][]byte, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		hxfe6ec59 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfe6ec59.Data = uintptr(unsafe.Pointer(ptr1))
		hxfe6ec59.Cap = 0x7fffffff
		// hxfe6ec59.Len = ?
	}
}

// allocFileMemory allocates memory for type C.FILE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFileMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFileValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFileValue = unsafe.Sizeof([1]C.FILE{})

// unpackArgSFile transforms a sliced Go data structure into plain C format.
func unpackArgSFile(x []File) (unpacked *C.FILE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.FILE) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocFileMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.FILE)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.FILE)(unsafe.Pointer(h.Data))
	return
}

// packSFile reads sliced Go data structure out from plain C format.
func packSFile(v []File, ptr0 *C.FILE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFileValue]C.FILE)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFileRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSOutput transforms a sliced Go data structure into plain C format.
func unpackArgSOutput(x []Output) (unpacked *C.fz_output, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_output) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocOutputMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_output)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_output)(unsafe.Pointer(h.Data))
	return
}

// allocPUcharMemory allocates memory for type *C.uchar in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPUcharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPUcharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPUcharValue = unsafe.Sizeof([1]*C.uchar{})

// unpackArgSStream transforms a sliced Go data structure into plain C format.
func unpackArgSStream(x []Stream) (unpacked *C.fz_stream, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_stream) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStreamMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_stream)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_stream)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSCompressedBuffer transforms a sliced Go data structure into plain C format.
func unpackArgSCompressedBuffer(x []CompressedBuffer) (unpacked *C.fz_compressed_buffer, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_compressed_buffer) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCompressedBufferMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_compressed_buffer)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_compressed_buffer)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSCompressionParams transforms a sliced Go data structure into plain C format.
func unpackArgSCompressionParams(x []CompressionParams) (unpacked *C.fz_compression_params, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_compression_params) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCompressionParamsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_compression_params)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_compression_params)(unsafe.Pointer(h.Data))
	return
}

// packSCompressionParams reads sliced Go data structure out from plain C format.
func packSCompressionParams(v []CompressionParams, ptr0 *C.fz_compression_params) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCompressionParamsValue]C.fz_compression_params)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCompressionParamsRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSStorable transforms a sliced Go data structure into plain C format.
func unpackArgSStorable(x []Storable) (unpacked *C.fz_storable, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_storable) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStorableMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_storable)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_storable)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSKeyStorable transforms a sliced Go data structure into plain C format.
func unpackArgSKeyStorable(x []KeyStorable) (unpacked *C.fz_key_storable, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_key_storable) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocKeyStorableMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_key_storable)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_key_storable)(unsafe.Pointer(h.Data))
	return
}

// packSKeyStorable reads sliced Go data structure out from plain C format.
func packSKeyStorable(v []KeyStorable, ptr0 *C.fz_key_storable) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfKeyStorableValue]C.fz_key_storable)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewKeyStorableRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSStoreType transforms a sliced Go data structure into plain C format.
func unpackArgSStoreType(x []StoreType) (unpacked *C.fz_store_type, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_store_type) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStoreTypeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_store_type)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_store_type)(unsafe.Pointer(h.Data))
	return
}

// packSStoreType reads sliced Go data structure out from plain C format.
func packSStoreType(v []StoreType, ptr0 *C.fz_store_type) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStoreTypeValue]C.fz_store_type)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewStoreTypeRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSArchive transforms a sliced Go data structure into plain C format.
func unpackArgSArchive(x []Archive) (unpacked *C.fz_archive, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_archive) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocArchiveMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_archive)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_archive)(unsafe.Pointer(h.Data))
	return
}

// packSArchive reads sliced Go data structure out from plain C format.
func packSArchive(v []Archive, ptr0 *C.fz_archive) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfArchiveValue]C.fz_archive)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewArchiveRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSColorParams transforms a sliced Go data structure into plain C format.
func unpackArgSColorParams(x []ColorParams) (unpacked *C.fz_color_params, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_color_params) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocColorParamsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_color_params)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_color_params)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSColorConverter transforms a sliced Go data structure into plain C format.
func unpackArgSColorConverter(x []ColorConverter) (unpacked *C.fz_color_converter, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_color_converter) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocColorConverterMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_color_converter)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_color_converter)(unsafe.Pointer(h.Data))
	return
}

// packSColorConverter reads sliced Go data structure out from plain C format.
func packSColorConverter(v []ColorConverter, ptr0 *C.fz_color_converter) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfColorConverterValue]C.fz_color_converter)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewColorConverterRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSCalColorspace transforms a sliced Go data structure into plain C format.
func unpackArgSCalColorspace(x []CalColorspace) (unpacked *C.fz_cal_colorspace, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_cal_colorspace) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCalColorspaceMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_cal_colorspace)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_cal_colorspace)(unsafe.Pointer(h.Data))
	return
}

// packSCalColorspace reads sliced Go data structure out from plain C format.
func packSCalColorspace(v []CalColorspace, ptr0 *C.fz_cal_colorspace) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCalColorspaceValue]C.fz_cal_colorspace)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCalColorspaceRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSGlyph transforms a sliced Go data structure into plain C format.
func unpackArgSGlyph(x []Glyph) (unpacked *C.fz_glyph, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_glyph) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocGlyphMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_glyph)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_glyph)(unsafe.Pointer(h.Data))
	return
}

// packSGlyph reads sliced Go data structure out from plain C format.
func packSGlyph(v []Glyph, ptr0 *C.fz_glyph) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfGlyphValue]C.fz_glyph)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewGlyphRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSBitmap transforms a sliced Go data structure into plain C format.
func unpackArgSBitmap(x []Bitmap) (unpacked *C.fz_bitmap, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_bitmap) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocBitmapMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_bitmap)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_bitmap)(unsafe.Pointer(h.Data))
	return
}

// packSBitmap reads sliced Go data structure out from plain C format.
func packSBitmap(v []Bitmap, ptr0 *C.fz_bitmap) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBitmapValue]C.fz_bitmap)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBitmapRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSImage transforms a sliced Go data structure into plain C format.
func unpackArgSImage(x []Image) (unpacked *C.fz_image, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_image) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocImageMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_image)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_image)(unsafe.Pointer(h.Data))
	return
}

// allocPColorspaceMemory allocates memory for type *C.fz_colorspace in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPColorspaceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPColorspaceValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPColorspaceValue = unsafe.Sizeof([1]*C.fz_colorspace{})

// unpackArgSSColorspace transforms a sliced Go data structure into plain C format.
func unpackArgSSColorspace(x [][]Colorspace) (unpacked **C.fz_colorspace, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.fz_colorspace) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPColorspaceMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.fz_colorspace)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.fz_colorspace)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.fz_colorspace)(unsafe.Pointer(h.Data))
	return
}

// packSSColorspace reads sliced Go data structure out from plain C format.
func packSSColorspace(v [][]Colorspace, ptr0 **C.fz_colorspace) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.fz_colorspace)(unsafe.Pointer(ptr0)))[i0]
		hxf61194e := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf61194e.Data = uintptr(unsafe.Pointer(ptr1))
		hxf61194e.Cap = 0x7fffffff
		// hxf61194e.Len = ?
	}
}

// unpackArgSShade transforms a sliced Go data structure into plain C format.
func unpackArgSShade(x []Shade) (unpacked *C.fz_shade, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_shade) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocShadeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_shade)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_shade)(unsafe.Pointer(h.Data))
	return
}

// packSShade reads sliced Go data structure out from plain C format.
func packSShade(v []Shade, ptr0 *C.fz_shade) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfShadeValue]C.fz_shade)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewShadeRef(unsafe.Pointer(&ptr1))
	}
}

// allocStruct_DeviceSMemory allocates memory for type C.struct_fz_device_s in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct_DeviceSMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct_DeviceSValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStruct_DeviceSValue = unsafe.Sizeof([1]C.struct_fz_device_s{})

// unpackArgSDeviceS transforms a sliced Go data structure into plain C format.
func unpackArgSDeviceS(x []DeviceS) (unpacked *C.struct_fz_device_s, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_fz_device_s) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStruct_DeviceSMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_fz_device_s)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_fz_device_s)(unsafe.Pointer(h.Data))
	return
}

// packSDeviceS reads sliced Go data structure out from plain C format.
func packSDeviceS(v []DeviceS, ptr0 *C.struct_fz_device_s) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStruct_DeviceSValue]C.struct_fz_device_s)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDeviceSRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSFont transforms a sliced Go data structure into plain C format.
func unpackArgSSFont(x [][]Font) (unpacked **C.fz_font, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.fz_font) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPFontMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.fz_font)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.fz_font)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.fz_font)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSPathWalker transforms a sliced Go data structure into plain C format.
func unpackArgSPathWalker(x []PathWalker) (unpacked *C.fz_path_walker, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_path_walker) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPathWalkerMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_path_walker)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_path_walker)(unsafe.Pointer(h.Data))
	return
}

// packSPathWalker reads sliced Go data structure out from plain C format.
func packSPathWalker(v []PathWalker, ptr0 *C.fz_path_walker) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPathWalkerValue]C.fz_path_walker)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPathWalkerRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSStrokeState transforms a sliced Go data structure into plain C format.
func unpackArgSStrokeState(x []StrokeState) (unpacked *C.fz_stroke_state, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_stroke_state) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStrokeStateMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_stroke_state)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_stroke_state)(unsafe.Pointer(h.Data))
	return
}

// packSStrokeState reads sliced Go data structure out from plain C format.
func packSStrokeState(v []StrokeState, ptr0 *C.fz_stroke_state) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStrokeStateValue]C.fz_stroke_state)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewStrokeStateRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSText transforms a sliced Go data structure into plain C format.
func unpackArgSText(x []Text) (unpacked *C.fz_text, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_text) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocTextMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_text)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_text)(unsafe.Pointer(h.Data))
	return
}

// packSText reads sliced Go data structure out from plain C format.
func packSText(v []Text, ptr0 *C.fz_text) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTextValue]C.fz_text)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTextRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSCmmEngine transforms a sliced Go data structure into plain C format.
func unpackArgSCmmEngine(x []CmmEngine) (unpacked *C.fz_cmm_engine, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_cmm_engine) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCmmEngineMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_cmm_engine)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_cmm_engine)(unsafe.Pointer(h.Data))
	return
}

// packSCmmEngine reads sliced Go data structure out from plain C format.
func packSCmmEngine(v []CmmEngine, ptr0 *C.fz_cmm_engine) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCmmEngineValue]C.fz_cmm_engine)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCmmEngineRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDrawOptions transforms a sliced Go data structure into plain C format.
func unpackArgSDrawOptions(x []DrawOptions) (unpacked *C.fz_draw_options, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_draw_options) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDrawOptionsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_draw_options)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_draw_options)(unsafe.Pointer(h.Data))
	return
}

// packSDrawOptions reads sliced Go data structure out from plain C format.
func packSDrawOptions(v []DrawOptions, ptr0 *C.fz_draw_options) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDrawOptionsValue]C.fz_draw_options)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDrawOptionsRef(unsafe.Pointer(&ptr1))
	}
}

// allocPPixmapMemory allocates memory for type *C.fz_pixmap in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPPixmapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPPixmapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPPixmapValue = unsafe.Sizeof([1]*C.fz_pixmap{})

// unpackArgSSPixmap transforms a sliced Go data structure into plain C format.
func unpackArgSSPixmap(x [][]Pixmap) (unpacked **C.fz_pixmap, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.fz_pixmap) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPPixmapMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.fz_pixmap)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocPixmapMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: uintptr(mem1),
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.fz_pixmap)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.fz_pixmap)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.fz_pixmap)(unsafe.Pointer(h.Data))
	return
}

// packSSPixmap reads sliced Go data structure out from plain C format.
func packSSPixmap(v [][]Pixmap, ptr0 **C.fz_pixmap) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.fz_pixmap)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfPixmapValue]C.fz_pixmap)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewPixmapRef(unsafe.Pointer(&ptr2))
		}
	}
}

// unpackArgSCookie transforms a sliced Go data structure into plain C format.
func unpackArgSCookie(x []Cookie) (unpacked *C.fz_cookie, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_cookie) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCookieMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_cookie)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_cookie)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSStextPage transforms a sliced Go data structure into plain C format.
func unpackArgSStextPage(x []StextPage) (unpacked *C.fz_stext_page, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_stext_page) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStextPageMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_stext_page)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_stext_page)(unsafe.Pointer(h.Data))
	return
}

// packSStextPage reads sliced Go data structure out from plain C format.
func packSStextPage(v []StextPage, ptr0 *C.fz_stext_page) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStextPageValue]C.fz_stext_page)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewStextPageRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSStextOptions transforms a sliced Go data structure into plain C format.
func unpackArgSStextOptions(x []StextOptions) (unpacked *C.fz_stext_options, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_stext_options) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStextOptionsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_stext_options)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_stext_options)(unsafe.Pointer(h.Data))
	return
}

// packSStextOptions reads sliced Go data structure out from plain C format.
func packSStextOptions(v []StextOptions, ptr0 *C.fz_stext_options) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStextOptionsValue]C.fz_stext_options)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewStextOptionsRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDocumentHandler transforms a sliced Go data structure into plain C format.
func unpackArgSDocumentHandler(x []DocumentHandler) (unpacked *C.fz_document_handler, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_document_handler) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDocumentHandlerMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_document_handler)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_document_handler)(unsafe.Pointer(h.Data))
	return
}

// packSDocumentHandler reads sliced Go data structure out from plain C format.
func packSDocumentHandler(v []DocumentHandler, ptr0 *C.fz_document_handler) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDocumentHandlerValue]C.fz_document_handler)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDocumentHandlerRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSString transforms a sliced Go data structure into plain C format.
func unpackArgSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = unpackPCharString(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSDocumentWriter transforms a sliced Go data structure into plain C format.
func unpackArgSDocumentWriter(x []DocumentWriter) (unpacked *C.fz_document_writer, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_document_writer) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDocumentWriterMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_document_writer)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_document_writer)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSBandWriter transforms a sliced Go data structure into plain C format.
func unpackArgSBandWriter(x []BandWriter) (unpacked *C.fz_band_writer, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_band_writer) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocBandWriterMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_band_writer)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_band_writer)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSPwgOptions transforms a sliced Go data structure into plain C format.
func unpackArgSPwgOptions(x []PwgOptions) (unpacked *C.fz_pwg_options, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_pwg_options) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPwgOptionsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_pwg_options)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_pwg_options)(unsafe.Pointer(h.Data))
	return
}

// packSPwgOptions reads sliced Go data structure out from plain C format.
func packSPwgOptions(v []PwgOptions, ptr0 *C.fz_pwg_options) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPwgOptionsValue]C.fz_pwg_options)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPwgOptionsRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPclOptions transforms a sliced Go data structure into plain C format.
func unpackArgSPclOptions(x []PclOptions) (unpacked *C.fz_pcl_options, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fz_pcl_options) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPclOptionsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fz_pcl_options)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fz_pcl_options)(unsafe.Pointer(h.Data))
	return
}

// packSPclOptions reads sliced Go data structure out from plain C format.
func packSPclOptions(v []PclOptions, ptr0 *C.fz_pcl_options) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPclOptionsValue]C.fz_pcl_options)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPclOptionsRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSSObj transforms a sliced Go data structure into plain C format.
func unpackArgSSObj(x [][]Obj) (unpacked **C.pdf_obj, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.pdf_obj) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPObjMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.pdf_obj)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.pdf_obj)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.pdf_obj)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSLayerConfig transforms a sliced Go data structure into plain C format.
func unpackArgSLayerConfig(x []LayerConfig) (unpacked *C.pdf_layer_config, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_layer_config) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocLayerConfigMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_layer_config)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_layer_config)(unsafe.Pointer(h.Data))
	return
}

// packSLayerConfig reads sliced Go data structure out from plain C format.
func packSLayerConfig(v []LayerConfig, ptr0 *C.pdf_layer_config) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfLayerConfigValue]C.pdf_layer_config)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewLayerConfigRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSLayerConfigUi transforms a sliced Go data structure into plain C format.
func unpackArgSLayerConfigUi(x []LayerConfigUi) (unpacked *C.pdf_layer_config_ui, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_layer_config_ui) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocLayerConfigUiMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_layer_config_ui)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_layer_config_ui)(unsafe.Pointer(h.Data))
	return
}

// packSLayerConfigUi reads sliced Go data structure out from plain C format.
func packSLayerConfigUi(v []LayerConfigUi, ptr0 *C.pdf_layer_config_ui) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfLayerConfigUiValue]C.pdf_layer_config_ui)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewLayerConfigUiRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPortfolioSchema transforms a sliced Go data structure into plain C format.
func unpackArgSPortfolioSchema(x []PortfolioSchema) (unpacked *C.pdf_portfolio_schema, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_portfolio_schema) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPortfolioSchemaMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_portfolio_schema)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_portfolio_schema)(unsafe.Pointer(h.Data))
	return
}

// packSPortfolioSchema reads sliced Go data structure out from plain C format.
func packSPortfolioSchema(v []PortfolioSchema, ptr0 *C.pdf_portfolio_schema) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPortfolioSchemaValue]C.pdf_portfolio_schema)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPortfolioSchemaRef(unsafe.Pointer(&ptr1))
	}
}

// allocPBufferMemory allocates memory for type *C.fz_buffer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPBufferValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPBufferValue = unsafe.Sizeof([1]*C.fz_buffer{})

// unpackArgSSBuffer transforms a sliced Go data structure into plain C format.
func unpackArgSSBuffer(x [][]Buffer) (unpacked **C.fz_buffer, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.fz_buffer) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPBufferMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.fz_buffer)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.fz_buffer)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.fz_buffer)(unsafe.Pointer(h.Data))
	return
}

// packSSBuffer reads sliced Go data structure out from plain C format.
func packSSBuffer(v [][]Buffer, ptr0 **C.fz_buffer) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.fz_buffer)(unsafe.Pointer(ptr0)))[i0]
		hxfadc325 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfadc325.Data = uintptr(unsafe.Pointer(ptr1))
		hxfadc325.Cap = 0x7fffffff
		// hxfadc325.Len = ?
	}
}

// unpackArgSWriteOptions transforms a sliced Go data structure into plain C format.
func unpackArgSWriteOptions(x []WriteOptions) (unpacked *C.pdf_write_options, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_write_options) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocWriteOptionsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_write_options)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_write_options)(unsafe.Pointer(h.Data))
	return
}

// packSWriteOptions reads sliced Go data structure out from plain C format.
func packSWriteOptions(v []WriteOptions, ptr0 *C.pdf_write_options) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfWriteOptionsValue]C.pdf_write_options)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewWriteOptionsRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSLexbuf transforms a sliced Go data structure into plain C format.
func unpackArgSLexbuf(x []Lexbuf) (unpacked *C.pdf_lexbuf, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_lexbuf) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocLexbufMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_lexbuf)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_lexbuf)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSXrefEntry transforms a sliced Go data structure into plain C format.
func unpackArgSXrefEntry(x []XrefEntry) (unpacked *C.pdf_xref_entry, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_xref_entry) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocXrefEntryMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_xref_entry)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_xref_entry)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSDesignatedName transforms a sliced Go data structure into plain C format.
func unpackArgSDesignatedName(x []DesignatedName) (unpacked *C.pdf_designated_name, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_designated_name) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDesignatedNameMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_designated_name)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_designated_name)(unsafe.Pointer(h.Data))
	return
}

// packSDesignatedName reads sliced Go data structure out from plain C format.
func packSDesignatedName(v []DesignatedName, ptr0 *C.pdf_designated_name) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDesignatedNameValue]C.pdf_designated_name)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDesignatedNameRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSPattern transforms a sliced Go data structure into plain C format.
func unpackArgSPattern(x []Pattern) (unpacked *C.pdf_pattern, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_pattern) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPatternMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_pattern)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_pattern)(unsafe.Pointer(h.Data))
	return
}

// packSPattern reads sliced Go data structure out from plain C format.
func packSPattern(v []Pattern, ptr0 *C.pdf_pattern) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPatternValue]C.pdf_pattern)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewPatternRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSXobject transforms a sliced Go data structure into plain C format.
func unpackArgSXobject(x []Xobject) (unpacked *C.pdf_xobject, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_xobject) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocXobjectMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_xobject)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_xobject)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSCmap transforms a sliced Go data structure into plain C format.
func unpackArgSCmap(x []Cmap) (unpacked *C.pdf_cmap, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_cmap) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCmapMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_cmap)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_cmap)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSFontDesc transforms a sliced Go data structure into plain C format.
func unpackArgSFontDesc(x []FontDesc) (unpacked *C.pdf_font_desc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_font_desc) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocFontDescMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_font_desc)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_font_desc)(unsafe.Pointer(h.Data))
	return
}

// packSFontDesc reads sliced Go data structure out from plain C format.
func packSFontDesc(v []FontDesc, ptr0 *C.pdf_font_desc) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFontDescValue]C.pdf_font_desc)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFontDescRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSProcessor transforms a sliced Go data structure into plain C format.
func unpackArgSProcessor(x []Processor) (unpacked *C.pdf_processor, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_processor) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocProcessorMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_processor)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_processor)(unsafe.Pointer(h.Data))
	return
}

// packSProcessor reads sliced Go data structure out from plain C format.
func packSProcessor(v []Processor, ptr0 *C.pdf_processor) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfProcessorValue]C.pdf_processor)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewProcessorRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDaInfo transforms a sliced Go data structure into plain C format.
func unpackArgSDaInfo(x []DaInfo) (unpacked *C.pdf_da_info, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_da_info) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDaInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_da_info)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_da_info)(unsafe.Pointer(h.Data))
	return
}

// packSDaInfo reads sliced Go data structure out from plain C format.
func packSDaInfo(v []DaInfo, ptr0 *C.pdf_da_info) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfDaInfoValue]C.pdf_da_info)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDaInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSUiEvent transforms a sliced Go data structure into plain C format.
func unpackArgSUiEvent(x []UiEvent) (unpacked *C.pdf_ui_event, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_ui_event) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocUiEventMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_ui_event)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_ui_event)(unsafe.Pointer(h.Data))
	return
}

// packSUiEvent reads sliced Go data structure out from plain C format.
func packSUiEvent(v []UiEvent, ptr0 *C.pdf_ui_event) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfUiEventValue]C.pdf_ui_event)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewUiEventRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSDocEvent transforms a sliced Go data structure into plain C format.
func unpackArgSDocEvent(x []DocEvent) (unpacked *C.pdf_doc_event, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_doc_event) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocDocEventMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_doc_event)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_doc_event)(unsafe.Pointer(h.Data))
	return
}

// unpackArgSAlertEvent transforms a sliced Go data structure into plain C format.
func unpackArgSAlertEvent(x []AlertEvent) (unpacked *C.pdf_alert_event, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_alert_event) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocAlertEventMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_alert_event)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_alert_event)(unsafe.Pointer(h.Data))
	return
}

// packSAlertEvent reads sliced Go data structure out from plain C format.
func packSAlertEvent(v []AlertEvent, ptr0 *C.pdf_alert_event) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfAlertEventValue]C.pdf_alert_event)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewAlertEventRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSMailDocEvent transforms a sliced Go data structure into plain C format.
func unpackArgSMailDocEvent(x []MailDocEvent) (unpacked *C.pdf_mail_doc_event, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_mail_doc_event) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMailDocEventMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_mail_doc_event)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_mail_doc_event)(unsafe.Pointer(h.Data))
	return
}

// packSMailDocEvent reads sliced Go data structure out from plain C format.
func packSMailDocEvent(v []MailDocEvent, ptr0 *C.pdf_mail_doc_event) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfMailDocEventValue]C.pdf_mail_doc_event)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewMailDocEventRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSJsEvent transforms a sliced Go data structure into plain C format.
func unpackArgSJsEvent(x []JsEvent) (unpacked *C.pdf_js_event, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.pdf_js_event) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocJsEventMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.pdf_js_event)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.pdf_js_event)(unsafe.Pointer(h.Data))
	return
}

// packSJsEvent reads sliced Go data structure out from plain C format.
func packSJsEvent(v []JsEvent, ptr0 *C.pdf_js_event) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfJsEventValue]C.pdf_js_event)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewJsEventRef(unsafe.Pointer(&ptr1))
	}
}
