// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Tue, 10 Oct 2017 18:52:59 MSK.
// By https://git.io/c-for-go. DO NOT EDIT.

package mupdf

/*
#include "mupdf/pdf.h"
#include "mupdf/fitz.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import "unsafe"

// VarImp function as declared in fitz/context.h:53
func VarImp(arg0 unsafe.Pointer) {
	carg0, _ := arg0, cgoAllocsUnknown
	C.fz_var_imp(carg0)
}

// PushTry function as declared in fitz/context.h:79
func PushTry(ctx []Context) int32 {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_push_try(cctx)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// Vthrow function as declared in fitz/context.h:80
func Vthrow(ctx []Context, errcode int32, arg2 string, ap unsafe.Pointer) {
	cctx, _ := unpackArgSContext(ctx)
	cerrcode, _ := (C.int)(errcode), cgoAllocsUnknown
	carg2, _ := unpackPCharString(arg2)
	cap, _ := ap, cgoAllocsUnknown
	C.fz_vthrow(cctx, cerrcode, carg2, cap)
	packSContext(ctx, cctx)
}

// Throw function as declared in fitz/context.h:81
func Throw(ctx []Context, errcode int32, arg2 string) {
	cctx, _ := unpackArgSContext(ctx)
	cerrcode, _ := (C.int)(errcode), cgoAllocsUnknown
	carg2, _ := unpackPCharString(arg2)
	C.fz_throw(cctx, cerrcode, carg2)
	packSContext(ctx, cctx)
}

// Rethrow function as declared in fitz/context.h:82
func Rethrow(ctx []Context) {
	cctx, _ := unpackArgSContext(ctx)
	C.fz_rethrow(cctx)
	packSContext(ctx, cctx)
}

// Vwarn function as declared in fitz/context.h:83
func Vwarn(ctx []Context, fmt string, ap unsafe.Pointer) {
	cctx, _ := unpackArgSContext(ctx)
	cfmt, _ := unpackPCharString(fmt)
	cap, _ := ap, cgoAllocsUnknown
	C.fz_vwarn(cctx, cfmt, cap)
	packSContext(ctx, cctx)
}

// Warn function as declared in fitz/context.h:84
func Warn(ctx []Context, fmt string) {
	cctx, _ := unpackArgSContext(ctx)
	cfmt, _ := unpackPCharString(fmt)
	C.fz_warn(cctx, cfmt)
	packSContext(ctx, cctx)
}

// CaughtMessage function as declared in fitz/context.h:85
func CaughtMessage(ctx []Context) string {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_caught_message(cctx)
	packSContext(ctx, cctx)
	__v := packPCharString(__ret)
	return __v
}

// Caught function as declared in fitz/context.h:86
func Caught(ctx []Context) int32 {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_caught(cctx)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// RethrowIf function as declared in fitz/context.h:87
func RethrowIf(ctx []Context, errcode int32) {
	cctx, _ := unpackArgSContext(ctx)
	cerrcode, _ := (C.int)(errcode), cgoAllocsUnknown
	C.fz_rethrow_if(cctx, cerrcode)
	packSContext(ctx, cctx)
}

// FlushWarnings function as declared in fitz/context.h:109
func FlushWarnings(ctx []Context) {
	cctx, _ := unpackArgSContext(ctx)
	C.fz_flush_warnings(cctx)
	packSContext(ctx, cctx)
}

// NewContextImp function as declared in fitz/context.h:173
func NewContextImp(alloc []AllocContext, locks []LocksContext, maxStore uint, version string) *Context {
	calloc, _ := unpackArgSAllocContext(alloc)
	clocks, _ := unpackArgSLocksContext(locks)
	cmaxStore, _ := (C.size_t)(maxStore), cgoAllocsUnknown
	cversion, _ := unpackPCharString(version)
	__ret := C.fz_new_context_imp(calloc, clocks, cmaxStore, cversion)
	packSLocksContext(locks, clocks)
	packSAllocContext(alloc, calloc)
	__v := NewContextRef(unsafe.Pointer(__ret))
	return __v
}

// CloneContext function as declared in fitz/context.h:192
func CloneContext(ctx []Context) *Context {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_clone_context(cctx)
	packSContext(ctx, cctx)
	__v := NewContextRef(unsafe.Pointer(__ret))
	return __v
}

// DropContext function as declared in fitz/context.h:201
func DropContext(ctx []Context) {
	cctx, _ := unpackArgSContext(ctx)
	C.fz_drop_context(cctx)
	packSContext(ctx, cctx)
}

// SetUserContext function as declared in fitz/context.h:209
func SetUserContext(ctx []Context, user unsafe.Pointer) {
	cctx, _ := unpackArgSContext(ctx)
	cuser, _ := user, cgoAllocsUnknown
	C.fz_set_user_context(cctx, cuser)
	packSContext(ctx, cctx)
}

// UserContext function as declared in fitz/context.h:214
func UserContext(ctx []Context) unsafe.Pointer {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_user_context(cctx)
	packSContext(ctx, cctx)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// TuneImageDecode function as declared in fitz/context.h:263
func TuneImageDecode(ctx []Context, imageDecode TuneImageDecodeFn, arg unsafe.Pointer) {
	cctx, _ := unpackArgSContext(ctx)
	cimageDecode, _ := imageDecode.PassRef()
	carg, _ := arg, cgoAllocsUnknown
	C.fz_tune_image_decode(cctx, cimageDecode, carg)
	packSContext(ctx, cctx)
}

// TuneImageScale function as declared in fitz/context.h:273
func TuneImageScale(ctx []Context, imageScale TuneImageScaleFn, arg unsafe.Pointer) {
	cctx, _ := unpackArgSContext(ctx)
	cimageScale, _ := imageScale.PassRef()
	carg, _ := arg, cgoAllocsUnknown
	C.fz_tune_image_scale(cctx, cimageScale, carg)
	packSContext(ctx, cctx)
}

// AaLevel function as declared in fitz/context.h:279
func AaLevel(ctx []Context) int32 {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_aa_level(cctx)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// SetAaLevel function as declared in fitz/context.h:288
func SetAaLevel(ctx []Context, bits int32) {
	cctx, _ := unpackArgSContext(ctx)
	cbits, _ := (C.int)(bits), cgoAllocsUnknown
	C.fz_set_aa_level(cctx, cbits)
	packSContext(ctx, cctx)
}

// TextAaLevel function as declared in fitz/context.h:294
func TextAaLevel(ctx []Context) int32 {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_text_aa_level(cctx)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// SetTextAaLevel function as declared in fitz/context.h:303
func SetTextAaLevel(ctx []Context, bits int32) {
	cctx, _ := unpackArgSContext(ctx)
	cbits, _ := (C.int)(bits), cgoAllocsUnknown
	C.fz_set_text_aa_level(cctx, cbits)
	packSContext(ctx, cctx)
}

// GraphicsAaLevel function as declared in fitz/context.h:309
func GraphicsAaLevel(ctx []Context) int32 {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_graphics_aa_level(cctx)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// SetGraphicsAaLevel function as declared in fitz/context.h:318
func SetGraphicsAaLevel(ctx []Context, bits int32) {
	cctx, _ := unpackArgSContext(ctx)
	cbits, _ := (C.int)(bits), cgoAllocsUnknown
	C.fz_set_graphics_aa_level(cctx, cbits)
	packSContext(ctx, cctx)
}

// GraphicsMinLineWidth function as declared in fitz/context.h:326
func GraphicsMinLineWidth(ctx []Context) float32 {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_graphics_min_line_width(cctx)
	packSContext(ctx, cctx)
	__v := (float32)(__ret)
	return __v
}

// SetGraphicsMinLineWidth function as declared in fitz/context.h:334
func SetGraphicsMinLineWidth(ctx []Context, minLineWidth float32) {
	cctx, _ := unpackArgSContext(ctx)
	cminLineWidth, _ := (C.float)(minLineWidth), cgoAllocsUnknown
	C.fz_set_graphics_min_line_width(cctx, cminLineWidth)
	packSContext(ctx, cctx)
}

// UserCss function as declared in fitz/context.h:339
func UserCss(ctx []Context) string {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_user_css(cctx)
	packSContext(ctx, cctx)
	__v := packPCharString(__ret)
	return __v
}

// SetUserCss function as declared in fitz/context.h:344
func SetUserCss(ctx []Context, text string) {
	cctx, _ := unpackArgSContext(ctx)
	ctext, _ := unpackPCharString(text)
	C.fz_set_user_css(cctx, ctext)
	packSContext(ctx, cctx)
}

// UseDocumentCss function as declared in fitz/context.h:349
func UseDocumentCss(ctx []Context) int32 {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_use_document_css(cctx)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// SetUseDocumentCss function as declared in fitz/context.h:354
func SetUseDocumentCss(ctx []Context, use int32) {
	cctx, _ := unpackArgSContext(ctx)
	cuse, _ := (C.int)(use), cgoAllocsUnknown
	C.fz_set_use_document_css(cctx, cuse)
	packSContext(ctx, cctx)
}

// Malloc function as declared in fitz/context.h:415
func Malloc(ctx []Context, size uint) unsafe.Pointer {
	cctx, _ := unpackArgSContext(ctx)
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	__ret := C.fz_malloc(cctx, csize)
	packSContext(ctx, cctx)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// Calloc function as declared in fitz/context.h:427
func Calloc(ctx []Context, count uint, size uint) unsafe.Pointer {
	cctx, _ := unpackArgSContext(ctx)
	ccount, _ := (C.size_t)(count), cgoAllocsUnknown
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	__ret := C.fz_calloc(cctx, ccount, csize)
	packSContext(ctx, cctx)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// MallocArray function as declared in fitz/context.h:455
func MallocArray(ctx []Context, count uint, size uint) unsafe.Pointer {
	cctx, _ := unpackArgSContext(ctx)
	ccount, _ := (C.size_t)(count), cgoAllocsUnknown
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	__ret := C.fz_malloc_array(cctx, ccount, csize)
	packSContext(ctx, cctx)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// ResizeArray function as declared in fitz/context.h:470
func ResizeArray(ctx []Context, p unsafe.Pointer, count uint, size uint) unsafe.Pointer {
	cctx, _ := unpackArgSContext(ctx)
	cp, _ := p, cgoAllocsUnknown
	ccount, _ := (C.size_t)(count), cgoAllocsUnknown
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	__ret := C.fz_resize_array(cctx, cp, ccount, csize)
	packSContext(ctx, cctx)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// Strdup function as declared in fitz/context.h:480
func Strdup(ctx []Context, s string) *byte {
	cctx, _ := unpackArgSContext(ctx)
	cs, _ := unpackPCharString(s)
	__ret := C.fz_strdup(cctx, cs)
	packSContext(ctx, cctx)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// Free function as declared in fitz/context.h:485
func Free(ctx []Context, p unsafe.Pointer) {
	cctx, _ := unpackArgSContext(ctx)
	cp, _ := p, cgoAllocsUnknown
	C.fz_free(cctx, cp)
	packSContext(ctx, cctx)
}

// MallocNoThrow function as declared in fitz/context.h:495
func MallocNoThrow(ctx []Context, size uint) unsafe.Pointer {
	cctx, _ := unpackArgSContext(ctx)
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	__ret := C.fz_malloc_no_throw(cctx, csize)
	packSContext(ctx, cctx)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// CallocNoThrow function as declared in fitz/context.h:507
func CallocNoThrow(ctx []Context, count uint, size uint) unsafe.Pointer {
	cctx, _ := unpackArgSContext(ctx)
	ccount, _ := (C.size_t)(count), cgoAllocsUnknown
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	__ret := C.fz_calloc_no_throw(cctx, ccount, csize)
	packSContext(ctx, cctx)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// MallocArrayNoThrow function as declared in fitz/context.h:521
func MallocArrayNoThrow(ctx []Context, count uint, size uint) unsafe.Pointer {
	cctx, _ := unpackArgSContext(ctx)
	ccount, _ := (C.size_t)(count), cgoAllocsUnknown
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	__ret := C.fz_malloc_array_no_throw(cctx, ccount, csize)
	packSContext(ctx, cctx)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// ResizeArrayNoThrow function as declared in fitz/context.h:536
func ResizeArrayNoThrow(ctx []Context, p unsafe.Pointer, count uint, size uint) unsafe.Pointer {
	cctx, _ := unpackArgSContext(ctx)
	cp, _ := p, cgoAllocsUnknown
	ccount, _ := (C.size_t)(count), cgoAllocsUnknown
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	__ret := C.fz_resize_array_no_throw(cctx, cp, ccount, csize)
	packSContext(ctx, cctx)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// StrdupNoThrow function as declared in fitz/context.h:546
func StrdupNoThrow(ctx []Context, s string) *byte {
	cctx, _ := unpackArgSContext(ctx)
	cs, _ := unpackPCharString(s)
	__ret := C.fz_strdup_no_throw(cctx, cs)
	packSContext(ctx, cctx)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// GenId function as declared in fitz/context.h:552
func GenId(ctx []Context) int32 {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_gen_id(cctx)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

var AllocDefault AllocContext
var LocksDefault LocksContext

// AssertLockHeld function as declared in fitz/context.h:572
func AssertLockHeld(ctx []Context, lock int32) {
	cctx, _ := unpackArgSContext(ctx)
	clock, _ := (C.int)(lock), cgoAllocsUnknown
	C.fz_assert_lock_held(cctx, clock)
	packSContext(ctx, cctx)
}

// AssertLockNotHeld function as declared in fitz/context.h:573
func AssertLockNotHeld(ctx []Context, lock int32) {
	cctx, _ := unpackArgSContext(ctx)
	clock, _ := (C.int)(lock), cgoAllocsUnknown
	C.fz_assert_lock_not_held(cctx, clock)
	packSContext(ctx, cctx)
}

// LockDebugLock function as declared in fitz/context.h:574
func LockDebugLock(ctx []Context, lock int32) {
	cctx, _ := unpackArgSContext(ctx)
	clock, _ := (C.int)(lock), cgoAllocsUnknown
	C.fz_lock_debug_lock(cctx, clock)
	packSContext(ctx, cctx)
}

// LockDebugUnlock function as declared in fitz/context.h:575
func LockDebugUnlock(ctx []Context, lock int32) {
	cctx, _ := unpackArgSContext(ctx)
	clock, _ := (C.int)(lock), cgoAllocsUnknown
	C.fz_lock_debug_unlock(cctx, clock)
	packSContext(ctx, cctx)
}

// Lock function as declared in fitz/context.h:587
func Lock(ctx []Context, lock int32) {
	cctx, _ := unpackArgSContext(ctx)
	clock, _ := (C.int)(lock), cgoAllocsUnknown
	C.fz_lock(cctx, clock)
	packSContext(ctx, cctx)
}

// Unlock function as declared in fitz/context.h:594
func Unlock(ctx []Context, lock int32) {
	cctx, _ := unpackArgSContext(ctx)
	clock, _ := (C.int)(lock), cgoAllocsUnknown
	C.fz_unlock(cctx, clock)
	packSContext(ctx, cctx)
}

// KeepImp function as declared in fitz/context.h:600
func KeepImp(ctx []Context, p unsafe.Pointer, refs []int32) unsafe.Pointer {
	cctx, _ := unpackArgSContext(ctx)
	cp, _ := p, cgoAllocsUnknown
	crefs, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&refs)).Data)), cgoAllocsUnknown
	__ret := C.fz_keep_imp(cctx, cp, crefs)
	packSContext(ctx, cctx)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// KeepImp8 function as declared in fitz/context.h:617
func KeepImp8(ctx []Context, p unsafe.Pointer, refs []byte) unsafe.Pointer {
	cctx, _ := unpackArgSContext(ctx)
	cp, _ := p, cgoAllocsUnknown
	crefs, _ := (*C.int8_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&refs)).Data)), cgoAllocsUnknown
	__ret := C.fz_keep_imp8(cctx, cp, crefs)
	packSContext(ctx, cctx)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// KeepImp16 function as declared in fitz/context.h:634
func KeepImp16(ctx []Context, p unsafe.Pointer, refs []int16) unsafe.Pointer {
	cctx, _ := unpackArgSContext(ctx)
	cp, _ := p, cgoAllocsUnknown
	crefs, _ := (*C.int16_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&refs)).Data)), cgoAllocsUnknown
	__ret := C.fz_keep_imp16(cctx, cp, crefs)
	packSContext(ctx, cctx)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// DropImp function as declared in fitz/context.h:652
func DropImp(ctx []Context, p unsafe.Pointer, refs []int32) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cp, _ := p, cgoAllocsUnknown
	crefs, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&refs)).Data)), cgoAllocsUnknown
	__ret := C.fz_drop_imp(cctx, cp, crefs)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// DropImp8 function as declared in fitz/context.h:673
func DropImp8(ctx []Context, p unsafe.Pointer, refs []byte) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cp, _ := p, cgoAllocsUnknown
	crefs, _ := (*C.int8_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&refs)).Data)), cgoAllocsUnknown
	__ret := C.fz_drop_imp8(cctx, cp, crefs)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// DropImp16 function as declared in fitz/context.h:694
func DropImp16(ctx []Context, p unsafe.Pointer, refs []int16) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cp, _ := p, cgoAllocsUnknown
	crefs, _ := (*C.int16_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&refs)).Data)), cgoAllocsUnknown
	__ret := C.fz_drop_imp16(cctx, cp, crefs)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// Mul255 function as declared in fitz/geometry.h:9
func Mul255(a int32, b int32) int32 {
	ca, _ := (C.int)(a), cgoAllocsUnknown
	cb, _ := (C.int)(b), cgoAllocsUnknown
	__ret := C.fz_mul255(ca, cb)
	__v := (int32)(__ret)
	return __v
}

// Atof function as declared in fitz/geometry.h:44
func Atof(s string) float32 {
	cs, _ := unpackPCharString(s)
	__ret := C.fz_atof(cs)
	__v := (float32)(__ret)
	return __v
}

// Atoi function as declared in fitz/geometry.h:49
func Atoi(s string) int32 {
	cs, _ := unpackPCharString(s)
	__ret := C.fz_atoi(cs)
	__v := (int32)(__ret)
	return __v
}

// Atoo function as declared in fitz/geometry.h:51
func Atoo(s string) Off {
	cs, _ := unpackPCharString(s)
	__ret := C.fz_atoo(cs)
	__v := (Off)(__ret)
	return __v
}

// Abs function as declared in fitz/geometry.h:58
func Abs(f float32) float32 {
	cf, _ := (C.float)(f), cgoAllocsUnknown
	__ret := C.fz_abs(cf)
	__v := (float32)(__ret)
	return __v
}

// Absi function as declared in fitz/geometry.h:63
func Absi(i int32) int32 {
	ci, _ := (C.int)(i), cgoAllocsUnknown
	__ret := C.fz_absi(ci)
	__v := (int32)(__ret)
	return __v
}

// Min function as declared in fitz/geometry.h:68
func Min(a float32, b float32) float32 {
	ca, _ := (C.float)(a), cgoAllocsUnknown
	cb, _ := (C.float)(b), cgoAllocsUnknown
	__ret := C.fz_min(ca, cb)
	__v := (float32)(__ret)
	return __v
}

// Mini function as declared in fitz/geometry.h:73
func Mini(a int32, b int32) int32 {
	ca, _ := (C.int)(a), cgoAllocsUnknown
	cb, _ := (C.int)(b), cgoAllocsUnknown
	__ret := C.fz_mini(ca, cb)
	__v := (int32)(__ret)
	return __v
}

// Minz function as declared in fitz/geometry.h:78
func Minz(a uint, b uint) uint {
	ca, _ := (C.size_t)(a), cgoAllocsUnknown
	cb, _ := (C.size_t)(b), cgoAllocsUnknown
	__ret := C.fz_minz(ca, cb)
	__v := (uint)(__ret)
	return __v
}

// Max function as declared in fitz/geometry.h:83
func Max(a float32, b float32) float32 {
	ca, _ := (C.float)(a), cgoAllocsUnknown
	cb, _ := (C.float)(b), cgoAllocsUnknown
	__ret := C.fz_max(ca, cb)
	__v := (float32)(__ret)
	return __v
}

// Maxi function as declared in fitz/geometry.h:88
func Maxi(a int32, b int32) int32 {
	ca, _ := (C.int)(a), cgoAllocsUnknown
	cb, _ := (C.int)(b), cgoAllocsUnknown
	__ret := C.fz_maxi(ca, cb)
	__v := (int32)(__ret)
	return __v
}

// Maxo function as declared in fitz/geometry.h:93
func Maxo(a Off, b Off) Off {
	ca, _ := (C.fz_off_t)(a), cgoAllocsUnknown
	cb, _ := (C.fz_off_t)(b), cgoAllocsUnknown
	__ret := C.fz_maxo(ca, cb)
	__v := (Off)(__ret)
	return __v
}

// Clamp function as declared in fitz/geometry.h:98
func Clamp(f float32, min float32, max float32) float32 {
	cf, _ := (C.float)(f), cgoAllocsUnknown
	cmin, _ := (C.float)(min), cgoAllocsUnknown
	cmax, _ := (C.float)(max), cgoAllocsUnknown
	__ret := C.fz_clamp(cf, cmin, cmax)
	__v := (float32)(__ret)
	return __v
}

// Clampi function as declared in fitz/geometry.h:103
func Clampi(i int32, min int32, max int32) int32 {
	ci, _ := (C.int)(i), cgoAllocsUnknown
	cmin, _ := (C.int)(min), cgoAllocsUnknown
	cmax, _ := (C.int)(max), cgoAllocsUnknown
	__ret := C.fz_clampi(ci, cmin, cmax)
	__v := (int32)(__ret)
	return __v
}

// Clampd function as declared in fitz/geometry.h:108
func Clampd(d float64, min float64, max float64) float64 {
	cd, _ := (C.double)(d), cgoAllocsUnknown
	cmin, _ := (C.double)(min), cgoAllocsUnknown
	cmax, _ := (C.double)(max), cgoAllocsUnknown
	__ret := C.fz_clampd(cd, cmin, cmax)
	__v := (float64)(__ret)
	return __v
}

// Clampp function as declared in fitz/geometry.h:113
func Clampp(p unsafe.Pointer, min unsafe.Pointer, max unsafe.Pointer) unsafe.Pointer {
	cp, _ := p, cgoAllocsUnknown
	cmin, _ := min, cgoAllocsUnknown
	cmax, _ := max, cgoAllocsUnknown
	__ret := C.fz_clampp(cp, cmin, cmax)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// RectMin function as declared in fitz/geometry.h:157
func RectMin(f []Rect) *Point {
	cf, _ := unpackArgSRect(f)
	__ret := C.fz_rect_min(cf)
	packSRect(f, cf)
	__v := NewPointRef(unsafe.Pointer(__ret))
	return __v
}

// RectMax function as declared in fitz/geometry.h:165
func RectMax(f []Rect) *Point {
	cf, _ := unpackArgSRect(f)
	__ret := C.fz_rect_max(cf)
	packSRect(f, cf)
	__v := NewPointRef(unsafe.Pointer(__ret))
	return __v
}

var UnitRect Rect
var EmptyRect Rect
var EmptyIrect Irect
var InfiniteRect Rect
var InfiniteIrect Irect

// IsEmptyRect function as declared in fitz/geometry.h:213
func IsEmptyRect(r []Rect) int32 {
	cr, _ := unpackArgSRect(r)
	__ret := C.fz_is_empty_rect(cr)
	packSRect(r, cr)
	__v := (int32)(__ret)
	return __v
}

// IsEmptyIrect function as declared in fitz/geometry.h:219
func IsEmptyIrect(r []Irect) int32 {
	cr, _ := unpackArgSIrect(r)
	__ret := C.fz_is_empty_irect(cr)
	packSIrect(r, cr)
	__v := (int32)(__ret)
	return __v
}

// IsInfiniteRect function as declared in fitz/geometry.h:231
func IsInfiniteRect(r []Rect) int32 {
	cr, _ := unpackArgSRect(r)
	__ret := C.fz_is_infinite_rect(cr)
	packSRect(r, cr)
	__v := (int32)(__ret)
	return __v
}

// IsInfiniteIrect function as declared in fitz/geometry.h:244
func IsInfiniteIrect(r []Irect) int32 {
	cr, _ := unpackArgSIrect(r)
	__ret := C.fz_is_infinite_irect(cr)
	packSIrect(r, cr)
	__v := (int32)(__ret)
	return __v
}

var Identity Matrix

// CopyMatrix function as declared in fitz/geometry.h:273
func CopyMatrix(m []Matrix, s []Matrix) *Matrix {
	cm, _ := unpackArgSMatrix(m)
	cs, _ := unpackArgSMatrix(s)
	__ret := C.fz_copy_matrix(cm, cs)
	packSMatrix(s, cs)
	packSMatrix(m, cm)
	__v := NewMatrixRef(unsafe.Pointer(__ret))
	return __v
}

// Concat function as declared in fitz/geometry.h:287
func Concat(result []Matrix, left []Matrix, right []Matrix) *Matrix {
	cresult, _ := unpackArgSMatrix(result)
	cleft, _ := unpackArgSMatrix(left)
	cright, _ := unpackArgSMatrix(right)
	__ret := C.fz_concat(cresult, cleft, cright)
	packSMatrix(right, cright)
	packSMatrix(left, cleft)
	packSMatrix(result, cresult)
	__v := NewMatrixRef(unsafe.Pointer(__ret))
	return __v
}

// Scale function as declared in fitz/geometry.h:302
func Scale(m []Matrix, sx float32, sy float32) *Matrix {
	cm, _ := unpackArgSMatrix(m)
	csx, _ := (C.float)(sx), cgoAllocsUnknown
	csy, _ := (C.float)(sy), cgoAllocsUnknown
	__ret := C.fz_scale(cm, csx, csy)
	packSMatrix(m, cm)
	__v := NewMatrixRef(unsafe.Pointer(__ret))
	return __v
}

// PreScale function as declared in fitz/geometry.h:315
func PreScale(m []Matrix, sx float32, sy float32) *Matrix {
	cm, _ := unpackArgSMatrix(m)
	csx, _ := (C.float)(sx), cgoAllocsUnknown
	csy, _ := (C.float)(sy), cgoAllocsUnknown
	__ret := C.fz_pre_scale(cm, csx, csy)
	packSMatrix(m, cm)
	__v := NewMatrixRef(unsafe.Pointer(__ret))
	return __v
}

// PostScale function as declared in fitz/geometry.h:328
func PostScale(m []Matrix, sx float32, sy float32) *Matrix {
	cm, _ := unpackArgSMatrix(m)
	csx, _ := (C.float)(sx), cgoAllocsUnknown
	csy, _ := (C.float)(sy), cgoAllocsUnknown
	__ret := C.fz_post_scale(cm, csx, csy)
	packSMatrix(m, cm)
	__v := NewMatrixRef(unsafe.Pointer(__ret))
	return __v
}

// Shear function as declared in fitz/geometry.h:342
func Shear(m []Matrix, sx float32, sy float32) *Matrix {
	cm, _ := unpackArgSMatrix(m)
	csx, _ := (C.float)(sx), cgoAllocsUnknown
	csy, _ := (C.float)(sy), cgoAllocsUnknown
	__ret := C.fz_shear(cm, csx, csy)
	packSMatrix(m, cm)
	__v := NewMatrixRef(unsafe.Pointer(__ret))
	return __v
}

// PreShear function as declared in fitz/geometry.h:356
func PreShear(m []Matrix, sx float32, sy float32) *Matrix {
	cm, _ := unpackArgSMatrix(m)
	csx, _ := (C.float)(sx), cgoAllocsUnknown
	csy, _ := (C.float)(sy), cgoAllocsUnknown
	__ret := C.fz_pre_shear(cm, csx, csy)
	packSMatrix(m, cm)
	__v := NewMatrixRef(unsafe.Pointer(__ret))
	return __v
}

// Rotate function as declared in fitz/geometry.h:371
func Rotate(m []Matrix, degrees float32) *Matrix {
	cm, _ := unpackArgSMatrix(m)
	cdegrees, _ := (C.float)(degrees), cgoAllocsUnknown
	__ret := C.fz_rotate(cm, cdegrees)
	packSMatrix(m, cm)
	__v := NewMatrixRef(unsafe.Pointer(__ret))
	return __v
}

// PreRotate function as declared in fitz/geometry.h:386
func PreRotate(m []Matrix, degrees float32) *Matrix {
	cm, _ := unpackArgSMatrix(m)
	cdegrees, _ := (C.float)(degrees), cgoAllocsUnknown
	__ret := C.fz_pre_rotate(cm, cdegrees)
	packSMatrix(m, cm)
	__v := NewMatrixRef(unsafe.Pointer(__ret))
	return __v
}

// Translate function as declared in fitz/geometry.h:401
func Translate(m []Matrix, tx float32, ty float32) *Matrix {
	cm, _ := unpackArgSMatrix(m)
	ctx, _ := (C.float)(tx), cgoAllocsUnknown
	cty, _ := (C.float)(ty), cgoAllocsUnknown
	__ret := C.fz_translate(cm, ctx, cty)
	packSMatrix(m, cm)
	__v := NewMatrixRef(unsafe.Pointer(__ret))
	return __v
}

// PreTranslate function as declared in fitz/geometry.h:414
func PreTranslate(m []Matrix, tx float32, ty float32) *Matrix {
	cm, _ := unpackArgSMatrix(m)
	ctx, _ := (C.float)(tx), cgoAllocsUnknown
	cty, _ := (C.float)(ty), cgoAllocsUnknown
	__ret := C.fz_pre_translate(cm, ctx, cty)
	packSMatrix(m, cm)
	__v := NewMatrixRef(unsafe.Pointer(__ret))
	return __v
}

// InvertMatrix function as declared in fitz/geometry.h:427
func InvertMatrix(inverse []Matrix, matrix []Matrix) *Matrix {
	cinverse, _ := unpackArgSMatrix(inverse)
	cmatrix, _ := unpackArgSMatrix(matrix)
	__ret := C.fz_invert_matrix(cinverse, cmatrix)
	packSMatrix(matrix, cmatrix)
	packSMatrix(inverse, cinverse)
	__v := NewMatrixRef(unsafe.Pointer(__ret))
	return __v
}

// TryInvertMatrix function as declared in fitz/geometry.h:439
func TryInvertMatrix(inverse []Matrix, matrix []Matrix) int32 {
	cinverse, _ := unpackArgSMatrix(inverse)
	cmatrix, _ := unpackArgSMatrix(matrix)
	__ret := C.fz_try_invert_matrix(cinverse, cmatrix)
	packSMatrix(matrix, cmatrix)
	packSMatrix(inverse, cinverse)
	__v := (int32)(__ret)
	return __v
}

// IsRectilinear function as declared in fitz/geometry.h:449
func IsRectilinear(m []Matrix) int32 {
	cm, _ := unpackArgSMatrix(m)
	__ret := C.fz_is_rectilinear(cm)
	packSMatrix(m, cm)
	__v := (int32)(__ret)
	return __v
}

// MatrixExpansion function as declared in fitz/geometry.h:454
func MatrixExpansion(m []Matrix) float32 {
	cm, _ := unpackArgSMatrix(m)
	__ret := C.fz_matrix_expansion(cm)
	packSMatrix(m, cm)
	__v := (float32)(__ret)
	return __v
}

// IntersectRect function as declared in fitz/geometry.h:467
func IntersectRect(a []Rect, b []Rect) *Rect {
	ca, _ := unpackArgSRect(a)
	cb, _ := unpackArgSRect(b)
	__ret := C.fz_intersect_rect(ca, cb)
	packSRect(b, cb)
	packSRect(a, ca)
	__v := NewRectRef(unsafe.Pointer(__ret))
	return __v
}

// IntersectIrect function as declared in fitz/geometry.h:475
func IntersectIrect(a []Irect, b []Irect) *Irect {
	ca, _ := unpackArgSIrect(a)
	cb, _ := unpackArgSIrect(b)
	__ret := C.fz_intersect_irect(ca, cb)
	packSIrect(b, cb)
	packSIrect(a, ca)
	__v := NewIrectRef(unsafe.Pointer(__ret))
	return __v
}

// UnionRect function as declared in fitz/geometry.h:487
func UnionRect(a []Rect, b []Rect) *Rect {
	ca, _ := unpackArgSRect(a)
	cb, _ := unpackArgSRect(b)
	__ret := C.fz_union_rect(ca, cb)
	packSRect(b, cb)
	packSRect(a, ca)
	__v := NewRectRef(unsafe.Pointer(__ret))
	return __v
}

// IrectFromRect function as declared in fitz/geometry.h:505
func IrectFromRect(bbox []Irect, rect []Rect) *Irect {
	cbbox, _ := unpackArgSIrect(bbox)
	crect, _ := unpackArgSRect(rect)
	__ret := C.fz_irect_from_rect(cbbox, crect)
	packSRect(rect, crect)
	packSIrect(bbox, cbbox)
	__v := NewIrectRef(unsafe.Pointer(__ret))
	return __v
}

// RoundRect function as declared in fitz/geometry.h:521
func RoundRect(bbox []Irect, rect []Rect) *Irect {
	cbbox, _ := unpackArgSIrect(bbox)
	crect, _ := unpackArgSRect(rect)
	__ret := C.fz_round_rect(cbbox, crect)
	packSRect(rect, crect)
	packSIrect(bbox, cbbox)
	__v := NewIrectRef(unsafe.Pointer(__ret))
	return __v
}

// RectFromIrect function as declared in fitz/geometry.h:535
func RectFromIrect(rect []Rect, bbox []Irect) *Rect {
	crect, _ := unpackArgSRect(rect)
	cbbox, _ := unpackArgSIrect(bbox)
	__ret := C.fz_rect_from_irect(crect, cbbox)
	packSIrect(bbox, cbbox)
	packSRect(rect, crect)
	__v := NewRectRef(unsafe.Pointer(__ret))
	return __v
}

// ExpandRect function as declared in fitz/geometry.h:540
func ExpandRect(b []Rect, expand float32) *Rect {
	cb, _ := unpackArgSRect(b)
	cexpand, _ := (C.float)(expand), cgoAllocsUnknown
	__ret := C.fz_expand_rect(cb, cexpand)
	packSRect(b, cb)
	__v := NewRectRef(unsafe.Pointer(__ret))
	return __v
}

// IncludePointInRect function as declared in fitz/geometry.h:548
func IncludePointInRect(r []Rect, p []Point) *Rect {
	cr, _ := unpackArgSRect(r)
	cp, _ := unpackArgSPoint(p)
	__ret := C.fz_include_point_in_rect(cr, cp)
	packSPoint(p, cp)
	packSRect(r, cr)
	__v := NewRectRef(unsafe.Pointer(__ret))
	return __v
}

// TranslateIrect function as declared in fitz/geometry.h:555
func TranslateIrect(a []Irect, xoff int32, yoff int32) *Irect {
	ca, _ := unpackArgSIrect(a)
	cxoff, _ := (C.int)(xoff), cgoAllocsUnknown
	cyoff, _ := (C.int)(yoff), cgoAllocsUnknown
	__ret := C.fz_translate_irect(ca, cxoff, cyoff)
	packSIrect(a, ca)
	__v := NewIrectRef(unsafe.Pointer(__ret))
	return __v
}

// ContainsRect function as declared in fitz/geometry.h:562
func ContainsRect(a []Rect, b []Rect) int32 {
	ca, _ := unpackArgSRect(a)
	cb, _ := unpackArgSRect(b)
	__ret := C.fz_contains_rect(ca, cb)
	packSRect(b, cb)
	packSRect(a, ca)
	__v := (int32)(__ret)
	return __v
}

// TransformPoint function as declared in fitz/geometry.h:575
func TransformPoint(point []Point, transform []Matrix) *Point {
	cpoint, _ := unpackArgSPoint(point)
	ctransform, _ := unpackArgSMatrix(transform)
	__ret := C.fz_transform_point(cpoint, ctransform)
	packSMatrix(transform, ctransform)
	packSPoint(point, cpoint)
	__v := NewPointRef(unsafe.Pointer(__ret))
	return __v
}

// TransformPointXy function as declared in fitz/geometry.h:576
func TransformPointXy(point []Point, transform []Matrix, x float32, y float32) *Point {
	cpoint, _ := unpackArgSPoint(point)
	ctransform, _ := unpackArgSMatrix(transform)
	cx, _ := (C.float)(x), cgoAllocsUnknown
	cy, _ := (C.float)(y), cgoAllocsUnknown
	__ret := C.fz_transform_point_xy(cpoint, ctransform, cx, cy)
	packSMatrix(transform, ctransform)
	packSPoint(point, cpoint)
	__v := NewPointRef(unsafe.Pointer(__ret))
	return __v
}

// TransformVector function as declared in fitz/geometry.h:587
func TransformVector(vector []Point, transform []Matrix) *Point {
	cvector, _ := unpackArgSPoint(vector)
	ctransform, _ := unpackArgSMatrix(transform)
	__ret := C.fz_transform_vector(cvector, ctransform)
	packSMatrix(transform, ctransform)
	packSPoint(vector, cvector)
	__v := NewPointRef(unsafe.Pointer(__ret))
	return __v
}

// TransformRect function as declared in fitz/geometry.h:604
func TransformRect(rect []Rect, transform []Matrix) *Rect {
	crect, _ := unpackArgSRect(rect)
	ctransform, _ := unpackArgSMatrix(transform)
	__ret := C.fz_transform_rect(crect, ctransform)
	packSMatrix(transform, ctransform)
	packSRect(rect, crect)
	__v := NewRectRef(unsafe.Pointer(__ret))
	return __v
}

// NormalizeVector function as declared in fitz/geometry.h:609
func NormalizeVector(p []Point) {
	cp, _ := unpackArgSPoint(p)
	C.fz_normalize_vector(cp)
	packSPoint(p, cp)
}

// GridfitMatrix function as declared in fitz/geometry.h:611
func GridfitMatrix(asTiled int32, m []Matrix) {
	casTiled, _ := (C.int)(asTiled), cgoAllocsUnknown
	cm, _ := unpackArgSMatrix(m)
	C.fz_gridfit_matrix(casTiled, cm)
	packSMatrix(m, cm)
}

// MatrixMaxExpansion function as declared in fitz/geometry.h:613
func MatrixMaxExpansion(m []Matrix) float32 {
	cm, _ := unpackArgSMatrix(m)
	__ret := C.fz_matrix_max_expansion(cm)
	packSMatrix(m, cm)
	__v := (float32)(__ret)
	return __v
}

// Md5Init function as declared in fitz/crypt.h:27
func Md5Init(state []Md5) {
	cstate, _ := unpackArgSMd5(state)
	C.fz_md5_init(cstate)
	packSMd5(state, cstate)
}

// Md5Update function as declared in fitz/crypt.h:28
func Md5Update(state []Md5, input string, inlen uint) {
	cstate, _ := unpackArgSMd5(state)
	cinput, _ := unpackPUcharString(input)
	cinlen, _ := (C.size_t)(inlen), cgoAllocsUnknown
	C.fz_md5_update(cstate, cinput, cinlen)
	packSMd5(state, cstate)
}

// Md5Final function as declared in fitz/crypt.h:29
func Md5Final(state []Md5, digest *[16]byte) {
	cstate, _ := unpackArgSMd5(state)
	cdigest, _ := *(**C.uchar)(unsafe.Pointer(&digest)), cgoAllocsUnknown
	C.fz_md5_final(cstate, cdigest)
	packSMd5(state, cstate)
}

// Sha256Init function as declared in fitz/crypt.h:49
func Sha256Init(state []Sha256) {
	cstate, _ := unpackArgSSha256(state)
	C.fz_sha256_init(cstate)
	packSSha256(state, cstate)
}

// Sha256Update function as declared in fitz/crypt.h:50
func Sha256Update(state []Sha256, input string, inlen uint) {
	cstate, _ := unpackArgSSha256(state)
	cinput, _ := unpackPUcharString(input)
	cinlen, _ := (C.size_t)(inlen), cgoAllocsUnknown
	C.fz_sha256_update(cstate, cinput, cinlen)
	packSSha256(state, cstate)
}

// Sha256Final function as declared in fitz/crypt.h:51
func Sha256Final(state []Sha256, digest *[32]byte) {
	cstate, _ := unpackArgSSha256(state)
	cdigest, _ := *(**C.uchar)(unsafe.Pointer(&digest)), cgoAllocsUnknown
	C.fz_sha256_final(cstate, cdigest)
	packSSha256(state, cstate)
}

// Sha512Init function as declared in fitz/crypt.h:71
func Sha512Init(state []Sha512) {
	cstate, _ := unpackArgSSha512(state)
	C.fz_sha512_init(cstate)
	packSSha512(state, cstate)
}

// Sha512Update function as declared in fitz/crypt.h:72
func Sha512Update(state []Sha512, input string, inlen uint) {
	cstate, _ := unpackArgSSha512(state)
	cinput, _ := unpackPUcharString(input)
	cinlen, _ := (C.size_t)(inlen), cgoAllocsUnknown
	C.fz_sha512_update(cstate, cinput, cinlen)
	packSSha512(state, cstate)
}

// Sha512Final function as declared in fitz/crypt.h:73
func Sha512Final(state []Sha512, digest *[64]byte) {
	cstate, _ := unpackArgSSha512(state)
	cdigest, _ := *(**C.uchar)(unsafe.Pointer(&digest)), cgoAllocsUnknown
	C.fz_sha512_final(cstate, cdigest)
	packSSha512(state, cstate)
}

// Sha384Init function as declared in fitz/crypt.h:79
func Sha384Init(state []Sha384) {
	cstate, _ := unpackArgSSha384(state)
	C.fz_sha384_init(cstate)
	packSSha384(state, cstate)
}

// Sha384Update function as declared in fitz/crypt.h:80
func Sha384Update(state []Sha384, input string, inlen uint) {
	cstate, _ := unpackArgSSha384(state)
	cinput, _ := unpackPUcharString(input)
	cinlen, _ := (C.size_t)(inlen), cgoAllocsUnknown
	C.fz_sha384_update(cstate, cinput, cinlen)
	packSSha384(state, cstate)
}

// Sha384Final function as declared in fitz/crypt.h:81
func Sha384Final(state []Sha384, digest *[64]byte) {
	cstate, _ := unpackArgSSha384(state)
	cdigest, _ := *(**C.uchar)(unsafe.Pointer(&digest)), cgoAllocsUnknown
	C.fz_sha384_final(cstate, cdigest)
	packSSha384(state, cstate)
}

// Arc4Init function as declared in fitz/crypt.h:98
func Arc4Init(state []Arc4, key string, len uint) {
	cstate, _ := unpackArgSArc4(state)
	ckey, _ := unpackPUcharString(key)
	clen, _ := (C.size_t)(len), cgoAllocsUnknown
	C.fz_arc4_init(cstate, ckey, clen)
	packSArc4(state, cstate)
}

// Arc4Encrypt function as declared in fitz/crypt.h:99
func Arc4Encrypt(state []Arc4, dest []byte, src string, len uint) {
	cstate, _ := unpackArgSArc4(state)
	cdest, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dest)).Data)), cgoAllocsUnknown
	csrc, _ := unpackPUcharString(src)
	clen, _ := (C.size_t)(len), cgoAllocsUnknown
	C.fz_arc4_encrypt(cstate, cdest, csrc, clen)
	packSArc4(state, cstate)
}

// AesSetkeyEnc function as declared in fitz/crypt.h:119
func AesSetkeyEnc(ctx []Aes, key string, keysize int32) int32 {
	cctx, _ := unpackArgSAes(ctx)
	ckey, _ := unpackPUcharString(key)
	ckeysize, _ := (C.int)(keysize), cgoAllocsUnknown
	__ret := C.fz_aes_setkey_enc(cctx, ckey, ckeysize)
	packSAes(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// AesSetkeyDec function as declared in fitz/crypt.h:120
func AesSetkeyDec(ctx []Aes, key string, keysize int32) int32 {
	cctx, _ := unpackArgSAes(ctx)
	ckey, _ := unpackPUcharString(key)
	ckeysize, _ := (C.int)(keysize), cgoAllocsUnknown
	__ret := C.fz_aes_setkey_dec(cctx, ckey, ckeysize)
	packSAes(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// AesCryptCbc function as declared in fitz/crypt.h:121
func AesCryptCbc(ctx []Aes, mode int32, length uint, iv *[16]byte, input string, output []byte) {
	cctx, _ := unpackArgSAes(ctx)
	cmode, _ := (C.int)(mode), cgoAllocsUnknown
	clength, _ := (C.size_t)(length), cgoAllocsUnknown
	civ, _ := *(**C.uchar)(unsafe.Pointer(&iv)), cgoAllocsUnknown
	cinput, _ := unpackPUcharString(input)
	coutput, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&output)).Data)), cgoAllocsUnknown
	C.fz_aes_crypt_cbc(cctx, cmode, clength, civ, cinput, coutput)
	packSAes(ctx, cctx)
}

// Getopt function as declared in fitz/getopt.h:7
func Getopt(nargc int32, nargv [][]byte, ostr string) int32 {
	cnargc, _ := (C.int)(nargc), cgoAllocsUnknown
	cnargv, _ := unpackArgSSByte(nargv)
	costr, _ := unpackPCharString(ostr)
	__ret := C.fz_getopt(cnargc, cnargv, costr)
	packSSByte(nargv, cnargv)
	__v := (int32)(__ret)
	return __v
}

// NewHashTable function as declared in fitz/hash.h:24
func NewHashTable(ctx []Context, initialsize int32, keylen int32, lock int32, dropVal HashTableDropFn) *HashTable {
	cctx, _ := unpackArgSContext(ctx)
	cinitialsize, _ := (C.int)(initialsize), cgoAllocsUnknown
	ckeylen, _ := (C.int)(keylen), cgoAllocsUnknown
	clock, _ := (C.int)(lock), cgoAllocsUnknown
	cdropVal, _ := dropVal.PassRef()
	__ret := C.fz_new_hash_table(cctx, cinitialsize, ckeylen, clock, cdropVal)
	packSContext(ctx, cctx)
	__v := *(**HashTable)(unsafe.Pointer(&__ret))
	return __v
}

// DropHashTable function as declared in fitz/hash.h:25
func DropHashTable(ctx []Context, table []HashTable) {
	cctx, _ := unpackArgSContext(ctx)
	ctable, _ := (*C.fz_hash_table)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&table)).Data)), cgoAllocsUnknown
	C.fz_drop_hash_table(cctx, ctable)
	packSContext(ctx, cctx)
}

// HashFind function as declared in fitz/hash.h:27
func HashFind(ctx []Context, table []HashTable, key unsafe.Pointer) unsafe.Pointer {
	cctx, _ := unpackArgSContext(ctx)
	ctable, _ := (*C.fz_hash_table)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&table)).Data)), cgoAllocsUnknown
	ckey, _ := key, cgoAllocsUnknown
	__ret := C.fz_hash_find(cctx, ctable, ckey)
	packSContext(ctx, cctx)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// HashInsert function as declared in fitz/hash.h:28
func HashInsert(ctx []Context, table []HashTable, key unsafe.Pointer, val unsafe.Pointer) unsafe.Pointer {
	cctx, _ := unpackArgSContext(ctx)
	ctable, _ := (*C.fz_hash_table)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&table)).Data)), cgoAllocsUnknown
	ckey, _ := key, cgoAllocsUnknown
	cval, _ := val, cgoAllocsUnknown
	__ret := C.fz_hash_insert(cctx, ctable, ckey, cval)
	packSContext(ctx, cctx)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// HashRemove function as declared in fitz/hash.h:29
func HashRemove(ctx []Context, table []HashTable, key unsafe.Pointer) {
	cctx, _ := unpackArgSContext(ctx)
	ctable, _ := (*C.fz_hash_table)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&table)).Data)), cgoAllocsUnknown
	ckey, _ := key, cgoAllocsUnknown
	C.fz_hash_remove(cctx, ctable, ckey)
	packSContext(ctx, cctx)
}

// HashForEach function as declared in fitz/hash.h:30
func HashForEach(ctx []Context, table []HashTable, state unsafe.Pointer, callback HashTableForEachFn) {
	cctx, _ := unpackArgSContext(ctx)
	ctable, _ := (*C.fz_hash_table)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&table)).Data)), cgoAllocsUnknown
	cstate, _ := state, cgoAllocsUnknown
	ccallback, _ := callback.PassRef()
	C.fz_hash_for_each(cctx, ctable, cstate, ccallback)
	packSContext(ctx, cctx)
}

// NewOutput function as declared in fitz/output.h:80
func NewOutput(ctx []Context, state unsafe.Pointer, write OutputWriteFn, close OutputCloseFn) *Output {
	cctx, _ := unpackArgSContext(ctx)
	cstate, _ := state, cgoAllocsUnknown
	cwrite, _ := write.PassRef()
	cclose, _ := close.PassRef()
	__ret := C.fz_new_output(cctx, cstate, cwrite, cclose)
	packSContext(ctx, cctx)
	__v := NewOutputRef(unsafe.Pointer(__ret))
	return __v
}

// NewOutputWithFilePtr function as declared in fitz/output.h:91
func NewOutputWithFilePtr(ctx []Context, file []File, close int32) *Output {
	cctx, _ := unpackArgSContext(ctx)
	cfile, _ := unpackArgSFile(file)
	cclose, _ := (C.int)(close), cgoAllocsUnknown
	__ret := C.fz_new_output_with_file_ptr(cctx, cfile, cclose)
	packSFile(file, cfile)
	packSContext(ctx, cctx)
	__v := NewOutputRef(unsafe.Pointer(__ret))
	return __v
}

// NewOutputWithPath function as declared in fitz/output.h:102
func NewOutputWithPath(arg0 []Context, filename string, append int32) *Output {
	carg0, _ := unpackArgSContext(arg0)
	cfilename, _ := unpackPCharString(filename)
	cappend, _ := (C.int)(append), cgoAllocsUnknown
	__ret := C.fz_new_output_with_path(carg0, cfilename, cappend)
	packSContext(arg0, carg0)
	__v := NewOutputRef(unsafe.Pointer(__ret))
	return __v
}

// NewOutputWithBuffer function as declared in fitz/output.h:110
func NewOutputWithBuffer(ctx []Context, buf []Buffer) *Output {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	__ret := C.fz_new_output_with_buffer(cctx, cbuf)
	packSContext(ctx, cctx)
	__v := NewOutputRef(unsafe.Pointer(__ret))
	return __v
}

// Stdout function as declared in fitz/output.h:117
func Stdout(ctx []Context) *Output {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_stdout(cctx)
	packSContext(ctx, cctx)
	__v := NewOutputRef(unsafe.Pointer(__ret))
	return __v
}

// Stderr function as declared in fitz/output.h:124
func Stderr(ctx []Context) *Output {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_stderr(cctx)
	packSContext(ctx, cctx)
	__v := NewOutputRef(unsafe.Pointer(__ret))
	return __v
}

// SetStdout function as declared in fitz/output.h:132
func SetStdout(ctx []Context, out []Output) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	C.fz_set_stdout(cctx, cout)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// SetStderr function as declared in fitz/output.h:140
func SetStderr(ctx []Context, err []Output) {
	cctx, _ := unpackArgSContext(ctx)
	cerr, _ := unpackArgSOutput(err)
	C.fz_set_stderr(cctx, cerr)
	packSOutput(err, cerr)
	packSContext(ctx, cctx)
}

// WritePrintf function as declared in fitz/output.h:146
func WritePrintf(ctx []Context, out []Output, fmt string) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cfmt, _ := unpackPCharString(fmt)
	C.fz_write_printf(cctx, cout, cfmt)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// WriteVprintf function as declared in fitz/output.h:151
func WriteVprintf(ctx []Context, out []Output, fmt string, ap unsafe.Pointer) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cfmt, _ := unpackPCharString(fmt)
	cap, _ := ap, cgoAllocsUnknown
	C.fz_write_vprintf(cctx, cout, cfmt, cap)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// SeekOutput function as declared in fitz/output.h:159
func SeekOutput(ctx []Context, out []Output, off Off, whence int32) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	coff, _ := (C.fz_off_t)(off), cgoAllocsUnknown
	cwhence, _ := (C.int)(whence), cgoAllocsUnknown
	C.fz_seek_output(cctx, cout, coff, cwhence)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// TellOutput function as declared in fitz/output.h:166
func TellOutput(ctx []Context, out []Output) Off {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	__ret := C.fz_tell_output(cctx, cout)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
	__v := (Off)(__ret)
	return __v
}

// DropOutput function as declared in fitz/output.h:171
func DropOutput(arg0 []Context, arg1 []Output) {
	carg0, _ := unpackArgSContext(arg0)
	carg1, _ := unpackArgSOutput(arg1)
	C.fz_drop_output(carg0, carg1)
	packSOutput(arg1, carg1)
	packSContext(arg0, carg0)
}

// WriteData function as declared in fitz/output.h:179
func WriteData(ctx []Context, out []Output, data unsafe.Pointer, size uint) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cdata, _ := data, cgoAllocsUnknown
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	C.fz_write_data(cctx, cout, cdata, csize)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// WriteString function as declared in fitz/output.h:184
func WriteString(ctx []Context, out []Output, s string) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cs, _ := unpackPCharString(s)
	C.fz_write_string(cctx, cout, cs)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// WriteInt32Be function as declared in fitz/output.h:189
func WriteInt32Be(ctx []Context, out []Output, x int32) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cx, _ := (C.int)(x), cgoAllocsUnknown
	C.fz_write_int32_be(cctx, cout, cx)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// WriteInt32Le function as declared in fitz/output.h:194
func WriteInt32Le(ctx []Context, out []Output, x int32) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cx, _ := (C.int)(x), cgoAllocsUnknown
	C.fz_write_int32_le(cctx, cout, cx)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// WriteInt16Be function as declared in fitz/output.h:199
func WriteInt16Be(ctx []Context, out []Output, x int32) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cx, _ := (C.int)(x), cgoAllocsUnknown
	C.fz_write_int16_be(cctx, cout, cx)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// WriteInt16Le function as declared in fitz/output.h:204
func WriteInt16Le(ctx []Context, out []Output, x int32) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cx, _ := (C.int)(x), cgoAllocsUnknown
	C.fz_write_int16_le(cctx, cout, cx)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// WriteByte function as declared in fitz/output.h:209
func WriteByte(ctx []Context, out []Output, x byte) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cx, _ := (C.uchar)(x), cgoAllocsUnknown
	C.fz_write_byte(cctx, cout, cx)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// WriteRune function as declared in fitz/output.h:214
func WriteRune(ctx []Context, out []Output, rune int32) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	crune, _ := (C.int)(rune), cgoAllocsUnknown
	C.fz_write_rune(cctx, cout, crune)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// WriteBase64 function as declared in fitz/output.h:219
func WriteBase64(ctx []Context, out []Output, data string, size int32, newline int32) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cdata, _ := unpackPUcharString(data)
	csize, _ := (C.int)(size), cgoAllocsUnknown
	cnewline, _ := (C.int)(newline), cgoAllocsUnknown
	C.fz_write_base64(cctx, cout, cdata, csize, cnewline)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// WriteBase64Buffer function as declared in fitz/output.h:220
func WriteBase64Buffer(ctx []Context, out []Output, data []Buffer, newline int32) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cdata, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	cnewline, _ := (C.int)(newline), cgoAllocsUnknown
	C.fz_write_base64_buffer(cctx, cout, cdata, cnewline)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// FormatString function as declared in fitz/output.h:240
func FormatString(ctx []Context, user unsafe.Pointer, emit *func(ctx []Context, user unsafe.Pointer, c int32), fmt string, args unsafe.Pointer) {
	cctx, _ := unpackArgSContext(ctx)
	cuser, _ := user, cgoAllocsUnknown
	cemit, _ := emit.PassRef()
	cfmt, _ := unpackPCharString(fmt)
	cargs, _ := args, cgoAllocsUnknown
	C.fz_format_string(cctx, cuser, cemit, cfmt, cargs)
	packSContext(ctx, cctx)
}

// Vsnprintf function as declared in fitz/output.h:245
func Vsnprintf(buffer []byte, space uint, fmt string, args unsafe.Pointer) uint {
	cbuffer, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buffer)).Data)), cgoAllocsUnknown
	cspace, _ := (C.size_t)(space), cgoAllocsUnknown
	cfmt, _ := unpackPCharString(fmt)
	cargs, _ := args, cgoAllocsUnknown
	__ret := C.fz_vsnprintf(cbuffer, cspace, cfmt, cargs)
	__v := (uint)(__ret)
	return __v
}

// Snprintf function as declared in fitz/output.h:250
func Snprintf(buffer []byte, space uint, fmt string) uint {
	cbuffer, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buffer)).Data)), cgoAllocsUnknown
	cspace, _ := (C.size_t)(space), cgoAllocsUnknown
	cfmt, _ := unpackPCharString(fmt)
	__ret := C.fz_snprintf(cbuffer, cspace, cfmt)
	__v := (uint)(__ret)
	return __v
}

// Asprintf function as declared in fitz/output.h:255
func Asprintf(ctx []Context, fmt string) *byte {
	cctx, _ := unpackArgSContext(ctx)
	cfmt, _ := unpackPCharString(fmt)
	__ret := C.fz_asprintf(cctx, cfmt)
	packSContext(ctx, cctx)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// Tempfilename function as declared in fitz/output.h:266
func Tempfilename(ctx []Context, base string, hint string) *byte {
	cctx, _ := unpackArgSContext(ctx)
	cbase, _ := unpackPCharString(base)
	chint, _ := unpackPCharString(hint)
	__ret := C.fz_tempfilename(cctx, cbase, chint)
	packSContext(ctx, cctx)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// SaveBuffer function as declared in fitz/output.h:271
func SaveBuffer(ctx []Context, buf []Buffer, filename string) {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	cfilename, _ := unpackPCharString(filename)
	C.fz_save_buffer(cctx, cbuf, cfilename)
	packSContext(ctx, cctx)
}

// KeepBuffer function as declared in fitz/buffer.h:20
func KeepBuffer(ctx []Context, buf []Buffer) *Buffer {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	__ret := C.fz_keep_buffer(cctx, cbuf)
	packSContext(ctx, cctx)
	__v := *(**Buffer)(unsafe.Pointer(&__ret))
	return __v
}

// DropBuffer function as declared in fitz/buffer.h:25
func DropBuffer(ctx []Context, buf []Buffer) {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	C.fz_drop_buffer(cctx, cbuf)
	packSContext(ctx, cctx)
}

// BufferStorage function as declared in fitz/buffer.h:34
func BufferStorage(ctx []Context, buf []Buffer, datap [][]byte) uint {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	cdatap, _ := unpackArgSSByte(datap)
	__ret := C.fz_buffer_storage(cctx, cbuf, cdatap)
	packSSByte(datap, cdatap)
	packSContext(ctx, cctx)
	__v := (uint)(__ret)
	return __v
}

// StringFromBuffer function as declared in fitz/buffer.h:40
func StringFromBuffer(ctx []Context, buf []Buffer) string {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	__ret := C.fz_string_from_buffer(cctx, cbuf)
	packSContext(ctx, cctx)
	__v := packPCharString(__ret)
	return __v
}

// NewBuffer function as declared in fitz/buffer.h:49
func NewBuffer(ctx []Context, capacity uint) *Buffer {
	cctx, _ := unpackArgSContext(ctx)
	ccapacity, _ := (C.size_t)(capacity), cgoAllocsUnknown
	__ret := C.fz_new_buffer(cctx, ccapacity)
	packSContext(ctx, cctx)
	__v := *(**Buffer)(unsafe.Pointer(&__ret))
	return __v
}

// NewBufferFromData function as declared in fitz/buffer.h:64
func NewBufferFromData(ctx []Context, data []byte, size uint) *Buffer {
	cctx, _ := unpackArgSContext(ctx)
	cdata, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	__ret := C.fz_new_buffer_from_data(cctx, cdata, csize)
	packSContext(ctx, cctx)
	__v := *(**Buffer)(unsafe.Pointer(&__ret))
	return __v
}

// NewBufferFromSharedData function as declared in fitz/buffer.h:69
func NewBufferFromSharedData(ctx []Context, data string, size uint) *Buffer {
	cctx, _ := unpackArgSContext(ctx)
	cdata, _ := unpackPUcharString(data)
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	__ret := C.fz_new_buffer_from_shared_data(cctx, cdata, csize)
	packSContext(ctx, cctx)
	__v := *(**Buffer)(unsafe.Pointer(&__ret))
	return __v
}

// NewBufferFromBase64 function as declared in fitz/buffer.h:74
func NewBufferFromBase64(ctx []Context, data string, size uint) *Buffer {
	cctx, _ := unpackArgSContext(ctx)
	cdata, _ := unpackPCharString(data)
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	__ret := C.fz_new_buffer_from_base64(cctx, cdata, csize)
	packSContext(ctx, cctx)
	__v := *(**Buffer)(unsafe.Pointer(&__ret))
	return __v
}

// ResizeBuffer function as declared in fitz/buffer.h:83
func ResizeBuffer(ctx []Context, buf []Buffer, capacity uint) {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	ccapacity, _ := (C.size_t)(capacity), cgoAllocsUnknown
	C.fz_resize_buffer(cctx, cbuf, ccapacity)
	packSContext(ctx, cctx)
}

// GrowBuffer function as declared in fitz/buffer.h:89
func GrowBuffer(ctx []Context, buf []Buffer) {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	C.fz_grow_buffer(cctx, cbuf)
	packSContext(ctx, cctx)
}

// TrimBuffer function as declared in fitz/buffer.h:94
func TrimBuffer(ctx []Context, buf []Buffer) {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	C.fz_trim_buffer(cctx, cbuf)
	packSContext(ctx, cctx)
}

// AppendBuffer function as declared in fitz/buffer.h:99
func AppendBuffer(ctx []Context, destination []Buffer, source []Buffer) {
	cctx, _ := unpackArgSContext(ctx)
	cdestination, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&destination)).Data)), cgoAllocsUnknown
	csource, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&source)).Data)), cgoAllocsUnknown
	C.fz_append_buffer(cctx, cdestination, csource)
	packSContext(ctx, cctx)
}

// AppendData function as declared in fitz/buffer.h:107
func AppendData(ctx []Context, buf []Buffer, data unsafe.Pointer, len uint) {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	cdata, _ := data, cgoAllocsUnknown
	clen, _ := (C.size_t)(len), cgoAllocsUnknown
	C.fz_append_data(cctx, cbuf, cdata, clen)
	packSContext(ctx, cctx)
}

// AppendString function as declared in fitz/buffer.h:108
func AppendString(ctx []Context, buf []Buffer, data string) {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	cdata, _ := unpackPCharString(data)
	C.fz_append_string(cctx, cbuf, cdata)
	packSContext(ctx, cctx)
}

// AppendByte function as declared in fitz/buffer.h:109
func AppendByte(ctx []Context, buf []Buffer, c int32) {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	cc, _ := (C.int)(c), cgoAllocsUnknown
	C.fz_append_byte(cctx, cbuf, cc)
	packSContext(ctx, cctx)
}

// AppendRune function as declared in fitz/buffer.h:110
func AppendRune(ctx []Context, buf []Buffer, c int32) {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	cc, _ := (C.int)(c), cgoAllocsUnknown
	C.fz_append_rune(cctx, cbuf, cc)
	packSContext(ctx, cctx)
}

// AppendInt32Le function as declared in fitz/buffer.h:111
func AppendInt32Le(ctx []Context, buf []Buffer, x int32) {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	cx, _ := (C.int)(x), cgoAllocsUnknown
	C.fz_append_int32_le(cctx, cbuf, cx)
	packSContext(ctx, cctx)
}

// AppendInt16Le function as declared in fitz/buffer.h:112
func AppendInt16Le(ctx []Context, buf []Buffer, x int32) {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	cx, _ := (C.int)(x), cgoAllocsUnknown
	C.fz_append_int16_le(cctx, cbuf, cx)
	packSContext(ctx, cctx)
}

// AppendInt32Be function as declared in fitz/buffer.h:113
func AppendInt32Be(ctx []Context, buf []Buffer, x int32) {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	cx, _ := (C.int)(x), cgoAllocsUnknown
	C.fz_append_int32_be(cctx, cbuf, cx)
	packSContext(ctx, cctx)
}

// AppendInt16Be function as declared in fitz/buffer.h:114
func AppendInt16Be(ctx []Context, buf []Buffer, x int32) {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	cx, _ := (C.int)(x), cgoAllocsUnknown
	C.fz_append_int16_be(cctx, cbuf, cx)
	packSContext(ctx, cctx)
}

// AppendBits function as declared in fitz/buffer.h:115
func AppendBits(ctx []Context, buf []Buffer, value int32, count int32) {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	cvalue, _ := (C.int)(value), cgoAllocsUnknown
	ccount, _ := (C.int)(count), cgoAllocsUnknown
	C.fz_append_bits(cctx, cbuf, cvalue, ccount)
	packSContext(ctx, cctx)
}

// AppendBitsPad function as declared in fitz/buffer.h:116
func AppendBitsPad(ctx []Context, buf []Buffer) {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	C.fz_append_bits_pad(cctx, cbuf)
	packSContext(ctx, cctx)
}

// AppendPrintf function as declared in fitz/buffer.h:117
func AppendPrintf(ctx []Context, buffer []Buffer, fmt string) {
	cctx, _ := unpackArgSContext(ctx)
	cbuffer, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buffer)).Data)), cgoAllocsUnknown
	cfmt, _ := unpackPCharString(fmt)
	C.fz_append_printf(cctx, cbuffer, cfmt)
	packSContext(ctx, cctx)
}

// AppendVprintf function as declared in fitz/buffer.h:118
func AppendVprintf(ctx []Context, buffer []Buffer, fmt string, args unsafe.Pointer) {
	cctx, _ := unpackArgSContext(ctx)
	cbuffer, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buffer)).Data)), cgoAllocsUnknown
	cfmt, _ := unpackPCharString(fmt)
	cargs, _ := args, cgoAllocsUnknown
	C.fz_append_vprintf(cctx, cbuffer, cfmt, cargs)
	packSContext(ctx, cctx)
}

// Append_String function as declared in fitz/buffer.h:119
func Append_String(ctx []Context, buffer []Buffer, text string) {
	cctx, _ := unpackArgSContext(ctx)
	cbuffer, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buffer)).Data)), cgoAllocsUnknown
	ctext, _ := unpackPCharString(text)
	C.fz_append_pdf_string(cctx, cbuffer, ctext)
	packSContext(ctx, cctx)
}

// TerminateBuffer function as declared in fitz/buffer.h:127
func TerminateBuffer(ctx []Context, buf []Buffer) {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	C.fz_terminate_buffer(cctx, cbuf)
	packSContext(ctx, cctx)
}

// Md5Buffer function as declared in fitz/buffer.h:132
func Md5Buffer(ctx []Context, buffer []Buffer, digest *[16]byte) {
	cctx, _ := unpackArgSContext(ctx)
	cbuffer, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buffer)).Data)), cgoAllocsUnknown
	cdigest, _ := *(**C.uchar)(unsafe.Pointer(&digest)), cgoAllocsUnknown
	C.fz_md5_buffer(cctx, cbuffer, cdigest)
	packSContext(ctx, cctx)
}

// BufferExtract function as declared in fitz/buffer.h:147
func BufferExtract(ctx []Context, buf []Buffer, data [][]byte) uint {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	cdata, _ := unpackArgSSByte(data)
	__ret := C.fz_buffer_extract(cctx, cbuf, cdata)
	packSSByte(data, cdata)
	packSContext(ctx, cctx)
	__v := (uint)(__ret)
	return __v
}

// Strsep function as declared in fitz/string-util.h:27
func Strsep(stringp [][]byte, delim string) *byte {
	cstringp, _ := unpackArgSSByte(stringp)
	cdelim, _ := unpackPCharString(delim)
	__ret := C.fz_strsep(cstringp, cdelim)
	packSSByte(stringp, cstringp)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// Strlcpy function as declared in fitz/string-util.h:42
func Strlcpy(dst []byte, src string, n uint) uint {
	cdst, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dst)).Data)), cgoAllocsUnknown
	csrc, _ := unpackPCharString(src)
	cn, _ := (C.size_t)(n), cgoAllocsUnknown
	__ret := C.fz_strlcpy(cdst, csrc, cn)
	__v := (uint)(__ret)
	return __v
}

// Strlcat function as declared in fitz/string-util.h:56
func Strlcat(dst []byte, src string, n uint) uint {
	cdst, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dst)).Data)), cgoAllocsUnknown
	csrc, _ := unpackPCharString(src)
	cn, _ := (C.size_t)(n), cgoAllocsUnknown
	__ret := C.fz_strlcat(cdst, csrc, cn)
	__v := (uint)(__ret)
	return __v
}

// Dirname function as declared in fitz/string-util.h:61
func Dirname(dir []byte, path string, dirsize uint) {
	cdir, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dir)).Data)), cgoAllocsUnknown
	cpath, _ := unpackPCharString(path)
	cdirsize, _ := (C.size_t)(dirsize), cgoAllocsUnknown
	C.fz_dirname(cdir, cpath, cdirsize)
}

// Urldecode function as declared in fitz/string-util.h:66
func Urldecode(url []byte) *byte {
	curl, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&url)).Data)), cgoAllocsUnknown
	__ret := C.fz_urldecode(curl)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// FormatOutputPath function as declared in fitz/string-util.h:75
func FormatOutputPath(ctx []Context, path []byte, size uint, fmt string, page int32) {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&path)).Data)), cgoAllocsUnknown
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	cfmt, _ := unpackPCharString(fmt)
	cpage, _ := (C.int)(page), cgoAllocsUnknown
	C.fz_format_output_path(cctx, cpath, csize, cfmt, cpage)
	packSContext(ctx, cctx)
}

// Cleanname function as declared in fitz/string-util.h:83
func Cleanname(name []byte) *byte {
	cname, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&name)).Data)), cgoAllocsUnknown
	__ret := C.fz_cleanname(cname)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// Strcasecmp function as declared in fitz/string-util.h:88
func Strcasecmp(a string, b string) int32 {
	ca, _ := unpackPCharString(a)
	cb, _ := unpackPCharString(b)
	__ret := C.fz_strcasecmp(ca, cb)
	__v := (int32)(__ret)
	return __v
}

// Chartorune function as declared in fitz/string-util.h:104
func Chartorune(rune []int32, str string) int32 {
	crune, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&rune)).Data)), cgoAllocsUnknown
	cstr, _ := unpackPCharString(str)
	__ret := C.fz_chartorune(crune, cstr)
	__v := (int32)(__ret)
	return __v
}

// Runetochar function as declared in fitz/string-util.h:115
func Runetochar(str []byte, rune int32) int32 {
	cstr, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&str)).Data)), cgoAllocsUnknown
	crune, _ := (C.int)(rune), cgoAllocsUnknown
	__ret := C.fz_runetochar(cstr, crune)
	__v := (int32)(__ret)
	return __v
}

// Runelen function as declared in fitz/string-util.h:124
func Runelen(rune int32) int32 {
	crune, _ := (C.int)(rune), cgoAllocsUnknown
	__ret := C.fz_runelen(crune)
	__v := (int32)(__ret)
	return __v
}

// Utflen function as declared in fitz/string-util.h:134
func Utflen(s string) int32 {
	cs, _ := unpackPCharString(s)
	__ret := C.fz_utflen(cs)
	__v := (int32)(__ret)
	return __v
}

// Strtof function as declared in fitz/string-util.h:142
func Strtof(s string, es [][]byte) float32 {
	cs, _ := unpackPCharString(s)
	ces, _ := unpackArgSSByte(es)
	__ret := C.fz_strtof(cs, ces)
	packSSByte(es, ces)
	__v := (float32)(__ret)
	return __v
}

// StrtofNoExp function as declared in fitz/string-util.h:150
func StrtofNoExp(string string, tailptr [][]byte) float32 {
	cstring, _ := unpackPCharString(string)
	ctailptr, _ := unpackArgSSByte(tailptr)
	__ret := C.fz_strtof_no_exp(cstring, ctailptr)
	packSSByte(tailptr, ctailptr)
	__v := (float32)(__ret)
	return __v
}

// Grisu function as declared in fitz/string-util.h:157
func Grisu(f float32, s []byte, exp []int32) int32 {
	cf, _ := (C.float)(f), cgoAllocsUnknown
	cs, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&s)).Data)), cgoAllocsUnknown
	cexp, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&exp)).Data)), cgoAllocsUnknown
	__ret := C.fz_grisu(cf, cs, cexp)
	__v := (int32)(__ret)
	return __v
}

// IsPageRange function as declared in fitz/string-util.h:163
func IsPageRange(ctx []Context, s string) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cs, _ := unpackPCharString(s)
	__ret := C.fz_is_page_range(cctx, cs)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ParsePageRange function as declared in fitz/string-util.h:164
func ParsePageRange(ctx []Context, s string, a []int32, b []int32, n int32) string {
	cctx, _ := unpackArgSContext(ctx)
	cs, _ := unpackPCharString(s)
	ca, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&a)).Data)), cgoAllocsUnknown
	cb, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&b)).Data)), cgoAllocsUnknown
	cn, _ := (C.int)(n), cgoAllocsUnknown
	__ret := C.fz_parse_page_range(cctx, cs, ca, cb, cn)
	packSContext(ctx, cctx)
	__v := packPCharString(__ret)
	return __v
}

// NewPool function as declared in fitz/pool.h:9
func NewPool(ctx []Context) *Pool {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_new_pool(cctx)
	packSContext(ctx, cctx)
	__v := *(**Pool)(unsafe.Pointer(&__ret))
	return __v
}

// PoolAlloc function as declared in fitz/pool.h:10
func PoolAlloc(ctx []Context, pool []Pool, size uint) unsafe.Pointer {
	cctx, _ := unpackArgSContext(ctx)
	cpool, _ := (*C.fz_pool)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&pool)).Data)), cgoAllocsUnknown
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	__ret := C.fz_pool_alloc(cctx, cpool, csize)
	packSContext(ctx, cctx)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// PoolStrdup function as declared in fitz/pool.h:11
func PoolStrdup(ctx []Context, pool []Pool, s string) *byte {
	cctx, _ := unpackArgSContext(ctx)
	cpool, _ := (*C.fz_pool)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&pool)).Data)), cgoAllocsUnknown
	cs, _ := unpackPCharString(s)
	__ret := C.fz_pool_strdup(cctx, cpool, cs)
	packSContext(ctx, cctx)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// DropPool function as declared in fitz/pool.h:12
func DropPool(ctx []Context, pool []Pool) {
	cctx, _ := unpackArgSContext(ctx)
	cpool, _ := (*C.fz_pool)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&pool)).Data)), cgoAllocsUnknown
	C.fz_drop_pool(cctx, cpool)
	packSContext(ctx, cctx)
}

// TreeLookup function as declared in fitz/tree.h:13
func TreeLookup(ctx []Context, node []Tree, key string) unsafe.Pointer {
	cctx, _ := unpackArgSContext(ctx)
	cnode, _ := (*C.fz_tree)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&node)).Data)), cgoAllocsUnknown
	ckey, _ := unpackPCharString(key)
	__ret := C.fz_tree_lookup(cctx, cnode, ckey)
	packSContext(ctx, cctx)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// TreeInsert function as declared in fitz/tree.h:20
func TreeInsert(ctx []Context, root []Tree, key string, value unsafe.Pointer) *Tree {
	cctx, _ := unpackArgSContext(ctx)
	croot, _ := (*C.fz_tree)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&root)).Data)), cgoAllocsUnknown
	ckey, _ := unpackPCharString(key)
	cvalue, _ := value, cgoAllocsUnknown
	__ret := C.fz_tree_insert(cctx, croot, ckey, cvalue)
	packSContext(ctx, cctx)
	__v := *(**Tree)(unsafe.Pointer(&__ret))
	return __v
}

// DropTree function as declared in fitz/tree.h:22
func DropTree(ctx []Context, node []Tree, dropfunc *func(ctx []Context, value unsafe.Pointer)) {
	cctx, _ := unpackArgSContext(ctx)
	cnode, _ := (*C.fz_tree)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&node)).Data)), cgoAllocsUnknown
	cdropfunc, _ := dropfunc.PassRef()
	C.fz_drop_tree(cctx, cnode, cdropfunc)
	packSContext(ctx, cctx)
}

// BidiFragmentText function as declared in fitz/bidi.h:79
func BidiFragmentText(ctx []Context, text []uint32, textlen uint, basedir []BidiDirection, callback BidiFragmentFn, arg unsafe.Pointer, flags int32) {
	cctx, _ := unpackArgSContext(ctx)
	ctext, _ := (*C.uint32_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&text)).Data)), cgoAllocsUnknown
	ctextlen, _ := (C.size_t)(textlen), cgoAllocsUnknown
	cbasedir, _ := (*C.fz_bidi_direction)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&basedir)).Data)), cgoAllocsUnknown
	ccallback, _ := callback.PassRef()
	carg, _ := arg, cgoAllocsUnknown
	cflags, _ := (C.int)(flags), cgoAllocsUnknown
	C.fz_bidi_fragment_text(cctx, ctext, ctextlen, cbasedir, ccallback, carg, cflags)
	packSContext(ctx, cctx)
}

// ParseXml function as declared in fitz/xml.h:18
func ParseXml(ctx []Context, buf []Buffer, preserveWhite int32) *Xml {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	cpreserveWhite, _ := (C.int)(preserveWhite), cgoAllocsUnknown
	__ret := C.fz_parse_xml(cctx, cbuf, cpreserveWhite)
	packSContext(ctx, cctx)
	__v := *(**Xml)(unsafe.Pointer(&__ret))
	return __v
}

// XmlPrev function as declared in fitz/xml.h:23
func XmlPrev(item []Xml) *Xml {
	citem, _ := (*C.fz_xml)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&item)).Data)), cgoAllocsUnknown
	__ret := C.fz_xml_prev(citem)
	__v := *(**Xml)(unsafe.Pointer(&__ret))
	return __v
}

// XmlNext function as declared in fitz/xml.h:28
func XmlNext(item []Xml) *Xml {
	citem, _ := (*C.fz_xml)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&item)).Data)), cgoAllocsUnknown
	__ret := C.fz_xml_next(citem)
	__v := *(**Xml)(unsafe.Pointer(&__ret))
	return __v
}

// XmlUp function as declared in fitz/xml.h:33
func XmlUp(item []Xml) *Xml {
	citem, _ := (*C.fz_xml)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&item)).Data)), cgoAllocsUnknown
	__ret := C.fz_xml_up(citem)
	__v := *(**Xml)(unsafe.Pointer(&__ret))
	return __v
}

// XmlDown function as declared in fitz/xml.h:38
func XmlDown(item []Xml) *Xml {
	citem, _ := (*C.fz_xml)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&item)).Data)), cgoAllocsUnknown
	__ret := C.fz_xml_down(citem)
	__v := *(**Xml)(unsafe.Pointer(&__ret))
	return __v
}

// XmlIsTag function as declared in fitz/xml.h:43
func XmlIsTag(item []Xml, name string) int32 {
	citem, _ := (*C.fz_xml)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&item)).Data)), cgoAllocsUnknown
	cname, _ := unpackPCharString(name)
	__ret := C.fz_xml_is_tag(citem, cname)
	__v := (int32)(__ret)
	return __v
}

// XmlTag function as declared in fitz/xml.h:48
func XmlTag(item []Xml) *byte {
	citem, _ := (*C.fz_xml)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&item)).Data)), cgoAllocsUnknown
	__ret := C.fz_xml_tag(citem)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// XmlAtt function as declared in fitz/xml.h:54
func XmlAtt(item []Xml, att string) *byte {
	citem, _ := (*C.fz_xml)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&item)).Data)), cgoAllocsUnknown
	catt, _ := unpackPCharString(att)
	__ret := C.fz_xml_att(citem, catt)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// XmlText function as declared in fitz/xml.h:60
func XmlText(item []Xml) *byte {
	citem, _ := (*C.fz_xml)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&item)).Data)), cgoAllocsUnknown
	__ret := C.fz_xml_text(citem)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// DropXml function as declared in fitz/xml.h:65
func DropXml(doc []Context, item []Xml) {
	cdoc, _ := unpackArgSContext(doc)
	citem, _ := (*C.fz_xml)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&item)).Data)), cgoAllocsUnknown
	C.fz_drop_xml(cdoc, citem)
	packSContext(doc, cdoc)
}

// DetachXml function as declared in fitz/xml.h:70
func DetachXml(node []Xml) {
	cnode, _ := (*C.fz_xml)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&node)).Data)), cgoAllocsUnknown
	C.fz_detach_xml(cnode)
}

// DebugXml function as declared in fitz/xml.h:75
func DebugXml(item []Xml, level int32) {
	citem, _ := (*C.fz_xml)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&item)).Data)), cgoAllocsUnknown
	clevel, _ := (C.int)(level), cgoAllocsUnknown
	C.fz_debug_xml(citem, clevel)
}

// XmlFind function as declared in fitz/xml.h:77
func XmlFind(item []Xml, tag string) *Xml {
	citem, _ := (*C.fz_xml)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&item)).Data)), cgoAllocsUnknown
	ctag, _ := unpackPCharString(tag)
	__ret := C.fz_xml_find(citem, ctag)
	__v := *(**Xml)(unsafe.Pointer(&__ret))
	return __v
}

// XmlFindNext function as declared in fitz/xml.h:78
func XmlFindNext(item []Xml, tag string) *Xml {
	citem, _ := (*C.fz_xml)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&item)).Data)), cgoAllocsUnknown
	ctag, _ := unpackPCharString(tag)
	__ret := C.fz_xml_find_next(citem, ctag)
	__v := *(**Xml)(unsafe.Pointer(&__ret))
	return __v
}

// XmlFindDown function as declared in fitz/xml.h:79
func XmlFindDown(item []Xml, tag string) *Xml {
	citem, _ := (*C.fz_xml)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&item)).Data)), cgoAllocsUnknown
	ctag, _ := unpackPCharString(tag)
	__ret := C.fz_xml_find_down(citem, ctag)
	__v := *(**Xml)(unsafe.Pointer(&__ret))
	return __v
}

// FileExists function as declared in fitz/stream.h:11
func FileExists(ctx []Context, path string) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := unpackPCharString(path)
	__ret := C.fz_file_exists(cctx, cpath)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// OpenFile function as declared in fitz/stream.h:34
func OpenFile(ctx []Context, filename string) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cfilename, _ := unpackPCharString(filename)
	__ret := C.fz_open_file(cctx, cfilename)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenFilePtrProgressive function as declared in fitz/stream.h:36
func OpenFilePtrProgressive(ctx []Context, file []File, bps int32) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cfile, _ := unpackArgSFile(file)
	cbps, _ := (C.int)(bps), cgoAllocsUnknown
	__ret := C.fz_open_file_ptr_progressive(cctx, cfile, cbps)
	packSFile(file, cfile)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenFileProgressive function as declared in fitz/stream.h:37
func OpenFileProgressive(ctx []Context, filename string, bps int32) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cfilename, _ := unpackPCharString(filename)
	cbps, _ := (C.int)(bps), cgoAllocsUnknown
	__ret := C.fz_open_file_progressive(cctx, cfilename, cbps)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenFileW function as declared in fitz/stream.h:47
func OpenFileW(ctx []Context, filename []int32) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cfilename, _ := (*C.wchar_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&filename)).Data)), cgoAllocsUnknown
	__ret := C.fz_open_file_w(cctx, cfilename)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenFilePtr function as declared in fitz/stream.h:58
func OpenFilePtr(ctx []Context, file []File) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cfile, _ := unpackArgSFile(file)
	__ret := C.fz_open_file_ptr(cctx, cfile)
	packSFile(file, cfile)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenMemory function as declared in fitz/stream.h:71
func OpenMemory(ctx []Context, data []byte, len uint) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cdata, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	clen, _ := (C.size_t)(len), cgoAllocsUnknown
	__ret := C.fz_open_memory(cctx, cdata, clen)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenBuffer function as declared in fitz/stream.h:82
func OpenBuffer(ctx []Context, buf []Buffer) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	__ret := C.fz_open_buffer(cctx, cbuf)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenLeecher function as declared in fitz/stream.h:96
func OpenLeecher(ctx []Context, chain []Stream, buf []Buffer) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cchain, _ := unpackArgSStream(chain)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	__ret := C.fz_open_leecher(cctx, cchain, cbuf)
	packSStream(chain, cchain)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// DropStream function as declared in fitz/stream.h:105
func DropStream(ctx []Context, stm []Stream) {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	C.fz_drop_stream(cctx, cstm)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
}

// Tell function as declared in fitz/stream.h:110
func Tell(ctx []Context, stm []Stream) Off {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	__ret := C.fz_tell(cctx, cstm)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := (Off)(__ret)
	return __v
}

// Seek function as declared in fitz/stream.h:121
func Seek(ctx []Context, stm []Stream, offset Off, whence int32) {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	coffset, _ := (C.fz_off_t)(offset), cgoAllocsUnknown
	cwhence, _ := (C.int)(whence), cgoAllocsUnknown
	C.fz_seek(cctx, cstm, coffset, cwhence)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
}

// Read function as declared in fitz/stream.h:134
func Read(ctx []Context, stm []Stream, data []byte, len uint) uint {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	cdata, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	clen, _ := (C.size_t)(len), cgoAllocsUnknown
	__ret := C.fz_read(cctx, cstm, cdata, clen)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := (uint)(__ret)
	return __v
}

// Skip function as declared in fitz/stream.h:145
func Skip(ctx []Context, stm []Stream, len uint) uint {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	clen, _ := (C.size_t)(len), cgoAllocsUnknown
	__ret := C.fz_skip(cctx, cstm, clen)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := (uint)(__ret)
	return __v
}

// ReadAll function as declared in fitz/stream.h:157
func ReadAll(ctx []Context, stm []Stream, initial uint) *Buffer {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	cinitial, _ := (C.size_t)(initial), cgoAllocsUnknown
	__ret := C.fz_read_all(cctx, cstm, cinitial)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := *(**Buffer)(unsafe.Pointer(&__ret))
	return __v
}

// ReadFile function as declared in fitz/stream.h:162
func ReadFile(ctx []Context, filename string) *Buffer {
	cctx, _ := unpackArgSContext(ctx)
	cfilename, _ := unpackPCharString(filename)
	__ret := C.fz_read_file(cctx, cfilename)
	packSContext(ctx, cctx)
	__v := *(**Buffer)(unsafe.Pointer(&__ret))
	return __v
}

// ReadUint16 function as declared in fitz/stream.h:172
func ReadUint16(ctx []Context, stm []Stream) uint16 {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	__ret := C.fz_read_uint16(cctx, cstm)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := (uint16)(__ret)
	return __v
}

// ReadUint24 function as declared in fitz/stream.h:173
func ReadUint24(ctx []Context, stm []Stream) uint32 {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	__ret := C.fz_read_uint24(cctx, cstm)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := (uint32)(__ret)
	return __v
}

// ReadUint32 function as declared in fitz/stream.h:174
func ReadUint32(ctx []Context, stm []Stream) uint32 {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	__ret := C.fz_read_uint32(cctx, cstm)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := (uint32)(__ret)
	return __v
}

// ReadUint64 function as declared in fitz/stream.h:175
func ReadUint64(ctx []Context, stm []Stream) uint64 {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	__ret := C.fz_read_uint64(cctx, cstm)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := (uint64)(__ret)
	return __v
}

// ReadUint16Le function as declared in fitz/stream.h:177
func ReadUint16Le(ctx []Context, stm []Stream) uint16 {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	__ret := C.fz_read_uint16_le(cctx, cstm)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := (uint16)(__ret)
	return __v
}

// ReadUint24Le function as declared in fitz/stream.h:178
func ReadUint24Le(ctx []Context, stm []Stream) uint32 {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	__ret := C.fz_read_uint24_le(cctx, cstm)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := (uint32)(__ret)
	return __v
}

// ReadUint32Le function as declared in fitz/stream.h:179
func ReadUint32Le(ctx []Context, stm []Stream) uint32 {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	__ret := C.fz_read_uint32_le(cctx, cstm)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := (uint32)(__ret)
	return __v
}

// ReadUint64Le function as declared in fitz/stream.h:180
func ReadUint64Le(ctx []Context, stm []Stream) uint64 {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	__ret := C.fz_read_uint64_le(cctx, cstm)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := (uint64)(__ret)
	return __v
}

// ReadInt16 function as declared in fitz/stream.h:182
func ReadInt16(ctx []Context, stm []Stream) int16 {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	__ret := C.fz_read_int16(cctx, cstm)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := (int16)(__ret)
	return __v
}

// ReadInt32 function as declared in fitz/stream.h:183
func ReadInt32(ctx []Context, stm []Stream) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	__ret := C.fz_read_int32(cctx, cstm)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ReadInt64 function as declared in fitz/stream.h:184
func ReadInt64(ctx []Context, stm []Stream) int64 {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	__ret := C.fz_read_int64(cctx, cstm)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := (int64)(__ret)
	return __v
}

// ReadInt16Le function as declared in fitz/stream.h:186
func ReadInt16Le(ctx []Context, stm []Stream) int16 {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	__ret := C.fz_read_int16_le(cctx, cstm)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := (int16)(__ret)
	return __v
}

// ReadInt32Le function as declared in fitz/stream.h:187
func ReadInt32Le(ctx []Context, stm []Stream) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	__ret := C.fz_read_int32_le(cctx, cstm)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ReadInt64Le function as declared in fitz/stream.h:188
func ReadInt64Le(ctx []Context, stm []Stream) int64 {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	__ret := C.fz_read_int64_le(cctx, cstm)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := (int64)(__ret)
	return __v
}

// ReadString function as declared in fitz/stream.h:196
func ReadString(ctx []Context, stm []Stream, buffer []byte, len int32) {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	cbuffer, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buffer)).Data)), cgoAllocsUnknown
	clen, _ := (C.int)(len), cgoAllocsUnknown
	C.fz_read_string(cctx, cstm, cbuffer, clen)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
}

// StreamMeta function as declared in fitz/stream.h:221
func StreamMeta(ctx []Context, stm []Stream, key int32, size int32, ptr unsafe.Pointer) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	ckey, _ := (C.int)(key), cgoAllocsUnknown
	csize, _ := (C.int)(size), cgoAllocsUnknown
	cptr, _ := ptr, cgoAllocsUnknown
	__ret := C.fz_stream_meta(cctx, cstm, ckey, csize, cptr)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// NewStream function as declared in fitz/stream.h:300
func NewStream(ctx []Context, state unsafe.Pointer, next StreamNextFn, close StreamCloseFn) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cstate, _ := state, cgoAllocsUnknown
	cnext, _ := next.PassRef()
	cclose, _ := close.PassRef()
	__ret := C.fz_new_stream(cctx, cstate, cnext, cclose)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// KeepStream function as declared in fitz/stream.h:302
func KeepStream(ctx []Context, stm []Stream) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	__ret := C.fz_keep_stream(cctx, cstm)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// ReadBest function as declared in fitz/stream.h:317
func ReadBest(ctx []Context, stm []Stream, initial uint, truncated []int32) *Buffer {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	cinitial, _ := (C.size_t)(initial), cgoAllocsUnknown
	ctruncated, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&truncated)).Data)), cgoAllocsUnknown
	__ret := C.fz_read_best(cctx, cstm, cinitial, ctruncated)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := *(**Buffer)(unsafe.Pointer(&__ret))
	return __v
}

// ReadLine function as declared in fitz/stream.h:326
func ReadLine(ctx []Context, stm []Stream, buf []byte, max uint) *byte {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	cbuf, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	cmax, _ := (C.size_t)(max), cgoAllocsUnknown
	__ret := C.fz_read_line(cctx, cstm, cbuf, cmax)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// Available function as declared in fitz/stream.h:343
func Available(ctx []Context, stm []Stream, max uint) uint {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	cmax, _ := (C.size_t)(max), cgoAllocsUnknown
	__ret := C.fz_available(cctx, cstm, cmax)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := (uint)(__ret)
	return __v
}

// ReadByte function as declared in fitz/stream.h:378
func ReadByte(ctx []Context, stm []Stream) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	__ret := C.fz_read_byte(cctx, cstm)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// PeekByte function as declared in fitz/stream.h:407
func PeekByte(ctx []Context, stm []Stream) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	__ret := C.fz_peek_byte(cctx, cstm)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// UnreadByte function as declared in fitz/stream.h:427
func UnreadByte(ctx []Context, stm []Stream) {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	C.fz_unread_byte(cctx, cstm)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
}

// IsEof function as declared in fitz/stream.h:432
func IsEof(ctx []Context, stm []Stream) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	__ret := C.fz_is_eof(cctx, cstm)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ReadBits function as declared in fitz/stream.h:454
func ReadBits(ctx []Context, stm []Stream, n int32) uint32 {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	cn, _ := (C.int)(n), cgoAllocsUnknown
	__ret := C.fz_read_bits(cctx, cstm, cn)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := (uint32)(__ret)
	return __v
}

// ReadRbits function as declared in fitz/stream.h:497
func ReadRbits(ctx []Context, stm []Stream, n int32) uint32 {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	cn, _ := (C.int)(n), cgoAllocsUnknown
	__ret := C.fz_read_rbits(cctx, cstm, cn)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := (uint32)(__ret)
	return __v
}

// SyncBits function as declared in fitz/stream.h:540
func SyncBits(ctx []Context, stm []Stream) {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	C.fz_sync_bits(cctx, cstm)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
}

// IsEofBits function as declared in fitz/stream.h:545
func IsEofBits(ctx []Context, stm []Stream) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	__ret := C.fz_is_eof_bits(cctx, cstm)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// CompressedBufferSize function as declared in fitz/compressed-buffer.h:12
func CompressedBufferSize(buffer []CompressedBuffer) uint {
	cbuffer, _ := unpackArgSCompressedBuffer(buffer)
	__ret := C.fz_compressed_buffer_size(cbuffer)
	packSCompressedBuffer(buffer, cbuffer)
	__v := (uint)(__ret)
	return __v
}

// OpenCompressedBuffer function as declared in fitz/compressed-buffer.h:14
func OpenCompressedBuffer(ctx []Context, arg1 []CompressedBuffer) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	carg1, _ := unpackArgSCompressedBuffer(arg1)
	__ret := C.fz_open_compressed_buffer(cctx, carg1)
	packSCompressedBuffer(arg1, carg1)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenImageDecompStreamFromBuffer function as declared in fitz/compressed-buffer.h:15
func OpenImageDecompStreamFromBuffer(ctx []Context, arg1 []CompressedBuffer, l2factor []int32) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	carg1, _ := unpackArgSCompressedBuffer(arg1)
	cl2factor, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&l2factor)).Data)), cgoAllocsUnknown
	__ret := C.fz_open_image_decomp_stream_from_buffer(cctx, carg1, cl2factor)
	packSCompressedBuffer(arg1, carg1)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenImageDecompStream function as declared in fitz/compressed-buffer.h:16
func OpenImageDecompStream(ctx []Context, arg1 []Stream, arg2 []CompressionParams, l2factor []int32) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	carg1, _ := unpackArgSStream(arg1)
	carg2, _ := unpackArgSCompressionParams(arg2)
	cl2factor, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&l2factor)).Data)), cgoAllocsUnknown
	__ret := C.fz_open_image_decomp_stream(cctx, carg1, carg2, cl2factor)
	packSCompressionParams(arg2, carg2)
	packSStream(arg1, carg1)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// DropCompressedBuffer function as declared in fitz/compressed-buffer.h:87
func DropCompressedBuffer(ctx []Context, buf []CompressedBuffer) {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := unpackArgSCompressedBuffer(buf)
	C.fz_drop_compressed_buffer(cctx, cbuf)
	packSCompressedBuffer(buf, cbuf)
	packSContext(ctx, cctx)
}

// OpenCopy function as declared in fitz/filter.h:12
func OpenCopy(ctx []Context, chain []Stream) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cchain, _ := unpackArgSStream(chain)
	__ret := C.fz_open_copy(cctx, cchain)
	packSStream(chain, cchain)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenNull function as declared in fitz/filter.h:13
func OpenNull(ctx []Context, chain []Stream, len int32, offset Off) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cchain, _ := unpackArgSStream(chain)
	clen, _ := (C.int)(len), cgoAllocsUnknown
	coffset, _ := (C.fz_off_t)(offset), cgoAllocsUnknown
	__ret := C.fz_open_null(cctx, cchain, clen, coffset)
	packSStream(chain, cchain)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenConcat function as declared in fitz/filter.h:14
func OpenConcat(ctx []Context, max int32, pad int32) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cmax, _ := (C.int)(max), cgoAllocsUnknown
	cpad, _ := (C.int)(pad), cgoAllocsUnknown
	__ret := C.fz_open_concat(cctx, cmax, cpad)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// ConcatPushDrop function as declared in fitz/filter.h:15
func ConcatPushDrop(ctx []Context, concat []Stream, chain []Stream) {
	cctx, _ := unpackArgSContext(ctx)
	cconcat, _ := unpackArgSStream(concat)
	cchain, _ := unpackArgSStream(chain)
	C.fz_concat_push_drop(cctx, cconcat, cchain)
	packSStream(chain, cchain)
	packSStream(concat, cconcat)
	packSContext(ctx, cctx)
}

// OpenArc4 function as declared in fitz/filter.h:16
func OpenArc4(ctx []Context, chain []Stream, key []byte, keylen uint32) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cchain, _ := unpackArgSStream(chain)
	ckey, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&key)).Data)), cgoAllocsUnknown
	ckeylen, _ := (C.uint)(keylen), cgoAllocsUnknown
	__ret := C.fz_open_arc4(cctx, cchain, ckey, ckeylen)
	packSStream(chain, cchain)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenAesd function as declared in fitz/filter.h:17
func OpenAesd(ctx []Context, chain []Stream, key []byte, keylen uint32) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cchain, _ := unpackArgSStream(chain)
	ckey, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&key)).Data)), cgoAllocsUnknown
	ckeylen, _ := (C.uint)(keylen), cgoAllocsUnknown
	__ret := C.fz_open_aesd(cctx, cchain, ckey, ckeylen)
	packSStream(chain, cchain)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenA85d function as declared in fitz/filter.h:18
func OpenA85d(ctx []Context, chain []Stream) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cchain, _ := unpackArgSStream(chain)
	__ret := C.fz_open_a85d(cctx, cchain)
	packSStream(chain, cchain)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenAhxd function as declared in fitz/filter.h:19
func OpenAhxd(ctx []Context, chain []Stream) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cchain, _ := unpackArgSStream(chain)
	__ret := C.fz_open_ahxd(cctx, cchain)
	packSStream(chain, cchain)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenRld function as declared in fitz/filter.h:20
func OpenRld(ctx []Context, chain []Stream) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cchain, _ := unpackArgSStream(chain)
	__ret := C.fz_open_rld(cctx, cchain)
	packSStream(chain, cchain)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenDctd function as declared in fitz/filter.h:21
func OpenDctd(ctx []Context, chain []Stream, colorTransform int32, l2factor int32, jpegtables []Stream) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cchain, _ := unpackArgSStream(chain)
	ccolorTransform, _ := (C.int)(colorTransform), cgoAllocsUnknown
	cl2factor, _ := (C.int)(l2factor), cgoAllocsUnknown
	cjpegtables, _ := unpackArgSStream(jpegtables)
	__ret := C.fz_open_dctd(cctx, cchain, ccolorTransform, cl2factor, cjpegtables)
	packSStream(jpegtables, cjpegtables)
	packSStream(chain, cchain)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenFaxd function as declared in fitz/filter.h:22
func OpenFaxd(ctx []Context, chain []Stream, k int32, endOfLine int32, encodedByteAlign int32, columns int32, rows int32, endOfBlock int32, blackIs1 int32) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cchain, _ := unpackArgSStream(chain)
	ck, _ := (C.int)(k), cgoAllocsUnknown
	cendOfLine, _ := (C.int)(endOfLine), cgoAllocsUnknown
	cencodedByteAlign, _ := (C.int)(encodedByteAlign), cgoAllocsUnknown
	ccolumns, _ := (C.int)(columns), cgoAllocsUnknown
	crows, _ := (C.int)(rows), cgoAllocsUnknown
	cendOfBlock, _ := (C.int)(endOfBlock), cgoAllocsUnknown
	cblackIs1, _ := (C.int)(blackIs1), cgoAllocsUnknown
	__ret := C.fz_open_faxd(cctx, cchain, ck, cendOfLine, cencodedByteAlign, ccolumns, crows, cendOfBlock, cblackIs1)
	packSStream(chain, cchain)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenFlated function as declared in fitz/filter.h:25
func OpenFlated(ctx []Context, chain []Stream, windowBits int32) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cchain, _ := unpackArgSStream(chain)
	cwindowBits, _ := (C.int)(windowBits), cgoAllocsUnknown
	__ret := C.fz_open_flated(cctx, cchain, cwindowBits)
	packSStream(chain, cchain)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenLzwd function as declared in fitz/filter.h:26
func OpenLzwd(ctx []Context, chain []Stream, earlyChange int32, minBits int32, reverseBits int32, oldTiff int32) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cchain, _ := unpackArgSStream(chain)
	cearlyChange, _ := (C.int)(earlyChange), cgoAllocsUnknown
	cminBits, _ := (C.int)(minBits), cgoAllocsUnknown
	creverseBits, _ := (C.int)(reverseBits), cgoAllocsUnknown
	coldTiff, _ := (C.int)(oldTiff), cgoAllocsUnknown
	__ret := C.fz_open_lzwd(cctx, cchain, cearlyChange, cminBits, creverseBits, coldTiff)
	packSStream(chain, cchain)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenPredict function as declared in fitz/filter.h:27
func OpenPredict(ctx []Context, chain []Stream, predictor int32, columns int32, colors int32, bpc int32) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cchain, _ := unpackArgSStream(chain)
	cpredictor, _ := (C.int)(predictor), cgoAllocsUnknown
	ccolumns, _ := (C.int)(columns), cgoAllocsUnknown
	ccolors, _ := (C.int)(colors), cgoAllocsUnknown
	cbpc, _ := (C.int)(bpc), cgoAllocsUnknown
	__ret := C.fz_open_predict(cctx, cchain, cpredictor, ccolumns, ccolors, cbpc)
	packSStream(chain, cchain)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenJbig2d function as declared in fitz/filter.h:28
func OpenJbig2d(ctx []Context, chain []Stream, globals []Jbig2Globals) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cchain, _ := unpackArgSStream(chain)
	cglobals, _ := (*C.fz_jbig2_globals)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&globals)).Data)), cgoAllocsUnknown
	__ret := C.fz_open_jbig2d(cctx, cchain, cglobals)
	packSStream(chain, cchain)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// LoadJbig2Globals function as declared in fitz/filter.h:30
func LoadJbig2Globals(ctx []Context, buf []Buffer) *Jbig2Globals {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	__ret := C.fz_load_jbig2_globals(cctx, cbuf)
	packSContext(ctx, cctx)
	__v := *(**Jbig2Globals)(unsafe.Pointer(&__ret))
	return __v
}

// DropJbig2GlobalsImp function as declared in fitz/filter.h:31
func DropJbig2GlobalsImp(ctx []Context, globals []Storable) {
	cctx, _ := unpackArgSContext(ctx)
	cglobals, _ := unpackArgSStorable(globals)
	C.fz_drop_jbig2_globals_imp(cctx, cglobals)
	packSStorable(globals, cglobals)
	packSContext(ctx, cctx)
}

// OpenSgilog16 function as declared in fitz/filter.h:34
func OpenSgilog16(ctx []Context, chain []Stream, w int32) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cchain, _ := unpackArgSStream(chain)
	cw, _ := (C.int)(w), cgoAllocsUnknown
	__ret := C.fz_open_sgilog16(cctx, cchain, cw)
	packSStream(chain, cchain)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenSgilog24 function as declared in fitz/filter.h:35
func OpenSgilog24(ctx []Context, chain []Stream, w int32) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cchain, _ := unpackArgSStream(chain)
	cw, _ := (C.int)(w), cgoAllocsUnknown
	__ret := C.fz_open_sgilog24(cctx, cchain, cw)
	packSStream(chain, cchain)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenSgilog32 function as declared in fitz/filter.h:36
func OpenSgilog32(ctx []Context, chain []Stream, w int32) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cchain, _ := unpackArgSStream(chain)
	cw, _ := (C.int)(w), cgoAllocsUnknown
	__ret := C.fz_open_sgilog32(cctx, cchain, cw)
	packSStream(chain, cchain)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenThunder function as declared in fitz/filter.h:37
func OpenThunder(ctx []Context, chain []Stream, w int32) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cchain, _ := unpackArgSStream(chain)
	cw, _ := (C.int)(w), cgoAllocsUnknown
	__ret := C.fz_open_thunder(cctx, cchain, cw)
	packSStream(chain, cchain)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// KeepStorable function as declared in fitz/store.h:54
func KeepStorable(arg0 []Context, arg1 []Storable) unsafe.Pointer {
	carg0, _ := unpackArgSContext(arg0)
	carg1, _ := unpackArgSStorable(arg1)
	__ret := C.fz_keep_storable(carg0, carg1)
	packSStorable(arg1, carg1)
	packSContext(arg0, carg0)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// DropStorable function as declared in fitz/store.h:55
func DropStorable(arg0 []Context, arg1 []Storable) {
	carg0, _ := unpackArgSContext(arg0)
	carg1, _ := unpackArgSStorable(arg1)
	C.fz_drop_storable(carg0, carg1)
	packSStorable(arg1, carg1)
	packSContext(arg0, carg0)
}

// KeepKeyStorable function as declared in fitz/store.h:57
func KeepKeyStorable(arg0 []Context, arg1 []KeyStorable) unsafe.Pointer {
	carg0, _ := unpackArgSContext(arg0)
	carg1, _ := unpackArgSKeyStorable(arg1)
	__ret := C.fz_keep_key_storable(carg0, carg1)
	packSKeyStorable(arg1, carg1)
	packSContext(arg0, carg0)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// DropKeyStorable function as declared in fitz/store.h:58
func DropKeyStorable(arg0 []Context, arg1 []KeyStorable) {
	carg0, _ := unpackArgSContext(arg0)
	carg1, _ := unpackArgSKeyStorable(arg1)
	C.fz_drop_key_storable(carg0, carg1)
	packSKeyStorable(arg1, carg1)
	packSContext(arg0, carg0)
}

// KeepKeyStorableKey function as declared in fitz/store.h:60
func KeepKeyStorableKey(arg0 []Context, arg1 []KeyStorable) unsafe.Pointer {
	carg0, _ := unpackArgSContext(arg0)
	carg1, _ := unpackArgSKeyStorable(arg1)
	__ret := C.fz_keep_key_storable_key(carg0, carg1)
	packSKeyStorable(arg1, carg1)
	packSContext(arg0, carg0)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// DropKeyStorableKey function as declared in fitz/store.h:61
func DropKeyStorableKey(arg0 []Context, arg1 []KeyStorable) {
	carg0, _ := unpackArgSContext(arg0)
	carg1, _ := unpackArgSKeyStorable(arg1)
	C.fz_drop_key_storable_key(carg0, carg1)
	packSKeyStorable(arg1, carg1)
	packSContext(arg0, carg0)
}

// KeyStorableNeedsReaping function as declared in fitz/store.h:63
func KeyStorableNeedsReaping(ctx []Context, ks []KeyStorable) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cks, _ := unpackArgSKeyStorable(ks)
	__ret := C.fz_key_storable_needs_reaping(cctx, cks)
	packSKeyStorable(ks, cks)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// NewStoreContext function as declared in fitz/store.h:169
func NewStoreContext(ctx []Context, max uint) {
	cctx, _ := unpackArgSContext(ctx)
	cmax, _ := (C.size_t)(max), cgoAllocsUnknown
	C.fz_new_store_context(cctx, cmax)
	packSContext(ctx, cctx)
}

// DropStoreContext function as declared in fitz/store.h:174
func DropStoreContext(ctx []Context) {
	cctx, _ := unpackArgSContext(ctx)
	C.fz_drop_store_context(cctx)
	packSContext(ctx, cctx)
}

// KeepStoreContext function as declared in fitz/store.h:179
func KeepStoreContext(ctx []Context) *Store {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_keep_store_context(cctx)
	packSContext(ctx, cctx)
	__v := *(**Store)(unsafe.Pointer(&__ret))
	return __v
}

// StoreItem function as declared in fitz/store.h:199
func StoreItem(ctx []Context, key unsafe.Pointer, val unsafe.Pointer, itemsize uint, kind []StoreType) unsafe.Pointer {
	cctx, _ := unpackArgSContext(ctx)
	ckey, _ := key, cgoAllocsUnknown
	cval, _ := val, cgoAllocsUnknown
	citemsize, _ := (C.size_t)(itemsize), cgoAllocsUnknown
	ckind, _ := unpackArgSStoreType(kind)
	__ret := C.fz_store_item(cctx, ckey, cval, citemsize, ckind)
	packSStoreType(kind, ckind)
	packSContext(ctx, cctx)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// FindItem function as declared in fitz/store.h:214
func FindItem(ctx []Context, drop StoreDropFn, key unsafe.Pointer, kind []StoreType) unsafe.Pointer {
	cctx, _ := unpackArgSContext(ctx)
	cdrop, _ := drop.PassRef()
	ckey, _ := key, cgoAllocsUnknown
	ckind, _ := unpackArgSStoreType(kind)
	__ret := C.fz_find_item(cctx, cdrop, ckey, ckind)
	packSStoreType(kind, ckind)
	packSContext(ctx, cctx)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// RemoveItem function as declared in fitz/store.h:228
func RemoveItem(ctx []Context, drop StoreDropFn, key unsafe.Pointer, kind []StoreType) {
	cctx, _ := unpackArgSContext(ctx)
	cdrop, _ := drop.PassRef()
	ckey, _ := key, cgoAllocsUnknown
	ckind, _ := unpackArgSStoreType(kind)
	C.fz_remove_item(cctx, cdrop, ckey, ckind)
	packSStoreType(kind, ckind)
	packSContext(ctx, cctx)
}

// EmptyStore function as declared in fitz/store.h:233
func EmptyStore(ctx []Context) {
	cctx, _ := unpackArgSContext(ctx)
	C.fz_empty_store(cctx)
	packSContext(ctx, cctx)
}

// StoreScavenge function as declared in fitz/store.h:247
func StoreScavenge(ctx []Context, size uint, phase []int32) int32 {
	cctx, _ := unpackArgSContext(ctx)
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	cphase, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&phase)).Data)), cgoAllocsUnknown
	__ret := C.fz_store_scavenge(cctx, csize, cphase)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ShrinkStore function as declared in fitz/store.h:258
func ShrinkStore(ctx []Context, percent uint32) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cpercent, _ := (C.uint)(percent), cgoAllocsUnknown
	__ret := C.fz_shrink_store(cctx, cpercent)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// FilterStore function as declared in fitz/store.h:262
func FilterStore(ctx []Context, fn StoreFilterFn, arg unsafe.Pointer, kind []StoreType) {
	cctx, _ := unpackArgSContext(ctx)
	cfn, _ := fn.PassRef()
	carg, _ := arg, cgoAllocsUnknown
	ckind, _ := unpackArgSStoreType(kind)
	C.fz_filter_store(cctx, cfn, carg, ckind)
	packSStoreType(kind, ckind)
	packSContext(ctx, cctx)
}

// DebugStore function as declared in fitz/store.h:267
func DebugStore(ctx []Context) {
	cctx, _ := unpackArgSContext(ctx)
	C.fz_debug_store(cctx)
	packSContext(ctx, cctx)
}

// DeferReapStart function as declared in fitz/store.h:282
func DeferReapStart(ctx []Context) {
	cctx, _ := unpackArgSContext(ctx)
	C.fz_defer_reap_start(cctx)
	packSContext(ctx, cctx)
}

// DeferReapEnd function as declared in fitz/store.h:296
func DeferReapEnd(ctx []Context) {
	cctx, _ := unpackArgSContext(ctx)
	C.fz_defer_reap_end(cctx)
	packSContext(ctx, cctx)
}

// NewArchiveOfSize function as declared in fitz/archive.h:27
func NewArchiveOfSize(ctx []Context, file []Stream, size int32) *Archive {
	cctx, _ := unpackArgSContext(ctx)
	cfile, _ := unpackArgSStream(file)
	csize, _ := (C.int)(size), cgoAllocsUnknown
	__ret := C.fz_new_archive_of_size(cctx, cfile, csize)
	packSStream(file, cfile)
	packSContext(ctx, cctx)
	__v := NewArchiveRef(unsafe.Pointer(__ret))
	return __v
}

// OpenArchive function as declared in fitz/archive.h:40
func OpenArchive(ctx []Context, filename string) *Archive {
	cctx, _ := unpackArgSContext(ctx)
	cfilename, _ := unpackPCharString(filename)
	__ret := C.fz_open_archive(cctx, cfilename)
	packSContext(ctx, cctx)
	__v := NewArchiveRef(unsafe.Pointer(__ret))
	return __v
}

// OpenArchiveWithStream function as declared in fitz/archive.h:48
func OpenArchiveWithStream(ctx []Context, file []Stream) *Archive {
	cctx, _ := unpackArgSContext(ctx)
	cfile, _ := unpackArgSStream(file)
	__ret := C.fz_open_archive_with_stream(cctx, cfile)
	packSStream(file, cfile)
	packSContext(ctx, cctx)
	__v := NewArchiveRef(unsafe.Pointer(__ret))
	return __v
}

// OpenDirectory function as declared in fitz/archive.h:62
func OpenDirectory(ctx []Context, path string) *Archive {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := unpackPCharString(path)
	__ret := C.fz_open_directory(cctx, cpath)
	packSContext(ctx, cctx)
	__v := NewArchiveRef(unsafe.Pointer(__ret))
	return __v
}

// DropArchive function as declared in fitz/archive.h:69
func DropArchive(ctx []Context, arch []Archive) {
	cctx, _ := unpackArgSContext(ctx)
	carch, _ := unpackArgSArchive(arch)
	C.fz_drop_archive(cctx, carch)
	packSArchive(arch, carch)
	packSContext(ctx, cctx)
}

// ArchiveFormat function as declared in fitz/archive.h:74
func ArchiveFormat(ctx []Context, arch []Archive) string {
	cctx, _ := unpackArgSContext(ctx)
	carch, _ := unpackArgSArchive(arch)
	__ret := C.fz_archive_format(cctx, carch)
	packSArchive(arch, carch)
	packSContext(ctx, cctx)
	__v := packPCharString(__ret)
	return __v
}

// CountArchiveEntries function as declared in fitz/archive.h:81
func CountArchiveEntries(ctx []Context, arch []Archive) int32 {
	cctx, _ := unpackArgSContext(ctx)
	carch, _ := unpackArgSArchive(arch)
	__ret := C.fz_count_archive_entries(cctx, carch)
	packSArchive(arch, carch)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ListArchiveEntry function as declared in fitz/archive.h:90
func ListArchiveEntry(ctx []Context, arch []Archive, idx int32) string {
	cctx, _ := unpackArgSContext(ctx)
	carch, _ := unpackArgSArchive(arch)
	cidx, _ := (C.int)(idx), cgoAllocsUnknown
	__ret := C.fz_list_archive_entry(cctx, carch, cidx)
	packSArchive(arch, carch)
	packSContext(ctx, cctx)
	__v := packPCharString(__ret)
	return __v
}

// HasArchiveEntry function as declared in fitz/archive.h:101
func HasArchiveEntry(ctx []Context, arch []Archive, name string) int32 {
	cctx, _ := unpackArgSContext(ctx)
	carch, _ := unpackArgSArchive(arch)
	cname, _ := unpackPCharString(name)
	__ret := C.fz_has_archive_entry(cctx, carch, cname)
	packSArchive(arch, carch)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// OpenArchiveEntry function as declared in fitz/archive.h:109
func OpenArchiveEntry(ctx []Context, arch []Archive, name string) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	carch, _ := unpackArgSArchive(arch)
	cname, _ := unpackPCharString(name)
	__ret := C.fz_open_archive_entry(cctx, carch, cname)
	packSArchive(arch, carch)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// ReadArchiveEntry function as declared in fitz/archive.h:119
func ReadArchiveEntry(ctx []Context, arch []Archive, name string) *Buffer {
	cctx, _ := unpackArgSContext(ctx)
	carch, _ := unpackArgSArchive(arch)
	cname, _ := unpackPCharString(name)
	__ret := C.fz_read_archive_entry(cctx, carch, cname)
	packSArchive(arch, carch)
	packSContext(ctx, cctx)
	__v := *(**Buffer)(unsafe.Pointer(&__ret))
	return __v
}

// IsTarArchive function as declared in fitz/archive.h:126
func IsTarArchive(ctx []Context, file []Stream) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cfile, _ := unpackArgSStream(file)
	__ret := C.fz_is_tar_archive(cctx, cfile)
	packSStream(file, cfile)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// OpenTarArchive function as declared in fitz/archive.h:137
func OpenTarArchive(ctx []Context, filename string) *Archive {
	cctx, _ := unpackArgSContext(ctx)
	cfilename, _ := unpackPCharString(filename)
	__ret := C.fz_open_tar_archive(cctx, cfilename)
	packSContext(ctx, cctx)
	__v := NewArchiveRef(unsafe.Pointer(__ret))
	return __v
}

// OpenTarArchiveWithStream function as declared in fitz/archive.h:149
func OpenTarArchiveWithStream(ctx []Context, file []Stream) *Archive {
	cctx, _ := unpackArgSContext(ctx)
	cfile, _ := unpackArgSStream(file)
	__ret := C.fz_open_tar_archive_with_stream(cctx, cfile)
	packSStream(file, cfile)
	packSContext(ctx, cctx)
	__v := NewArchiveRef(unsafe.Pointer(__ret))
	return __v
}

// IsZipArchive function as declared in fitz/archive.h:156
func IsZipArchive(ctx []Context, file []Stream) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cfile, _ := unpackArgSStream(file)
	__ret := C.fz_is_zip_archive(cctx, cfile)
	packSStream(file, cfile)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// OpenZipArchive function as declared in fitz/archive.h:167
func OpenZipArchive(ctx []Context, path string) *Archive {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := unpackPCharString(path)
	__ret := C.fz_open_zip_archive(cctx, cpath)
	packSContext(ctx, cctx)
	__v := NewArchiveRef(unsafe.Pointer(__ret))
	return __v
}

// OpenZipArchiveWithStream function as declared in fitz/archive.h:179
func OpenZipArchiveWithStream(ctx []Context, file []Stream) *Archive {
	cctx, _ := unpackArgSContext(ctx)
	cfile, _ := unpackArgSStream(file)
	__ret := C.fz_open_zip_archive_with_stream(cctx, cfile)
	packSStream(file, cfile)
	packSContext(ctx, cctx)
	__v := NewArchiveRef(unsafe.Pointer(__ret))
	return __v
}

// NewZipWriter function as declared in fitz/archive.h:183
func NewZipWriter(ctx []Context, filename string) *ZipWriter {
	cctx, _ := unpackArgSContext(ctx)
	cfilename, _ := unpackPCharString(filename)
	__ret := C.fz_new_zip_writer(cctx, cfilename)
	packSContext(ctx, cctx)
	__v := *(**ZipWriter)(unsafe.Pointer(&__ret))
	return __v
}

// WriteZipEntry function as declared in fitz/archive.h:184
func WriteZipEntry(ctx []Context, zip []ZipWriter, name string, buf []Buffer, compress int32) {
	cctx, _ := unpackArgSContext(ctx)
	czip, _ := (*C.fz_zip_writer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&zip)).Data)), cgoAllocsUnknown
	cname, _ := unpackPCharString(name)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	ccompress, _ := (C.int)(compress), cgoAllocsUnknown
	C.fz_write_zip_entry(cctx, czip, cname, cbuf, ccompress)
	packSContext(ctx, cctx)
}

// CloseZipWriter function as declared in fitz/archive.h:185
func CloseZipWriter(ctx []Context, zip []ZipWriter) {
	cctx, _ := unpackArgSContext(ctx)
	czip, _ := (*C.fz_zip_writer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&zip)).Data)), cgoAllocsUnknown
	C.fz_close_zip_writer(cctx, czip)
	packSContext(ctx, cctx)
}

// DropZipWriter function as declared in fitz/archive.h:186
func DropZipWriter(ctx []Context, zip []ZipWriter) {
	cctx, _ := unpackArgSContext(ctx)
	czip, _ := (*C.fz_zip_writer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&zip)).Data)), cgoAllocsUnknown
	C.fz_drop_zip_writer(cctx, czip)
	packSContext(ctx, cctx)
}

// LookupRenderingIntent function as declared in fitz/colorspace.h:30
func LookupRenderingIntent(name string) int32 {
	cname, _ := unpackPCharString(name)
	__ret := C.fz_lookup_rendering_intent(cname)
	__v := (int32)(__ret)
	return __v
}

// RenderingIntentName function as declared in fitz/colorspace.h:31
func RenderingIntentName(ri int32) *byte {
	cri, _ := (C.int)(ri), cgoAllocsUnknown
	__ret := C.fz_rendering_intent_name(cri)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// ColorspaceIsSubtractive function as declared in fitz/colorspace.h:64
func ColorspaceIsSubtractive(ctx []Context, cs []Colorspace) int32 {
	cctx, _ := unpackArgSContext(ctx)
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	__ret := C.fz_colorspace_is_subtractive(cctx, ccs)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ColorspaceIsDeviceN function as declared in fitz/colorspace.h:71
func ColorspaceIsDeviceN(ctx []Context, cs []Colorspace) int32 {
	cctx, _ := unpackArgSContext(ctx)
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	__ret := C.fz_colorspace_is_device_n(cctx, ccs)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// DeviceGray function as declared in fitz/colorspace.h:76
func DeviceGray(ctx []Context) *Colorspace {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_device_gray(cctx)
	packSContext(ctx, cctx)
	__v := *(**Colorspace)(unsafe.Pointer(&__ret))
	return __v
}

// DeviceRgb function as declared in fitz/colorspace.h:81
func DeviceRgb(ctx []Context) *Colorspace {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_device_rgb(cctx)
	packSContext(ctx, cctx)
	__v := *(**Colorspace)(unsafe.Pointer(&__ret))
	return __v
}

// DeviceBgr function as declared in fitz/colorspace.h:86
func DeviceBgr(ctx []Context) *Colorspace {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_device_bgr(cctx)
	packSContext(ctx, cctx)
	__v := *(**Colorspace)(unsafe.Pointer(&__ret))
	return __v
}

// DeviceCmyk function as declared in fitz/colorspace.h:91
func DeviceCmyk(ctx []Context) *Colorspace {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_device_cmyk(cctx)
	packSContext(ctx, cctx)
	__v := *(**Colorspace)(unsafe.Pointer(&__ret))
	return __v
}

// DeviceLab function as declared in fitz/colorspace.h:96
func DeviceLab(ctx []Context) *Colorspace {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_device_lab(cctx)
	packSContext(ctx, cctx)
	__v := *(**Colorspace)(unsafe.Pointer(&__ret))
	return __v
}

// DefaultColorParams function as declared in fitz/colorspace.h:101
func DefaultColorParams(ctx []Context) *ColorParams {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_default_color_params(cctx)
	packSContext(ctx, cctx)
	__v := NewColorParamsRef(unsafe.Pointer(__ret))
	return __v
}

// NewColorspace function as declared in fitz/colorspace.h:111
func NewColorspace(ctx []Context, name string, n int32, isSubtractive int32, isDeviceN int32, toCcs ColorspaceConvertFn, fromCcs ColorspaceConvertFn, base ColorspaceBaseFn, clamp ColorspaceClampFn, destruct ColorspaceDestructFn, data unsafe.Pointer, size uint) *Colorspace {
	cctx, _ := unpackArgSContext(ctx)
	cname, _ := unpackPCharString(name)
	cn, _ := (C.int)(n), cgoAllocsUnknown
	cisSubtractive, _ := (C.int)(isSubtractive), cgoAllocsUnknown
	cisDeviceN, _ := (C.int)(isDeviceN), cgoAllocsUnknown
	ctoCcs, _ := toCcs.PassRef()
	cfromCcs, _ := fromCcs.PassRef()
	cbase, _ := base.PassRef()
	cclamp, _ := clamp.PassRef()
	cdestruct, _ := destruct.PassRef()
	cdata, _ := data, cgoAllocsUnknown
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	__ret := C.fz_new_colorspace(cctx, cname, cn, cisSubtractive, cisDeviceN, ctoCcs, cfromCcs, cbase, cclamp, cdestruct, cdata, csize)
	packSContext(ctx, cctx)
	__v := *(**Colorspace)(unsafe.Pointer(&__ret))
	return __v
}

// ColorspaceNameColorant function as declared in fitz/colorspace.h:112
func ColorspaceNameColorant(ctx []Context, cs []Colorspace, n int32, name string) {
	cctx, _ := unpackArgSContext(ctx)
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	cn, _ := (C.int)(n), cgoAllocsUnknown
	cname, _ := unpackPCharString(name)
	C.fz_colorspace_name_colorant(cctx, ccs, cn, cname)
	packSContext(ctx, cctx)
}

// ColorspaceColorant function as declared in fitz/colorspace.h:113
func ColorspaceColorant(ctx []Context, cs []Colorspace, n int32) string {
	cctx, _ := unpackArgSContext(ctx)
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	cn, _ := (C.int)(n), cgoAllocsUnknown
	__ret := C.fz_colorspace_colorant(cctx, ccs, cn)
	packSContext(ctx, cctx)
	__v := packPCharString(__ret)
	return __v
}

// NewIndexedColorspace function as declared in fitz/colorspace.h:114
func NewIndexedColorspace(ctx []Context, base []Colorspace, high int32, lookup []byte) *Colorspace {
	cctx, _ := unpackArgSContext(ctx)
	cbase, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&base)).Data)), cgoAllocsUnknown
	chigh, _ := (C.int)(high), cgoAllocsUnknown
	clookup, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&lookup)).Data)), cgoAllocsUnknown
	__ret := C.fz_new_indexed_colorspace(cctx, cbase, chigh, clookup)
	packSContext(ctx, cctx)
	__v := *(**Colorspace)(unsafe.Pointer(&__ret))
	return __v
}

// KeepColorspace function as declared in fitz/colorspace.h:115
func KeepColorspace(ctx []Context, colorspace []Colorspace) *Colorspace {
	cctx, _ := unpackArgSContext(ctx)
	ccolorspace, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&colorspace)).Data)), cgoAllocsUnknown
	__ret := C.fz_keep_colorspace(cctx, ccolorspace)
	packSContext(ctx, cctx)
	__v := *(**Colorspace)(unsafe.Pointer(&__ret))
	return __v
}

// DropColorspace function as declared in fitz/colorspace.h:116
func DropColorspace(ctx []Context, colorspace []Colorspace) {
	cctx, _ := unpackArgSContext(ctx)
	ccolorspace, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&colorspace)).Data)), cgoAllocsUnknown
	C.fz_drop_colorspace(cctx, ccolorspace)
	packSContext(ctx, cctx)
}

// DropColorspaceImp function as declared in fitz/colorspace.h:117
func DropColorspaceImp(ctx []Context, colorspace []Storable) {
	cctx, _ := unpackArgSContext(ctx)
	ccolorspace, _ := unpackArgSStorable(colorspace)
	C.fz_drop_colorspace_imp(cctx, ccolorspace)
	packSStorable(colorspace, ccolorspace)
	packSContext(ctx, cctx)
}

// ColorspaceBase function as declared in fitz/colorspace.h:119
func ColorspaceBase(ctx []Context, cs []Colorspace) *Colorspace {
	cctx, _ := unpackArgSContext(ctx)
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	__ret := C.fz_colorspace_base(cctx, ccs)
	packSContext(ctx, cctx)
	__v := *(**Colorspace)(unsafe.Pointer(&__ret))
	return __v
}

// ColorspaceIsIcc function as declared in fitz/colorspace.h:120
func ColorspaceIsIcc(ctx []Context, cs []Colorspace) int32 {
	cctx, _ := unpackArgSContext(ctx)
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	__ret := C.fz_colorspace_is_icc(cctx, ccs)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ColorspaceIsLabIcc function as declared in fitz/colorspace.h:121
func ColorspaceIsLabIcc(ctx []Context, cs []Colorspace) int32 {
	cctx, _ := unpackArgSContext(ctx)
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	__ret := C.fz_colorspace_is_lab_icc(cctx, ccs)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ColorspaceIsCal function as declared in fitz/colorspace.h:122
func ColorspaceIsCal(ctx []Context, cs []Colorspace) int32 {
	cctx, _ := unpackArgSContext(ctx)
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	__ret := C.fz_colorspace_is_cal(cctx, ccs)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ColorspaceIsIndexed function as declared in fitz/colorspace.h:123
func ColorspaceIsIndexed(ctx []Context, cs []Colorspace) int32 {
	cctx, _ := unpackArgSContext(ctx)
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	__ret := C.fz_colorspace_is_indexed(cctx, ccs)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ColorspaceN function as declared in fitz/colorspace.h:124
func ColorspaceN(ctx []Context, cs []Colorspace) int32 {
	cctx, _ := unpackArgSContext(ctx)
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	__ret := C.fz_colorspace_n(cctx, ccs)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ColorspaceDevicenN function as declared in fitz/colorspace.h:125
func ColorspaceDevicenN(ctx []Context, cs []Colorspace) int32 {
	cctx, _ := unpackArgSContext(ctx)
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	__ret := C.fz_colorspace_devicen_n(cctx, ccs)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ColorspaceName function as declared in fitz/colorspace.h:126
func ColorspaceName(ctx []Context, cs []Colorspace) string {
	cctx, _ := unpackArgSContext(ctx)
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	__ret := C.fz_colorspace_name(cctx, ccs)
	packSContext(ctx, cctx)
	__v := packPCharString(__ret)
	return __v
}

// ClampColor function as declared in fitz/colorspace.h:127
func ClampColor(ctx []Context, cs []Colorspace, in []float32, out []float32) {
	cctx, _ := unpackArgSContext(ctx)
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	cin, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&in)).Data)), cgoAllocsUnknown
	cout, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&out)).Data)), cgoAllocsUnknown
	C.fz_clamp_color(cctx, ccs, cin, cout)
	packSContext(ctx, cctx)
}

// ConvertColor function as declared in fitz/colorspace.h:128
func ConvertColor(ctx []Context, params []ColorParams, intcs []Colorspace, dscs []Colorspace, dstv []float32, srcs []Colorspace, srcv []float32) {
	cctx, _ := unpackArgSContext(ctx)
	cparams, _ := unpackArgSColorParams(params)
	cintcs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&intcs)).Data)), cgoAllocsUnknown
	cdscs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dscs)).Data)), cgoAllocsUnknown
	cdstv, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dstv)).Data)), cgoAllocsUnknown
	csrcs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&srcs)).Data)), cgoAllocsUnknown
	csrcv, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&srcv)).Data)), cgoAllocsUnknown
	C.fz_convert_color(cctx, cparams, cintcs, cdscs, cdstv, csrcs, csrcv)
	packSColorParams(params, cparams)
	packSContext(ctx, cctx)
}

// FindColorConverter function as declared in fitz/colorspace.h:147
func FindColorConverter(ctx []Context, cc []ColorConverter, is []Colorspace, ds []Colorspace, ss []Colorspace, params []ColorParams) {
	cctx, _ := unpackArgSContext(ctx)
	ccc, _ := unpackArgSColorConverter(cc)
	cis, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&is)).Data)), cgoAllocsUnknown
	cds, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ds)).Data)), cgoAllocsUnknown
	css, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ss)).Data)), cgoAllocsUnknown
	cparams, _ := unpackArgSColorParams(params)
	C.fz_find_color_converter(cctx, ccc, cis, cds, css, cparams)
	packSColorParams(params, cparams)
	packSColorConverter(cc, ccc)
	packSContext(ctx, cctx)
}

// DropColorConverter function as declared in fitz/colorspace.h:148
func DropColorConverter(ctx []Context, cc []ColorConverter) {
	cctx, _ := unpackArgSContext(ctx)
	ccc, _ := unpackArgSColorConverter(cc)
	C.fz_drop_color_converter(cctx, ccc)
	packSColorConverter(cc, ccc)
	packSContext(ctx, cctx)
}

// InitCachedColorConverter function as declared in fitz/colorspace.h:149
func InitCachedColorConverter(ctx []Context, cc []ColorConverter, is []Colorspace, ds []Colorspace, ss []Colorspace, params []ColorParams) {
	cctx, _ := unpackArgSContext(ctx)
	ccc, _ := unpackArgSColorConverter(cc)
	cis, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&is)).Data)), cgoAllocsUnknown
	cds, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ds)).Data)), cgoAllocsUnknown
	css, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ss)).Data)), cgoAllocsUnknown
	cparams, _ := unpackArgSColorParams(params)
	C.fz_init_cached_color_converter(cctx, ccc, cis, cds, css, cparams)
	packSColorParams(params, cparams)
	packSColorConverter(cc, ccc)
	packSContext(ctx, cctx)
}

// FinCachedColorConverter function as declared in fitz/colorspace.h:150
func FinCachedColorConverter(ctx []Context, cc []ColorConverter) {
	cctx, _ := unpackArgSContext(ctx)
	ccc, _ := unpackArgSColorConverter(cc)
	C.fz_fin_cached_color_converter(cctx, ccc)
	packSColorConverter(cc, ccc)
	packSContext(ctx, cctx)
}

// NewIccColorspace function as declared in fitz/colorspace.h:167
func NewIccColorspace(ctx []Context, name string, num int32, buf []Buffer) *Colorspace {
	cctx, _ := unpackArgSContext(ctx)
	cname, _ := unpackPCharString(name)
	cnum, _ := (C.int)(num), cgoAllocsUnknown
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	__ret := C.fz_new_icc_colorspace(cctx, cname, cnum, cbuf)
	packSContext(ctx, cctx)
	__v := *(**Colorspace)(unsafe.Pointer(&__ret))
	return __v
}

// NewCalColorspace function as declared in fitz/colorspace.h:168
func NewCalColorspace(ctx []Context, name string, wp []float32, bp []float32, gamma []float32, matrix []float32) *Colorspace {
	cctx, _ := unpackArgSContext(ctx)
	cname, _ := unpackPCharString(name)
	cwp, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&wp)).Data)), cgoAllocsUnknown
	cbp, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&bp)).Data)), cgoAllocsUnknown
	cgamma, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&gamma)).Data)), cgoAllocsUnknown
	cmatrix, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&matrix)).Data)), cgoAllocsUnknown
	__ret := C.fz_new_cal_colorspace(cctx, cname, cwp, cbp, cgamma, cmatrix)
	packSContext(ctx, cctx)
	__v := *(**Colorspace)(unsafe.Pointer(&__ret))
	return __v
}

// NewIccDataFromCalColorspace function as declared in fitz/colorspace.h:169
func NewIccDataFromCalColorspace(ctx []Context, cal []CalColorspace) *Buffer {
	cctx, _ := unpackArgSContext(ctx)
	ccal, _ := unpackArgSCalColorspace(cal)
	__ret := C.fz_new_icc_data_from_cal_colorspace(cctx, ccal)
	packSCalColorspace(cal, ccal)
	packSContext(ctx, cctx)
	__v := *(**Buffer)(unsafe.Pointer(&__ret))
	return __v
}

// IccDataFromIccColorspace function as declared in fitz/colorspace.h:170
func IccDataFromIccColorspace(ctx []Context, cs []Colorspace) *Buffer {
	cctx, _ := unpackArgSContext(ctx)
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	__ret := C.fz_icc_data_from_icc_colorspace(cctx, ccs)
	packSContext(ctx, cctx)
	__v := *(**Buffer)(unsafe.Pointer(&__ret))
	return __v
}

// NewDefaultColorspaces function as declared in fitz/colorspace.h:173
func NewDefaultColorspaces(ctx []Context) *DefaultColorspaces {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_new_default_colorspaces(cctx)
	packSContext(ctx, cctx)
	__v := *(**DefaultColorspaces)(unsafe.Pointer(&__ret))
	return __v
}

// KeepDefaultColorspaces function as declared in fitz/colorspace.h:174
func KeepDefaultColorspaces(ctx []Context, defaultCs []DefaultColorspaces) *DefaultColorspaces {
	cctx, _ := unpackArgSContext(ctx)
	cdefaultCs, _ := (*C.fz_default_colorspaces)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&defaultCs)).Data)), cgoAllocsUnknown
	__ret := C.fz_keep_default_colorspaces(cctx, cdefaultCs)
	packSContext(ctx, cctx)
	__v := *(**DefaultColorspaces)(unsafe.Pointer(&__ret))
	return __v
}

// DropDefaultColorspaces function as declared in fitz/colorspace.h:175
func DropDefaultColorspaces(ctx []Context, defaultCs []DefaultColorspaces) {
	cctx, _ := unpackArgSContext(ctx)
	cdefaultCs, _ := (*C.fz_default_colorspaces)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&defaultCs)).Data)), cgoAllocsUnknown
	C.fz_drop_default_colorspaces(cctx, cdefaultCs)
	packSContext(ctx, cctx)
}

// SetDefaultGray function as declared in fitz/colorspace.h:178
func SetDefaultGray(ctx []Context, defaultCs []DefaultColorspaces, cs []Colorspace) {
	cctx, _ := unpackArgSContext(ctx)
	cdefaultCs, _ := (*C.fz_default_colorspaces)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&defaultCs)).Data)), cgoAllocsUnknown
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	C.fz_set_default_gray(cctx, cdefaultCs, ccs)
	packSContext(ctx, cctx)
}

// SetDefaultRgb function as declared in fitz/colorspace.h:179
func SetDefaultRgb(ctx []Context, defaultCs []DefaultColorspaces, cs []Colorspace) {
	cctx, _ := unpackArgSContext(ctx)
	cdefaultCs, _ := (*C.fz_default_colorspaces)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&defaultCs)).Data)), cgoAllocsUnknown
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	C.fz_set_default_rgb(cctx, cdefaultCs, ccs)
	packSContext(ctx, cctx)
}

// SetDefaultCmyk function as declared in fitz/colorspace.h:180
func SetDefaultCmyk(ctx []Context, defaultCs []DefaultColorspaces, cs []Colorspace) {
	cctx, _ := unpackArgSContext(ctx)
	cdefaultCs, _ := (*C.fz_default_colorspaces)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&defaultCs)).Data)), cgoAllocsUnknown
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	C.fz_set_default_cmyk(cctx, cdefaultCs, ccs)
	packSContext(ctx, cctx)
}

// SetDefaultOutputIntent function as declared in fitz/colorspace.h:181
func SetDefaultOutputIntent(ctx []Context, defaultCs []DefaultColorspaces, cs []Colorspace) {
	cctx, _ := unpackArgSContext(ctx)
	cdefaultCs, _ := (*C.fz_default_colorspaces)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&defaultCs)).Data)), cgoAllocsUnknown
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	C.fz_set_default_output_intent(cctx, cdefaultCs, ccs)
	packSContext(ctx, cctx)
}

// DefaultGray function as declared in fitz/colorspace.h:183
func DefaultGray(ctx []Context, defaultCs []DefaultColorspaces) *Colorspace {
	cctx, _ := unpackArgSContext(ctx)
	cdefaultCs, _ := (*C.fz_default_colorspaces)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&defaultCs)).Data)), cgoAllocsUnknown
	__ret := C.fz_default_gray(cctx, cdefaultCs)
	packSContext(ctx, cctx)
	__v := *(**Colorspace)(unsafe.Pointer(&__ret))
	return __v
}

// DefaultRgb function as declared in fitz/colorspace.h:184
func DefaultRgb(ctx []Context, defaultCs []DefaultColorspaces) *Colorspace {
	cctx, _ := unpackArgSContext(ctx)
	cdefaultCs, _ := (*C.fz_default_colorspaces)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&defaultCs)).Data)), cgoAllocsUnknown
	__ret := C.fz_default_rgb(cctx, cdefaultCs)
	packSContext(ctx, cctx)
	__v := *(**Colorspace)(unsafe.Pointer(&__ret))
	return __v
}

// DefaultCmyk function as declared in fitz/colorspace.h:185
func DefaultCmyk(ctx []Context, defaultCs []DefaultColorspaces) *Colorspace {
	cctx, _ := unpackArgSContext(ctx)
	cdefaultCs, _ := (*C.fz_default_colorspaces)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&defaultCs)).Data)), cgoAllocsUnknown
	__ret := C.fz_default_cmyk(cctx, cdefaultCs)
	packSContext(ctx, cctx)
	__v := *(**Colorspace)(unsafe.Pointer(&__ret))
	return __v
}

// DefaultOutputIntent function as declared in fitz/colorspace.h:186
func DefaultOutputIntent(ctx []Context, defaultCs []DefaultColorspaces) *Colorspace {
	cctx, _ := unpackArgSContext(ctx)
	cdefaultCs, _ := (*C.fz_default_colorspaces)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&defaultCs)).Data)), cgoAllocsUnknown
	__ret := C.fz_default_output_intent(cctx, cdefaultCs)
	packSContext(ctx, cctx)
	__v := *(**Colorspace)(unsafe.Pointer(&__ret))
	return __v
}

// PixmapBbox function as declared in fitz/pixmap.h:23
func PixmapBbox(ctx []Context, pix []Pixmap, bbox []Irect) *Irect {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	cbbox, _ := unpackArgSIrect(bbox)
	__ret := C.fz_pixmap_bbox(cctx, cpix, cbbox)
	packSIrect(bbox, cbbox)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
	__v := NewIrectRef(unsafe.Pointer(__ret))
	return __v
}

// PixmapWidth function as declared in fitz/pixmap.h:28
func PixmapWidth(ctx []Context, pix []Pixmap) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	__ret := C.fz_pixmap_width(cctx, cpix)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// PixmapHeight function as declared in fitz/pixmap.h:33
func PixmapHeight(ctx []Context, pix []Pixmap) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	__ret := C.fz_pixmap_height(cctx, cpix)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// PixmapX function as declared in fitz/pixmap.h:38
func PixmapX(ctx []Context, pix []Pixmap) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	__ret := C.fz_pixmap_x(cctx, cpix)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// PixmapY function as declared in fitz/pixmap.h:43
func PixmapY(ctx []Context, pix []Pixmap) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	__ret := C.fz_pixmap_y(cctx, cpix)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// NewPixmap function as declared in fitz/pixmap.h:62
func NewPixmap(ctx []Context, cs []Colorspace, w int32, h int32, seps []Separations, alpha int32) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	cw, _ := (C.int)(w), cgoAllocsUnknown
	ch, _ := (C.int)(h), cgoAllocsUnknown
	cseps, _ := (*C.fz_separations)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&seps)).Data)), cgoAllocsUnknown
	calpha, _ := (C.int)(alpha), cgoAllocsUnknown
	__ret := C.fz_new_pixmap(cctx, ccs, cw, ch, cseps, calpha)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// NewPixmapWithBbox function as declared in fitz/pixmap.h:85
func NewPixmapWithBbox(ctx []Context, colorspace []Colorspace, bbox []Irect, seps []Separations, alpha int32) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	ccolorspace, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&colorspace)).Data)), cgoAllocsUnknown
	cbbox, _ := unpackArgSIrect(bbox)
	cseps, _ := (*C.fz_separations)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&seps)).Data)), cgoAllocsUnknown
	calpha, _ := (C.int)(alpha), cgoAllocsUnknown
	__ret := C.fz_new_pixmap_with_bbox(cctx, ccolorspace, cbbox, cseps, calpha)
	packSIrect(bbox, cbbox)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// NewPixmapWithData function as declared in fitz/pixmap.h:110
func NewPixmapWithData(ctx []Context, colorspace []Colorspace, w int32, h int32, seps []Separations, alpha int32, stride int32, samples []byte) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	ccolorspace, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&colorspace)).Data)), cgoAllocsUnknown
	cw, _ := (C.int)(w), cgoAllocsUnknown
	ch, _ := (C.int)(h), cgoAllocsUnknown
	cseps, _ := (*C.fz_separations)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&seps)).Data)), cgoAllocsUnknown
	calpha, _ := (C.int)(alpha), cgoAllocsUnknown
	cstride, _ := (C.int)(stride), cgoAllocsUnknown
	csamples, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&samples)).Data)), cgoAllocsUnknown
	__ret := C.fz_new_pixmap_with_data(cctx, ccolorspace, cw, ch, cseps, calpha, cstride, csamples)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// NewPixmapWithBboxAndData function as declared in fitz/pixmap.h:135
func NewPixmapWithBboxAndData(ctx []Context, colorspace []Colorspace, rect []Irect, seps []Separations, alpha int32, samples []byte) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	ccolorspace, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&colorspace)).Data)), cgoAllocsUnknown
	crect, _ := unpackArgSIrect(rect)
	cseps, _ := (*C.fz_separations)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&seps)).Data)), cgoAllocsUnknown
	calpha, _ := (C.int)(alpha), cgoAllocsUnknown
	csamples, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&samples)).Data)), cgoAllocsUnknown
	__ret := C.fz_new_pixmap_with_bbox_and_data(cctx, ccolorspace, crect, cseps, calpha, csamples)
	packSIrect(rect, crect)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// KeepPixmap function as declared in fitz/pixmap.h:144
func KeepPixmap(ctx []Context, pix []Pixmap) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	__ret := C.fz_keep_pixmap(cctx, cpix)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// DropPixmap function as declared in fitz/pixmap.h:152
func DropPixmap(ctx []Context, pix []Pixmap) {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	C.fz_drop_pixmap(cctx, cpix)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
}

// PixmapColorspace function as declared in fitz/pixmap.h:159
func PixmapColorspace(ctx []Context, pix []Pixmap) *Colorspace {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	__ret := C.fz_pixmap_colorspace(cctx, cpix)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
	__v := *(**Colorspace)(unsafe.Pointer(&__ret))
	return __v
}

// PixmapComponents function as declared in fitz/pixmap.h:166
func PixmapComponents(ctx []Context, pix []Pixmap) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	__ret := C.fz_pixmap_components(cctx, cpix)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// PixmapColorants function as declared in fitz/pixmap.h:173
func PixmapColorants(ctx []Context, pix []Pixmap) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	__ret := C.fz_pixmap_colorants(cctx, cpix)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// PixmapSpots function as declared in fitz/pixmap.h:180
func PixmapSpots(ctx []Context, pix []Pixmap) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	__ret := C.fz_pixmap_spots(cctx, cpix)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// PixmapAlpha function as declared in fitz/pixmap.h:187
func PixmapAlpha(ctx []Context, pix []Pixmap) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	__ret := C.fz_pixmap_alpha(cctx, cpix)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// PixmapSamples function as declared in fitz/pixmap.h:194
func PixmapSamples(ctx []Context, pix []Pixmap) *byte {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	__ret := C.fz_pixmap_samples(cctx, cpix)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// PixmapStride function as declared in fitz/pixmap.h:199
func PixmapStride(ctx []Context, pix []Pixmap) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	__ret := C.fz_pixmap_stride(cctx, cpix)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// SetPixmapResolution function as declared in fitz/pixmap.h:204
func SetPixmapResolution(ctx []Context, pix []Pixmap, xres int32, yres int32) {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	cxres, _ := (C.int)(xres), cgoAllocsUnknown
	cyres, _ := (C.int)(yres), cgoAllocsUnknown
	C.fz_set_pixmap_resolution(cctx, cpix, cxres, cyres)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
}

// ClearPixmapWithValue function as declared in fitz/pixmap.h:215
func ClearPixmapWithValue(ctx []Context, pix []Pixmap, value int32) {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	cvalue, _ := (C.int)(value), cgoAllocsUnknown
	C.fz_clear_pixmap_with_value(cctx, cpix, cvalue)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
}

// FillPixmapWithColor function as declared in fitz/pixmap.h:220
func FillPixmapWithColor(ctx []Context, pix []Pixmap, colorspace []Colorspace, color []float32, colorParams []ColorParams) {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	ccolorspace, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&colorspace)).Data)), cgoAllocsUnknown
	ccolor, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&color)).Data)), cgoAllocsUnknown
	ccolorParams, _ := unpackArgSColorParams(colorParams)
	C.fz_fill_pixmap_with_color(cctx, cpix, ccolorspace, ccolor, ccolorParams)
	packSColorParams(colorParams, ccolorParams)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
}

// ClearPixmapRectWithValue function as declared in fitz/pixmap.h:233
func ClearPixmapRectWithValue(ctx []Context, pix []Pixmap, value int32, r []Irect) {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	cvalue, _ := (C.int)(value), cgoAllocsUnknown
	cr, _ := unpackArgSIrect(r)
	C.fz_clear_pixmap_rect_with_value(cctx, cpix, cvalue, cr)
	packSIrect(r, cr)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
}

// ClearPixmap function as declared in fitz/pixmap.h:241
func ClearPixmap(ctx []Context, pix []Pixmap) {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	C.fz_clear_pixmap(cctx, cpix)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
}

// InvertPixmap function as declared in fitz/pixmap.h:247
func InvertPixmap(ctx []Context, pix []Pixmap) {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	C.fz_invert_pixmap(cctx, cpix)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
}

// TintPixmap function as declared in fitz/pixmap.h:256
func TintPixmap(ctx []Context, pix []Pixmap, r int32, g int32, b int32) {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	cr, _ := (C.int)(r), cgoAllocsUnknown
	cg, _ := (C.int)(g), cgoAllocsUnknown
	cb, _ := (C.int)(b), cgoAllocsUnknown
	C.fz_tint_pixmap(cctx, cpix, cr, cg, cb)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
}

// InvertPixmapRect function as declared in fitz/pixmap.h:263
func InvertPixmapRect(ctx []Context, image []Pixmap, rect []Irect) {
	cctx, _ := unpackArgSContext(ctx)
	cimage, _ := unpackArgSPixmap(image)
	crect, _ := unpackArgSIrect(rect)
	C.fz_invert_pixmap_rect(cctx, cimage, crect)
	packSIrect(rect, crect)
	packSPixmap(image, cimage)
	packSContext(ctx, cctx)
}

// GammaPixmap function as declared in fitz/pixmap.h:271
func GammaPixmap(ctx []Context, pix []Pixmap, gamma float32) {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	cgamma, _ := (C.float)(gamma), cgoAllocsUnknown
	C.fz_gamma_pixmap(cctx, cpix, cgamma)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
}

// UnmultiplyPixmap function as declared in fitz/pixmap.h:277
func UnmultiplyPixmap(ctx []Context, pix []Pixmap) {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	C.fz_unmultiply_pixmap(cctx, cpix)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
}

// ConvertPixmap function as declared in fitz/pixmap.h:298
func ConvertPixmap(ctx []Context, pix []Pixmap, csDes []Colorspace, prf []Colorspace, defaultCs []DefaultColorspaces, colorParams []ColorParams, keepAlpha int32) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	ccsDes, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&csDes)).Data)), cgoAllocsUnknown
	cprf, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&prf)).Data)), cgoAllocsUnknown
	cdefaultCs, _ := (*C.fz_default_colorspaces)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&defaultCs)).Data)), cgoAllocsUnknown
	ccolorParams, _ := unpackArgSColorParams(colorParams)
	ckeepAlpha, _ := (C.int)(keepAlpha), cgoAllocsUnknown
	__ret := C.fz_convert_pixmap(cctx, cpix, ccsDes, cprf, cdefaultCs, ccolorParams, ckeepAlpha)
	packSColorParams(colorParams, ccolorParams)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// DropPixmapImp function as declared in fitz/pixmap.h:361
func DropPixmapImp(ctx []Context, pix []Storable) {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSStorable(pix)
	C.fz_drop_pixmap_imp(cctx, cpix)
	packSStorable(pix, cpix)
	packSContext(ctx, cctx)
}

// CopyPixmapRect function as declared in fitz/pixmap.h:363
func CopyPixmapRect(ctx []Context, dest []Pixmap, src []Pixmap, r []Irect, defaultCs []DefaultColorspaces) {
	cctx, _ := unpackArgSContext(ctx)
	cdest, _ := unpackArgSPixmap(dest)
	csrc, _ := unpackArgSPixmap(src)
	cr, _ := unpackArgSIrect(r)
	cdefaultCs, _ := (*C.fz_default_colorspaces)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&defaultCs)).Data)), cgoAllocsUnknown
	C.fz_copy_pixmap_rect(cctx, cdest, csrc, cr, cdefaultCs)
	packSIrect(r, cr)
	packSPixmap(src, csrc)
	packSPixmap(dest, cdest)
	packSContext(ctx, cctx)
}

// PremultiplyPixmap function as declared in fitz/pixmap.h:364
func PremultiplyPixmap(ctx []Context, pix []Pixmap) {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	C.fz_premultiply_pixmap(cctx, cpix)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
}

// AlphaFromGray function as declared in fitz/pixmap.h:365
func AlphaFromGray(ctx []Context, gray []Pixmap) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	cgray, _ := unpackArgSPixmap(gray)
	__ret := C.fz_alpha_from_gray(cctx, cgray)
	packSPixmap(gray, cgray)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// PixmapSize function as declared in fitz/pixmap.h:366
func PixmapSize(ctx []Context, pix []Pixmap) uint {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	__ret := C.fz_pixmap_size(cctx, cpix)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
	__v := (uint)(__ret)
	return __v
}

// ScalePixmap function as declared in fitz/pixmap.h:368
func ScalePixmap(ctx []Context, src []Pixmap, x float32, y float32, w float32, h float32, clip []Irect) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	csrc, _ := unpackArgSPixmap(src)
	cx, _ := (C.float)(x), cgoAllocsUnknown
	cy, _ := (C.float)(y), cgoAllocsUnknown
	cw, _ := (C.float)(w), cgoAllocsUnknown
	ch, _ := (C.float)(h), cgoAllocsUnknown
	cclip, _ := unpackArgSIrect(clip)
	__ret := C.fz_scale_pixmap(cctx, csrc, cx, cy, cw, ch, cclip)
	packSIrect(clip, cclip)
	packSPixmap(src, csrc)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// NewScaleCache function as declared in fitz/pixmap.h:372
func NewScaleCache(ctx []Context) *ScaleCache {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_new_scale_cache(cctx)
	packSContext(ctx, cctx)
	__v := *(**ScaleCache)(unsafe.Pointer(&__ret))
	return __v
}

// DropScaleCache function as declared in fitz/pixmap.h:373
func DropScaleCache(ctx []Context, cache []ScaleCache) {
	cctx, _ := unpackArgSContext(ctx)
	ccache, _ := (*C.fz_scale_cache)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cache)).Data)), cgoAllocsUnknown
	C.fz_drop_scale_cache(cctx, ccache)
	packSContext(ctx, cctx)
}

// ScalePixmapCached function as declared in fitz/pixmap.h:374
func ScalePixmapCached(ctx []Context, src []Pixmap, x float32, y float32, w float32, h float32, clip []Irect, cacheX []ScaleCache, cacheY []ScaleCache) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	csrc, _ := unpackArgSPixmap(src)
	cx, _ := (C.float)(x), cgoAllocsUnknown
	cy, _ := (C.float)(y), cgoAllocsUnknown
	cw, _ := (C.float)(w), cgoAllocsUnknown
	ch, _ := (C.float)(h), cgoAllocsUnknown
	cclip, _ := unpackArgSIrect(clip)
	ccacheX, _ := (*C.fz_scale_cache)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cacheX)).Data)), cgoAllocsUnknown
	ccacheY, _ := (*C.fz_scale_cache)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cacheY)).Data)), cgoAllocsUnknown
	__ret := C.fz_scale_pixmap_cached(cctx, csrc, cx, cy, cw, ch, cclip, ccacheX, ccacheY)
	packSIrect(clip, cclip)
	packSPixmap(src, csrc)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// SubsamplePixmap function as declared in fitz/pixmap.h:376
func SubsamplePixmap(ctx []Context, tile []Pixmap, factor int32) {
	cctx, _ := unpackArgSContext(ctx)
	ctile, _ := unpackArgSPixmap(tile)
	cfactor, _ := (C.int)(factor), cgoAllocsUnknown
	C.fz_subsample_pixmap(cctx, ctile, cfactor)
	packSPixmap(tile, ctile)
	packSContext(ctx, cctx)
}

// PixmapBboxNoCtx function as declared in fitz/pixmap.h:378
func PixmapBboxNoCtx(src []Pixmap, bbox []Irect) *Irect {
	csrc, _ := unpackArgSPixmap(src)
	cbbox, _ := unpackArgSIrect(bbox)
	__ret := C.fz_pixmap_bbox_no_ctx(csrc, cbbox)
	packSIrect(bbox, cbbox)
	packSPixmap(src, csrc)
	__v := NewIrectRef(unsafe.Pointer(__ret))
	return __v
}

// DecodeTile function as declared in fitz/pixmap.h:380
func DecodeTile(ctx []Context, pix []Pixmap, decode []float32) {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	cdecode, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&decode)).Data)), cgoAllocsUnknown
	C.fz_decode_tile(cctx, cpix, cdecode)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
}

// DecodeIndexedTile function as declared in fitz/pixmap.h:381
func DecodeIndexedTile(ctx []Context, pix []Pixmap, decode []float32, maxval int32) {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	cdecode, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&decode)).Data)), cgoAllocsUnknown
	cmaxval, _ := (C.int)(maxval), cgoAllocsUnknown
	C.fz_decode_indexed_tile(cctx, cpix, cdecode, cmaxval)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
}

// UnpackTile function as declared in fitz/pixmap.h:382
func UnpackTile(ctx []Context, dst []Pixmap, src []byte, n int32, depth int32, stride uint, scale int32) {
	cctx, _ := unpackArgSContext(ctx)
	cdst, _ := unpackArgSPixmap(dst)
	csrc, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&src)).Data)), cgoAllocsUnknown
	cn, _ := (C.int)(n), cgoAllocsUnknown
	cdepth, _ := (C.int)(depth), cgoAllocsUnknown
	cstride, _ := (C.size_t)(stride), cgoAllocsUnknown
	cscale, _ := (C.int)(scale), cgoAllocsUnknown
	C.fz_unpack_tile(cctx, cdst, csrc, cn, cdepth, cstride, cscale)
	packSPixmap(dst, cdst)
	packSContext(ctx, cctx)
}

// LookupPixmapConverter function as declared in fitz/pixmap.h:389
func LookupPixmapConverter(ctx []Context, ds []Colorspace, ss []Colorspace) *PixmapConverter {
	cctx, _ := unpackArgSContext(ctx)
	cds, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ds)).Data)), cgoAllocsUnknown
	css, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ss)).Data)), cgoAllocsUnknown
	__ret := C.fz_lookup_pixmap_converter(cctx, cds, css)
	packSContext(ctx, cctx)
	__v := NewPixmapConverterRef(unsafe.Pointer(__ret))
	return __v
}

// Md5Pixmap function as declared in fitz/pixmap.h:394
func Md5Pixmap(ctx []Context, pixmap []Pixmap, digest *[16]byte) {
	cctx, _ := unpackArgSContext(ctx)
	cpixmap, _ := unpackArgSPixmap(pixmap)
	cdigest, _ := *(**C.uchar)(unsafe.Pointer(&digest)), cgoAllocsUnknown
	C.fz_md5_pixmap(cctx, cpixmap, cdigest)
	packSPixmap(pixmap, cpixmap)
	packSContext(ctx, cctx)
}

// NewPixmapFrom8bppData function as declared in fitz/pixmap.h:396
func NewPixmapFrom8bppData(ctx []Context, x int32, y int32, w int32, h int32, sp []byte, span int32) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	cx, _ := (C.int)(x), cgoAllocsUnknown
	cy, _ := (C.int)(y), cgoAllocsUnknown
	cw, _ := (C.int)(w), cgoAllocsUnknown
	ch, _ := (C.int)(h), cgoAllocsUnknown
	csp, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&sp)).Data)), cgoAllocsUnknown
	cspan, _ := (C.int)(span), cgoAllocsUnknown
	__ret := C.fz_new_pixmap_from_8bpp_data(cctx, cx, cy, cw, ch, csp, cspan)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// NewPixmapFrom1bppData function as declared in fitz/pixmap.h:397
func NewPixmapFrom1bppData(ctx []Context, x int32, y int32, w int32, h int32, sp []byte, span int32) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	cx, _ := (C.int)(x), cgoAllocsUnknown
	cy, _ := (C.int)(y), cgoAllocsUnknown
	cw, _ := (C.int)(w), cgoAllocsUnknown
	ch, _ := (C.int)(h), cgoAllocsUnknown
	csp, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&sp)).Data)), cgoAllocsUnknown
	cspan, _ := (C.int)(span), cgoAllocsUnknown
	__ret := C.fz_new_pixmap_from_1bpp_data(cctx, cx, cy, cw, ch, csp, cspan)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// ClonePixmapAreaWithDifferentSeps function as declared in fitz/pixmap.h:409
func ClonePixmapAreaWithDifferentSeps(ctx []Context, src []Pixmap, bbox []Irect, dcs []Colorspace, seps []Separations, colorParams []ColorParams, prf []Colorspace, defaultCs []DefaultColorspaces) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	csrc, _ := unpackArgSPixmap(src)
	cbbox, _ := unpackArgSIrect(bbox)
	cdcs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dcs)).Data)), cgoAllocsUnknown
	cseps, _ := (*C.fz_separations)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&seps)).Data)), cgoAllocsUnknown
	ccolorParams, _ := unpackArgSColorParams(colorParams)
	cprf, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&prf)).Data)), cgoAllocsUnknown
	cdefaultCs, _ := (*C.fz_default_colorspaces)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&defaultCs)).Data)), cgoAllocsUnknown
	__ret := C.fz_clone_pixmap_area_with_different_seps(cctx, csrc, cbbox, cdcs, cseps, ccolorParams, cprf, cdefaultCs)
	packSColorParams(colorParams, ccolorParams)
	packSIrect(bbox, cbbox)
	packSPixmap(src, csrc)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// CopyPixmapAreaConvertingSeps function as declared in fitz/pixmap.h:411
func CopyPixmapAreaConvertingSeps(ctx []Context, dst []Pixmap, src []Pixmap, colorParams []ColorParams, prf []Colorspace, defaultCs []DefaultColorspaces) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	cdst, _ := unpackArgSPixmap(dst)
	csrc, _ := unpackArgSPixmap(src)
	ccolorParams, _ := unpackArgSColorParams(colorParams)
	cprf, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&prf)).Data)), cgoAllocsUnknown
	cdefaultCs, _ := (*C.fz_default_colorspaces)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&defaultCs)).Data)), cgoAllocsUnknown
	__ret := C.fz_copy_pixmap_area_converting_seps(cctx, cdst, csrc, ccolorParams, cprf, cdefaultCs)
	packSColorParams(colorParams, ccolorParams)
	packSPixmap(src, csrc)
	packSPixmap(dst, cdst)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// NewSeparations function as declared in fitz/separation.h:35
func NewSeparations(ctx []Context, controllable int32) *Separations {
	cctx, _ := unpackArgSContext(ctx)
	ccontrollable, _ := (C.int)(controllable), cgoAllocsUnknown
	__ret := C.fz_new_separations(cctx, ccontrollable)
	packSContext(ctx, cctx)
	__v := *(**Separations)(unsafe.Pointer(&__ret))
	return __v
}

// KeepSeparations function as declared in fitz/separation.h:38
func KeepSeparations(ctx []Context, sep []Separations) *Separations {
	cctx, _ := unpackArgSContext(ctx)
	csep, _ := (*C.fz_separations)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&sep)).Data)), cgoAllocsUnknown
	__ret := C.fz_keep_separations(cctx, csep)
	packSContext(ctx, cctx)
	__v := *(**Separations)(unsafe.Pointer(&__ret))
	return __v
}

// DropSeparations function as declared in fitz/separation.h:41
func DropSeparations(ctx []Context, sep []Separations) {
	cctx, _ := unpackArgSContext(ctx)
	csep, _ := (*C.fz_separations)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&sep)).Data)), cgoAllocsUnknown
	C.fz_drop_separations(cctx, csep)
	packSContext(ctx, cctx)
}

// AddSeparation function as declared in fitz/separation.h:44
func AddSeparation(ctx []Context, sep []Separations, name string, cs []Colorspace, csChannel int32) {
	cctx, _ := unpackArgSContext(ctx)
	csep, _ := (*C.fz_separations)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&sep)).Data)), cgoAllocsUnknown
	cname, _ := unpackPCharString(name)
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	ccsChannel, _ := (C.int)(csChannel), cgoAllocsUnknown
	C.fz_add_separation(cctx, csep, cname, ccs, ccsChannel)
	packSContext(ctx, cctx)
}

// AddSeparationEquivalents function as declared in fitz/separation.h:47
func AddSeparationEquivalents(ctx []Context, sep []Separations, rgba uint32, cmyk uint32, name string) {
	cctx, _ := unpackArgSContext(ctx)
	csep, _ := (*C.fz_separations)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&sep)).Data)), cgoAllocsUnknown
	crgba, _ := (C.uint32_t)(rgba), cgoAllocsUnknown
	ccmyk, _ := (C.uint32_t)(cmyk), cgoAllocsUnknown
	cname, _ := unpackPCharString(name)
	C.fz_add_separation_equivalents(cctx, csep, crgba, ccmyk, cname)
	packSContext(ctx, cctx)
}

// SetSeparationBehavior function as declared in fitz/separation.h:50
func SetSeparationBehavior(ctx []Context, sep []Separations, separation int32, behavior SeparationBehavior) {
	cctx, _ := unpackArgSContext(ctx)
	csep, _ := (*C.fz_separations)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&sep)).Data)), cgoAllocsUnknown
	cseparation, _ := (C.int)(separation), cgoAllocsUnknown
	cbehavior, _ := (C.fz_separation_behavior)(behavior), cgoAllocsUnknown
	C.fz_set_separation_behavior(cctx, csep, cseparation, cbehavior)
	packSContext(ctx, cctx)
}

// SeparationCurrentBehavior function as declared in fitz/separation.h:53
func SeparationCurrentBehavior(ctx []Context, sep []Separations, separation int32) SeparationBehavior {
	cctx, _ := unpackArgSContext(ctx)
	csep, _ := (*C.fz_separations)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&sep)).Data)), cgoAllocsUnknown
	cseparation, _ := (C.int)(separation), cgoAllocsUnknown
	__ret := C.fz_separation_current_behavior(cctx, csep, cseparation)
	packSContext(ctx, cctx)
	__v := (SeparationBehavior)(__ret)
	return __v
}

// SeparationsAllComposite function as declared in fitz/separation.h:56
func SeparationsAllComposite(ctx []Context, sep []Separations) int32 {
	cctx, _ := unpackArgSContext(ctx)
	csep, _ := (*C.fz_separations)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&sep)).Data)), cgoAllocsUnknown
	__ret := C.fz_separations_all_composite(cctx, csep)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// SeparationName function as declared in fitz/separation.h:59
func SeparationName(ctx []Context, sep []Separations, separation int32) string {
	cctx, _ := unpackArgSContext(ctx)
	csep, _ := (*C.fz_separations)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&sep)).Data)), cgoAllocsUnknown
	cseparation, _ := (C.int)(separation), cgoAllocsUnknown
	__ret := C.fz_separation_name(cctx, csep, cseparation)
	packSContext(ctx, cctx)
	__v := packPCharString(__ret)
	return __v
}

// CountSeparations function as declared in fitz/separation.h:62
func CountSeparations(ctx []Context, sep []Separations) int32 {
	cctx, _ := unpackArgSContext(ctx)
	csep, _ := (*C.fz_separations)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&sep)).Data)), cgoAllocsUnknown
	__ret := C.fz_count_separations(cctx, csep)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// SeparationsControllable function as declared in fitz/separation.h:65
func SeparationsControllable(ctx []Context, seps []Separations) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cseps, _ := (*C.fz_separations)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&seps)).Data)), cgoAllocsUnknown
	__ret := C.fz_separations_controllable(cctx, cseps)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// CountActiveSeparations function as declared in fitz/separation.h:68
func CountActiveSeparations(ctx []Context, seps []Separations) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cseps, _ := (*C.fz_separations)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&seps)).Data)), cgoAllocsUnknown
	__ret := C.fz_count_active_separations(cctx, cseps)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// CloneSeparationsForOverprint function as declared in fitz/separation.h:72
func CloneSeparationsForOverprint(ctx []Context, seps []Separations) *Separations {
	cctx, _ := unpackArgSContext(ctx)
	cseps, _ := (*C.fz_separations)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&seps)).Data)), cgoAllocsUnknown
	__ret := C.fz_clone_separations_for_overprint(cctx, cseps)
	packSContext(ctx, cctx)
	__v := *(**Separations)(unsafe.Pointer(&__ret))
	return __v
}

// ConvertSeparationColors function as declared in fitz/separation.h:76
func ConvertSeparationColors(ctx []Context, colorParams []ColorParams, dstCs []Colorspace, dstSep []Separations, dstColor []float32, srcCs []Colorspace, srcColor []float32) {
	cctx, _ := unpackArgSContext(ctx)
	ccolorParams, _ := unpackArgSColorParams(colorParams)
	cdstCs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dstCs)).Data)), cgoAllocsUnknown
	cdstSep, _ := (*C.fz_separations)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dstSep)).Data)), cgoAllocsUnknown
	cdstColor, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dstColor)).Data)), cgoAllocsUnknown
	csrcCs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&srcCs)).Data)), cgoAllocsUnknown
	csrcColor, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&srcColor)).Data)), cgoAllocsUnknown
	C.fz_convert_separation_colors(cctx, ccolorParams, cdstCs, cdstSep, cdstColor, csrcCs, csrcColor)
	packSColorParams(colorParams, ccolorParams)
	packSContext(ctx, cctx)
}

// SeparationEquivalent function as declared in fitz/separation.h:79
func SeparationEquivalent(ctx []Context, seps []Separations, i int32, colorParams []ColorParams, dstCs []Colorspace, prf []Colorspace, convert []float32) {
	cctx, _ := unpackArgSContext(ctx)
	cseps, _ := (*C.fz_separations)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&seps)).Data)), cgoAllocsUnknown
	ci, _ := (C.int)(i), cgoAllocsUnknown
	ccolorParams, _ := unpackArgSColorParams(colorParams)
	cdstCs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dstCs)).Data)), cgoAllocsUnknown
	cprf, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&prf)).Data)), cgoAllocsUnknown
	cconvert, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&convert)).Data)), cgoAllocsUnknown
	C.fz_separation_equivalent(cctx, cseps, ci, ccolorParams, cdstCs, cprf, cconvert)
	packSColorParams(colorParams, ccolorParams)
	packSContext(ctx, cctx)
}

// GlyphBbox function as declared in fitz/glyph.h:19
func GlyphBbox(ctx []Context, glyph []Glyph, bbox []Irect) *Irect {
	cctx, _ := unpackArgSContext(ctx)
	cglyph, _ := unpackArgSGlyph(glyph)
	cbbox, _ := unpackArgSIrect(bbox)
	__ret := C.fz_glyph_bbox(cctx, cglyph, cbbox)
	packSIrect(bbox, cbbox)
	packSGlyph(glyph, cglyph)
	packSContext(ctx, cctx)
	__v := NewIrectRef(unsafe.Pointer(__ret))
	return __v
}

// GlyphWidth function as declared in fitz/glyph.h:24
func GlyphWidth(ctx []Context, glyph []Glyph) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cglyph, _ := unpackArgSGlyph(glyph)
	__ret := C.fz_glyph_width(cctx, cglyph)
	packSGlyph(glyph, cglyph)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// GlyphHeight function as declared in fitz/glyph.h:29
func GlyphHeight(ctx []Context, glyph []Glyph) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cglyph, _ := unpackArgSGlyph(glyph)
	__ret := C.fz_glyph_height(cctx, cglyph)
	packSGlyph(glyph, cglyph)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// NewGlyphFromPixmap function as declared in fitz/glyph.h:37
func NewGlyphFromPixmap(ctx []Context, pix []Pixmap) *Glyph {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	__ret := C.fz_new_glyph_from_pixmap(cctx, cpix)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
	__v := NewGlyphRef(unsafe.Pointer(__ret))
	return __v
}

// NewGlyphFrom8bppData function as declared in fitz/glyph.h:53
func NewGlyphFrom8bppData(ctx []Context, x int32, y int32, w int32, h int32, sp []byte, span int32) *Glyph {
	cctx, _ := unpackArgSContext(ctx)
	cx, _ := (C.int)(x), cgoAllocsUnknown
	cy, _ := (C.int)(y), cgoAllocsUnknown
	cw, _ := (C.int)(w), cgoAllocsUnknown
	ch, _ := (C.int)(h), cgoAllocsUnknown
	csp, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&sp)).Data)), cgoAllocsUnknown
	cspan, _ := (C.int)(span), cgoAllocsUnknown
	__ret := C.fz_new_glyph_from_8bpp_data(cctx, cx, cy, cw, ch, csp, cspan)
	packSContext(ctx, cctx)
	__v := NewGlyphRef(unsafe.Pointer(__ret))
	return __v
}

// NewGlyphFrom1bppData function as declared in fitz/glyph.h:69
func NewGlyphFrom1bppData(ctx []Context, x int32, y int32, w int32, h int32, sp []byte, span int32) *Glyph {
	cctx, _ := unpackArgSContext(ctx)
	cx, _ := (C.int)(x), cgoAllocsUnknown
	cy, _ := (C.int)(y), cgoAllocsUnknown
	cw, _ := (C.int)(w), cgoAllocsUnknown
	ch, _ := (C.int)(h), cgoAllocsUnknown
	csp, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&sp)).Data)), cgoAllocsUnknown
	cspan, _ := (C.int)(span), cgoAllocsUnknown
	__ret := C.fz_new_glyph_from_1bpp_data(cctx, cx, cy, cw, ch, csp, cspan)
	packSContext(ctx, cctx)
	__v := NewGlyphRef(unsafe.Pointer(__ret))
	return __v
}

// KeepGlyph function as declared in fitz/glyph.h:78
func KeepGlyph(ctx []Context, pix []Glyph) *Glyph {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSGlyph(pix)
	__ret := C.fz_keep_glyph(cctx, cpix)
	packSGlyph(pix, cpix)
	packSContext(ctx, cctx)
	__v := NewGlyphRef(unsafe.Pointer(__ret))
	return __v
}

// DropGlyph function as declared in fitz/glyph.h:86
func DropGlyph(ctx []Context, pix []Glyph) {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSGlyph(pix)
	C.fz_drop_glyph(cctx, cpix)
	packSGlyph(pix, cpix)
	packSContext(ctx, cctx)
}

// GlyphBboxNoCtx function as declared in fitz/glyph.h:123
func GlyphBboxNoCtx(src []Glyph, bbox []Irect) *Irect {
	csrc, _ := unpackArgSGlyph(src)
	cbbox, _ := unpackArgSIrect(bbox)
	__ret := C.fz_glyph_bbox_no_ctx(csrc, cbbox)
	packSIrect(bbox, cbbox)
	packSGlyph(src, csrc)
	__v := NewIrectRef(unsafe.Pointer(__ret))
	return __v
}

// GlyphSize function as declared in fitz/glyph.h:126
func GlyphSize(ctx []Context, glyph []Glyph) uint {
	cctx, _ := unpackArgSContext(ctx)
	cglyph, _ := unpackArgSGlyph(glyph)
	__ret := C.fz_glyph_size(cctx, cglyph)
	packSGlyph(glyph, cglyph)
	packSContext(ctx, cctx)
	__v := (uint)(__ret)
	return __v
}

// KeepBitmap function as declared in fitz/bitmap.h:22
func KeepBitmap(ctx []Context, bit []Bitmap) *Bitmap {
	cctx, _ := unpackArgSContext(ctx)
	cbit, _ := unpackArgSBitmap(bit)
	__ret := C.fz_keep_bitmap(cctx, cbit)
	packSBitmap(bit, cbit)
	packSContext(ctx, cctx)
	__v := NewBitmapRef(unsafe.Pointer(__ret))
	return __v
}

// DropBitmap function as declared in fitz/bitmap.h:30
func DropBitmap(ctx []Context, bit []Bitmap) {
	cctx, _ := unpackArgSContext(ctx)
	cbit, _ := unpackArgSBitmap(bit)
	C.fz_drop_bitmap(cctx, cbit)
	packSBitmap(bit, cbit)
	packSContext(ctx, cctx)
}

// NewBitmapFromPixmap function as declared in fitz/bitmap.h:52
func NewBitmapFromPixmap(ctx []Context, pix []Pixmap, ht []Halftone) *Bitmap {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	cht, _ := (*C.fz_halftone)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ht)).Data)), cgoAllocsUnknown
	__ret := C.fz_new_bitmap_from_pixmap(cctx, cpix, cht)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
	__v := NewBitmapRef(unsafe.Pointer(__ret))
	return __v
}

// NewBitmapFromPixmapBand function as declared in fitz/bitmap.h:70
func NewBitmapFromPixmapBand(ctx []Context, pix []Pixmap, ht []Halftone, bandStart int32) *Bitmap {
	cctx, _ := unpackArgSContext(ctx)
	cpix, _ := unpackArgSPixmap(pix)
	cht, _ := (*C.fz_halftone)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ht)).Data)), cgoAllocsUnknown
	cbandStart, _ := (C.int)(bandStart), cgoAllocsUnknown
	__ret := C.fz_new_bitmap_from_pixmap_band(cctx, cpix, cht, cbandStart)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
	__v := NewBitmapRef(unsafe.Pointer(__ret))
	return __v
}

// NewBitmap function as declared in fitz/bitmap.h:92
func NewBitmap(ctx []Context, w int32, h int32, n int32, xres int32, yres int32) *Bitmap {
	cctx, _ := unpackArgSContext(ctx)
	cw, _ := (C.int)(w), cgoAllocsUnknown
	ch, _ := (C.int)(h), cgoAllocsUnknown
	cn, _ := (C.int)(n), cgoAllocsUnknown
	cxres, _ := (C.int)(xres), cgoAllocsUnknown
	cyres, _ := (C.int)(yres), cgoAllocsUnknown
	__ret := C.fz_new_bitmap(cctx, cw, ch, cn, cxres, cyres)
	packSContext(ctx, cctx)
	__v := NewBitmapRef(unsafe.Pointer(__ret))
	return __v
}

// BitmapDetails function as declared in fitz/bitmap.h:107
func BitmapDetails(bitmap []Bitmap, w []int32, h []int32, n []int32, stride []int32) {
	cbitmap, _ := unpackArgSBitmap(bitmap)
	cw, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&w)).Data)), cgoAllocsUnknown
	ch, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&h)).Data)), cgoAllocsUnknown
	cn, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&n)).Data)), cgoAllocsUnknown
	cstride, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&stride)).Data)), cgoAllocsUnknown
	C.fz_bitmap_details(cbitmap, cw, ch, cn, cstride)
	packSBitmap(bitmap, cbitmap)
}

// ClearBitmap function as declared in fitz/bitmap.h:114
func ClearBitmap(ctx []Context, bit []Bitmap) {
	cctx, _ := unpackArgSContext(ctx)
	cbit, _ := unpackArgSBitmap(bit)
	C.fz_clear_bitmap(cctx, cbit)
	packSBitmap(bit, cbit)
	packSContext(ctx, cctx)
}

// DefaultHalftone function as declared in fitz/bitmap.h:126
func DefaultHalftone(ctx []Context, numComps int32) *Halftone {
	cctx, _ := unpackArgSContext(ctx)
	cnumComps, _ := (C.int)(numComps), cgoAllocsUnknown
	__ret := C.fz_default_halftone(cctx, cnumComps)
	packSContext(ctx, cctx)
	__v := *(**Halftone)(unsafe.Pointer(&__ret))
	return __v
}

// KeepHalftone function as declared in fitz/bitmap.h:132
func KeepHalftone(ctx []Context, half []Halftone) *Halftone {
	cctx, _ := unpackArgSContext(ctx)
	chalf, _ := (*C.fz_halftone)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&half)).Data)), cgoAllocsUnknown
	__ret := C.fz_keep_halftone(cctx, chalf)
	packSContext(ctx, cctx)
	__v := *(**Halftone)(unsafe.Pointer(&__ret))
	return __v
}

// DropHalftone function as declared in fitz/bitmap.h:138
func DropHalftone(ctx []Context, ht []Halftone) {
	cctx, _ := unpackArgSContext(ctx)
	cht, _ := (*C.fz_halftone)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ht)).Data)), cgoAllocsUnknown
	C.fz_drop_halftone(cctx, cht)
	packSContext(ctx, cctx)
}

// GetPixmapFromImage function as declared in fitz/image.h:47
func GetPixmapFromImage(ctx []Context, image []Image, subarea []Irect, trans []Matrix, w []int32, h []int32) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	cimage, _ := unpackArgSImage(image)
	csubarea, _ := unpackArgSIrect(subarea)
	ctrans, _ := unpackArgSMatrix(trans)
	cw, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&w)).Data)), cgoAllocsUnknown
	ch, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&h)).Data)), cgoAllocsUnknown
	__ret := C.fz_get_pixmap_from_image(cctx, cimage, csubarea, ctrans, cw, ch)
	packSMatrix(trans, ctrans)
	packSIrect(subarea, csubarea)
	packSImage(image, cimage)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// DropImage function as declared in fitz/image.h:54
func DropImage(ctx []Context, image []Image) {
	cctx, _ := unpackArgSContext(ctx)
	cimage, _ := unpackArgSImage(image)
	C.fz_drop_image(cctx, cimage)
	packSImage(image, cimage)
	packSContext(ctx, cctx)
}

// KeepImage function as declared in fitz/image.h:63
func KeepImage(ctx []Context, image []Image) *Image {
	cctx, _ := unpackArgSContext(ctx)
	cimage, _ := unpackArgSImage(image)
	__ret := C.fz_keep_image(cctx, cimage)
	packSImage(image, cimage)
	packSContext(ctx, cctx)
	__v := NewImageRef(unsafe.Pointer(__ret))
	return __v
}

// KeepImageStoreKey function as declared in fitz/image.h:65
func KeepImageStoreKey(ctx []Context, image []Image) *Image {
	cctx, _ := unpackArgSContext(ctx)
	cimage, _ := unpackArgSImage(image)
	__ret := C.fz_keep_image_store_key(cctx, cimage)
	packSImage(image, cimage)
	packSContext(ctx, cctx)
	__v := NewImageRef(unsafe.Pointer(__ret))
	return __v
}

// DropImageStoreKey function as declared in fitz/image.h:66
func DropImageStoreKey(ctx []Context, image []Image) {
	cctx, _ := unpackArgSContext(ctx)
	cimage, _ := unpackArgSImage(image)
	C.fz_drop_image_store_key(cctx, cimage)
	packSImage(image, cimage)
	packSContext(ctx, cctx)
}

// NewImageOfSize function as declared in fitz/image.h:152
func NewImageOfSize(ctx []Context, w int32, h int32, bpc int32, colorspace []Colorspace, xres int32, yres int32, interpolate int32, imagemask int32, decode []float32, colorkey []int32, mask []Image, size int32, getPixmap ImageGetPixmapFn, getSize ImageGetSizeFn, drop DropImageFn) *Image {
	cctx, _ := unpackArgSContext(ctx)
	cw, _ := (C.int)(w), cgoAllocsUnknown
	ch, _ := (C.int)(h), cgoAllocsUnknown
	cbpc, _ := (C.int)(bpc), cgoAllocsUnknown
	ccolorspace, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&colorspace)).Data)), cgoAllocsUnknown
	cxres, _ := (C.int)(xres), cgoAllocsUnknown
	cyres, _ := (C.int)(yres), cgoAllocsUnknown
	cinterpolate, _ := (C.int)(interpolate), cgoAllocsUnknown
	cimagemask, _ := (C.int)(imagemask), cgoAllocsUnknown
	cdecode, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&decode)).Data)), cgoAllocsUnknown
	ccolorkey, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&colorkey)).Data)), cgoAllocsUnknown
	cmask, _ := unpackArgSImage(mask)
	csize, _ := (C.int)(size), cgoAllocsUnknown
	cgetPixmap, _ := getPixmap.PassRef()
	cgetSize, _ := getSize.PassRef()
	cdrop, _ := drop.PassRef()
	__ret := C.fz_new_image_of_size(cctx, cw, ch, cbpc, ccolorspace, cxres, cyres, cinterpolate, cimagemask, cdecode, ccolorkey, cmask, csize, cgetPixmap, cgetSize, cdrop)
	packSImage(mask, cmask)
	packSContext(ctx, cctx)
	__v := NewImageRef(unsafe.Pointer(__ret))
	return __v
}

// NewImageFromCompressedBuffer function as declared in fitz/image.h:205
func NewImageFromCompressedBuffer(ctx []Context, w int32, h int32, bpc int32, colorspace []Colorspace, xres int32, yres int32, interpolate int32, imagemask int32, decode []float32, colorkey []int32, buffer []CompressedBuffer, mask []Image) *Image {
	cctx, _ := unpackArgSContext(ctx)
	cw, _ := (C.int)(w), cgoAllocsUnknown
	ch, _ := (C.int)(h), cgoAllocsUnknown
	cbpc, _ := (C.int)(bpc), cgoAllocsUnknown
	ccolorspace, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&colorspace)).Data)), cgoAllocsUnknown
	cxres, _ := (C.int)(xres), cgoAllocsUnknown
	cyres, _ := (C.int)(yres), cgoAllocsUnknown
	cinterpolate, _ := (C.int)(interpolate), cgoAllocsUnknown
	cimagemask, _ := (C.int)(imagemask), cgoAllocsUnknown
	cdecode, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&decode)).Data)), cgoAllocsUnknown
	ccolorkey, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&colorkey)).Data)), cgoAllocsUnknown
	cbuffer, _ := unpackArgSCompressedBuffer(buffer)
	cmask, _ := unpackArgSImage(mask)
	__ret := C.fz_new_image_from_compressed_buffer(cctx, cw, ch, cbpc, ccolorspace, cxres, cyres, cinterpolate, cimagemask, cdecode, ccolorkey, cbuffer, cmask)
	packSImage(mask, cmask)
	packSCompressedBuffer(buffer, cbuffer)
	packSContext(ctx, cctx)
	__v := NewImageRef(unsafe.Pointer(__ret))
	return __v
}

// NewImageFromPixmap function as declared in fitz/image.h:218
func NewImageFromPixmap(ctx []Context, pixmap []Pixmap, mask []Image) *Image {
	cctx, _ := unpackArgSContext(ctx)
	cpixmap, _ := unpackArgSPixmap(pixmap)
	cmask, _ := unpackArgSImage(mask)
	__ret := C.fz_new_image_from_pixmap(cctx, cpixmap, cmask)
	packSImage(mask, cmask)
	packSPixmap(pixmap, cpixmap)
	packSContext(ctx, cctx)
	__v := NewImageRef(unsafe.Pointer(__ret))
	return __v
}

// NewImageFromBuffer function as declared in fitz/image.h:225
func NewImageFromBuffer(ctx []Context, buffer []Buffer) *Image {
	cctx, _ := unpackArgSContext(ctx)
	cbuffer, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buffer)).Data)), cgoAllocsUnknown
	__ret := C.fz_new_image_from_buffer(cctx, cbuffer)
	packSContext(ctx, cctx)
	__v := NewImageRef(unsafe.Pointer(__ret))
	return __v
}

// NewImageFromFile function as declared in fitz/image.h:232
func NewImageFromFile(ctx []Context, path string) *Image {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := unpackPCharString(path)
	__ret := C.fz_new_image_from_file(cctx, cpath)
	packSContext(ctx, cctx)
	__v := NewImageRef(unsafe.Pointer(__ret))
	return __v
}

// DropImageImp function as declared in fitz/image.h:234
func DropImageImp(ctx []Context, image []Storable) {
	cctx, _ := unpackArgSContext(ctx)
	cimage, _ := unpackArgSStorable(image)
	C.fz_drop_image_imp(cctx, cimage)
	packSStorable(image, cimage)
	packSContext(ctx, cctx)
}

// DropImageBase function as declared in fitz/image.h:235
func DropImageBase(ctx []Context, image []Image) {
	cctx, _ := unpackArgSContext(ctx)
	cimage, _ := unpackArgSImage(image)
	C.fz_drop_image_base(cctx, cimage)
	packSImage(image, cimage)
	packSContext(ctx, cctx)
}

// DecompImageFromStream function as declared in fitz/image.h:236
func DecompImageFromStream(ctx []Context, stm []Stream, image []CompressedImage, subarea []Irect, indexed int32, l2factor int32) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	cstm, _ := unpackArgSStream(stm)
	cimage, _ := (*C.fz_compressed_image)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&image)).Data)), cgoAllocsUnknown
	csubarea, _ := unpackArgSIrect(subarea)
	cindexed, _ := (C.int)(indexed), cgoAllocsUnknown
	cl2factor, _ := (C.int)(l2factor), cgoAllocsUnknown
	__ret := C.fz_decomp_image_from_stream(cctx, cstm, cimage, csubarea, cindexed, cl2factor)
	packSIrect(subarea, csubarea)
	packSStream(stm, cstm)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// IndexedColorspacePalette function as declared in fitz/image.h:237
func IndexedColorspacePalette(ctx []Context, cs []Colorspace, high []int32) *byte {
	cctx, _ := unpackArgSContext(ctx)
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	chigh, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&high)).Data)), cgoAllocsUnknown
	__ret := C.fz_indexed_colorspace_palette(cctx, ccs, chigh)
	packSContext(ctx, cctx)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// ExpandIndexedPixmap function as declared in fitz/image.h:238
func ExpandIndexedPixmap(ctx []Context, src []Pixmap, alpha int32) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	csrc, _ := unpackArgSPixmap(src)
	calpha, _ := (C.int)(alpha), cgoAllocsUnknown
	__ret := C.fz_expand_indexed_pixmap(cctx, csrc, calpha)
	packSPixmap(src, csrc)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// ImageSize function as declared in fitz/image.h:239
func ImageSize(ctx []Context, im []Image) uint {
	cctx, _ := unpackArgSContext(ctx)
	cim, _ := unpackArgSImage(im)
	__ret := C.fz_image_size(cctx, cim)
	packSImage(im, cim)
	packSContext(ctx, cctx)
	__v := (uint)(__ret)
	return __v
}

// LoadJpeg function as declared in fitz/image.h:269
func LoadJpeg(ctx []Context, data []byte, size uint) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	cdata, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	__ret := C.fz_load_jpeg(cctx, cdata, csize)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// LoadJpx function as declared in fitz/image.h:270
func LoadJpx(ctx []Context, data []byte, size uint, cs []Colorspace) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	cdata, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	__ret := C.fz_load_jpx(cctx, cdata, csize, ccs)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// LoadPng function as declared in fitz/image.h:271
func LoadPng(ctx []Context, data []byte, size uint) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	cdata, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	__ret := C.fz_load_png(cctx, cdata, csize)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// LoadTiff function as declared in fitz/image.h:272
func LoadTiff(ctx []Context, data []byte, size uint) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	cdata, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	__ret := C.fz_load_tiff(cctx, cdata, csize)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// LoadJxr function as declared in fitz/image.h:273
func LoadJxr(ctx []Context, data []byte, size uint) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	cdata, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	__ret := C.fz_load_jxr(cctx, cdata, csize)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// LoadGif function as declared in fitz/image.h:274
func LoadGif(ctx []Context, data []byte, size uint) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	cdata, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	__ret := C.fz_load_gif(cctx, cdata, csize)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// LoadBmp function as declared in fitz/image.h:275
func LoadBmp(ctx []Context, data []byte, size uint) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	cdata, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	__ret := C.fz_load_bmp(cctx, cdata, csize)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// LoadPnm function as declared in fitz/image.h:276
func LoadPnm(ctx []Context, data []byte, size uint) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	cdata, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	__ret := C.fz_load_pnm(cctx, cdata, csize)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// LoadJpegInfo function as declared in fitz/image.h:278
func LoadJpegInfo(ctx []Context, data []byte, size uint, w []int32, h []int32, xres []int32, yres []int32, cspace [][]Colorspace) {
	cctx, _ := unpackArgSContext(ctx)
	cdata, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	cw, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&w)).Data)), cgoAllocsUnknown
	ch, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&h)).Data)), cgoAllocsUnknown
	cxres, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&xres)).Data)), cgoAllocsUnknown
	cyres, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&yres)).Data)), cgoAllocsUnknown
	ccspace, _ := unpackArgSSColorspace(cspace)
	C.fz_load_jpeg_info(cctx, cdata, csize, cw, ch, cxres, cyres, ccspace)
	packSSColorspace(cspace, ccspace)
	packSContext(ctx, cctx)
}

// LoadJpxInfo function as declared in fitz/image.h:279
func LoadJpxInfo(ctx []Context, data []byte, size uint, w []int32, h []int32, xres []int32, yres []int32, cspace [][]Colorspace) {
	cctx, _ := unpackArgSContext(ctx)
	cdata, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	cw, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&w)).Data)), cgoAllocsUnknown
	ch, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&h)).Data)), cgoAllocsUnknown
	cxres, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&xres)).Data)), cgoAllocsUnknown
	cyres, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&yres)).Data)), cgoAllocsUnknown
	ccspace, _ := unpackArgSSColorspace(cspace)
	C.fz_load_jpx_info(cctx, cdata, csize, cw, ch, cxres, cyres, ccspace)
	packSSColorspace(cspace, ccspace)
	packSContext(ctx, cctx)
}

// LoadPngInfo function as declared in fitz/image.h:280
func LoadPngInfo(ctx []Context, data []byte, size uint, w []int32, h []int32, xres []int32, yres []int32, cspace [][]Colorspace) {
	cctx, _ := unpackArgSContext(ctx)
	cdata, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	cw, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&w)).Data)), cgoAllocsUnknown
	ch, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&h)).Data)), cgoAllocsUnknown
	cxres, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&xres)).Data)), cgoAllocsUnknown
	cyres, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&yres)).Data)), cgoAllocsUnknown
	ccspace, _ := unpackArgSSColorspace(cspace)
	C.fz_load_png_info(cctx, cdata, csize, cw, ch, cxres, cyres, ccspace)
	packSSColorspace(cspace, ccspace)
	packSContext(ctx, cctx)
}

// LoadTiffInfo function as declared in fitz/image.h:281
func LoadTiffInfo(ctx []Context, data []byte, size uint, w []int32, h []int32, xres []int32, yres []int32, cspace [][]Colorspace) {
	cctx, _ := unpackArgSContext(ctx)
	cdata, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	cw, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&w)).Data)), cgoAllocsUnknown
	ch, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&h)).Data)), cgoAllocsUnknown
	cxres, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&xres)).Data)), cgoAllocsUnknown
	cyres, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&yres)).Data)), cgoAllocsUnknown
	ccspace, _ := unpackArgSSColorspace(cspace)
	C.fz_load_tiff_info(cctx, cdata, csize, cw, ch, cxres, cyres, ccspace)
	packSSColorspace(cspace, ccspace)
	packSContext(ctx, cctx)
}

// LoadJxrInfo function as declared in fitz/image.h:282
func LoadJxrInfo(ctx []Context, data []byte, size uint, w []int32, h []int32, xres []int32, yres []int32, cspace [][]Colorspace) {
	cctx, _ := unpackArgSContext(ctx)
	cdata, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	cw, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&w)).Data)), cgoAllocsUnknown
	ch, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&h)).Data)), cgoAllocsUnknown
	cxres, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&xres)).Data)), cgoAllocsUnknown
	cyres, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&yres)).Data)), cgoAllocsUnknown
	ccspace, _ := unpackArgSSColorspace(cspace)
	C.fz_load_jxr_info(cctx, cdata, csize, cw, ch, cxres, cyres, ccspace)
	packSSColorspace(cspace, ccspace)
	packSContext(ctx, cctx)
}

// LoadGifInfo function as declared in fitz/image.h:283
func LoadGifInfo(ctx []Context, data []byte, size uint, w []int32, h []int32, xres []int32, yres []int32, cspace [][]Colorspace) {
	cctx, _ := unpackArgSContext(ctx)
	cdata, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	cw, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&w)).Data)), cgoAllocsUnknown
	ch, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&h)).Data)), cgoAllocsUnknown
	cxres, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&xres)).Data)), cgoAllocsUnknown
	cyres, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&yres)).Data)), cgoAllocsUnknown
	ccspace, _ := unpackArgSSColorspace(cspace)
	C.fz_load_gif_info(cctx, cdata, csize, cw, ch, cxres, cyres, ccspace)
	packSSColorspace(cspace, ccspace)
	packSContext(ctx, cctx)
}

// LoadBmpInfo function as declared in fitz/image.h:284
func LoadBmpInfo(ctx []Context, data []byte, size uint, w []int32, h []int32, xres []int32, yres []int32, cspace [][]Colorspace) {
	cctx, _ := unpackArgSContext(ctx)
	cdata, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	cw, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&w)).Data)), cgoAllocsUnknown
	ch, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&h)).Data)), cgoAllocsUnknown
	cxres, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&xres)).Data)), cgoAllocsUnknown
	cyres, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&yres)).Data)), cgoAllocsUnknown
	ccspace, _ := unpackArgSSColorspace(cspace)
	C.fz_load_bmp_info(cctx, cdata, csize, cw, ch, cxres, cyres, ccspace)
	packSSColorspace(cspace, ccspace)
	packSContext(ctx, cctx)
}

// LoadPnmInfo function as declared in fitz/image.h:285
func LoadPnmInfo(ctx []Context, data []byte, size uint, w []int32, h []int32, xres []int32, yres []int32, cspace [][]Colorspace) {
	cctx, _ := unpackArgSContext(ctx)
	cdata, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	cw, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&w)).Data)), cgoAllocsUnknown
	ch, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&h)).Data)), cgoAllocsUnknown
	cxres, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&xres)).Data)), cgoAllocsUnknown
	cyres, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&yres)).Data)), cgoAllocsUnknown
	ccspace, _ := unpackArgSSColorspace(cspace)
	C.fz_load_pnm_info(cctx, cdata, csize, cw, ch, cxres, cyres, ccspace)
	packSSColorspace(cspace, ccspace)
	packSContext(ctx, cctx)
}

// LoadTiffSubimageCount function as declared in fitz/image.h:287
func LoadTiffSubimageCount(ctx []Context, buf []byte, len uint) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	clen, _ := (C.size_t)(len), cgoAllocsUnknown
	__ret := C.fz_load_tiff_subimage_count(cctx, cbuf, clen)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// LoadTiffSubimage function as declared in fitz/image.h:288
func LoadTiffSubimage(ctx []Context, buf []byte, len uint, subimage int32) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	clen, _ := (C.size_t)(len), cgoAllocsUnknown
	csubimage, _ := (C.int)(subimage), cgoAllocsUnknown
	__ret := C.fz_load_tiff_subimage(cctx, cbuf, clen, csubimage)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// ImageResolution function as declared in fitz/image.h:298
func ImageResolution(image []Image, xres []int32, yres []int32) {
	cimage, _ := unpackArgSImage(image)
	cxres, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&xres)).Data)), cgoAllocsUnknown
	cyres, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&yres)).Data)), cgoAllocsUnknown
	C.fz_image_resolution(cimage, cxres, cyres)
	packSImage(image, cimage)
}

// CompressedImageTile function as declared in fitz/image.h:300
func CompressedImageTile(ctx []Context, cimg []CompressedImage) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	ccimg, _ := (*C.fz_compressed_image)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cimg)).Data)), cgoAllocsUnknown
	__ret := C.fz_compressed_image_tile(cctx, ccimg)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// SetCompressedImageTile function as declared in fitz/image.h:301
func SetCompressedImageTile(ctx []Context, cimg []CompressedImage, pix []Pixmap) {
	cctx, _ := unpackArgSContext(ctx)
	ccimg, _ := (*C.fz_compressed_image)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cimg)).Data)), cgoAllocsUnknown
	cpix, _ := unpackArgSPixmap(pix)
	C.fz_set_compressed_image_tile(cctx, ccimg, cpix)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
}

// CompressedImageBuffer function as declared in fitz/image.h:314
func CompressedImageBuffer(ctx []Context, image []Image) *CompressedBuffer {
	cctx, _ := unpackArgSContext(ctx)
	cimage, _ := unpackArgSImage(image)
	__ret := C.fz_compressed_image_buffer(cctx, cimage)
	packSImage(image, cimage)
	packSContext(ctx, cctx)
	__v := NewCompressedBufferRef(unsafe.Pointer(__ret))
	return __v
}

// SetCompressedImageBuffer function as declared in fitz/image.h:315
func SetCompressedImageBuffer(ctx []Context, cimg []CompressedImage, buf []CompressedBuffer) {
	cctx, _ := unpackArgSContext(ctx)
	ccimg, _ := (*C.fz_compressed_image)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cimg)).Data)), cgoAllocsUnknown
	cbuf, _ := unpackArgSCompressedBuffer(buf)
	C.fz_set_compressed_image_buffer(cctx, ccimg, cbuf)
	packSCompressedBuffer(buf, cbuf)
	packSContext(ctx, cctx)
}

// PixmapImageTile function as declared in fitz/image.h:328
func PixmapImageTile(ctx []Context, cimg []PixmapImage) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	ccimg, _ := (*C.fz_pixmap_image)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cimg)).Data)), cgoAllocsUnknown
	__ret := C.fz_pixmap_image_tile(cctx, ccimg)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// SetPixmapImageTile function as declared in fitz/image.h:329
func SetPixmapImageTile(ctx []Context, cimg []PixmapImage, pix []Pixmap) {
	cctx, _ := unpackArgSContext(ctx)
	ccimg, _ := (*C.fz_pixmap_image)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cimg)).Data)), cgoAllocsUnknown
	cpix, _ := unpackArgSPixmap(pix)
	C.fz_set_pixmap_image_tile(cctx, ccimg, cpix)
	packSPixmap(pix, cpix)
	packSContext(ctx, cctx)
}

// KeepShade function as declared in fitz/shade.h:89
func KeepShade(ctx []Context, shade []Shade) *Shade {
	cctx, _ := unpackArgSContext(ctx)
	cshade, _ := unpackArgSShade(shade)
	__ret := C.fz_keep_shade(cctx, cshade)
	packSShade(shade, cshade)
	packSContext(ctx, cctx)
	__v := NewShadeRef(unsafe.Pointer(__ret))
	return __v
}

// DropShade function as declared in fitz/shade.h:97
func DropShade(ctx []Context, shade []Shade) {
	cctx, _ := unpackArgSContext(ctx)
	cshade, _ := unpackArgSShade(shade)
	C.fz_drop_shade(cctx, cshade)
	packSShade(shade, cshade)
	packSContext(ctx, cctx)
}

// DropShadeImp function as declared in fitz/shade.h:105
func DropShadeImp(ctx []Context, shade []Storable) {
	cctx, _ := unpackArgSContext(ctx)
	cshade, _ := unpackArgSStorable(shade)
	C.fz_drop_shade_imp(cctx, cshade)
	packSStorable(shade, cshade)
	packSContext(ctx, cctx)
}

// BoundShade function as declared in fitz/shade.h:118
func BoundShade(ctx []Context, shade []Shade, ctm []Matrix, r []Rect) *Rect {
	cctx, _ := unpackArgSContext(ctx)
	cshade, _ := unpackArgSShade(shade)
	cctm, _ := unpackArgSMatrix(ctm)
	cr, _ := unpackArgSRect(r)
	__ret := C.fz_bound_shade(cctx, cshade, cctm, cr)
	packSRect(r, cr)
	packSMatrix(ctm, cctm)
	packSShade(shade, cshade)
	packSContext(ctx, cctx)
	__v := NewRectRef(unsafe.Pointer(__ret))
	return __v
}

// PaintShade function as declared in fitz/shade.h:136
func PaintShade(ctx []Context, shade []Shade, ctm []Matrix, dest []Pixmap, prf []Colorspace, colorParams []ColorParams, bbox []Irect) {
	cctx, _ := unpackArgSContext(ctx)
	cshade, _ := unpackArgSShade(shade)
	cctm, _ := unpackArgSMatrix(ctm)
	cdest, _ := unpackArgSPixmap(dest)
	cprf, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&prf)).Data)), cgoAllocsUnknown
	ccolorParams, _ := unpackArgSColorParams(colorParams)
	cbbox, _ := unpackArgSIrect(bbox)
	C.fz_paint_shade(cctx, cshade, cctm, cdest, cprf, ccolorParams, cbbox)
	packSIrect(bbox, cbbox)
	packSColorParams(colorParams, ccolorParams)
	packSPixmap(dest, cdest)
	packSMatrix(ctm, cctm)
	packSShade(shade, cshade)
	packSContext(ctx, cctx)
}

// ProcessShade function as declared in fitz/shade.h:194
func ProcessShade(ctx []Context, shade []Shade, ctm []Matrix, prepare ShadePrepareFn, process ShadeProcessFn, processArg unsafe.Pointer) {
	cctx, _ := unpackArgSContext(ctx)
	cshade, _ := unpackArgSShade(shade)
	cctm, _ := unpackArgSMatrix(ctm)
	cprepare, _ := prepare.PassRef()
	cprocess, _ := process.PassRef()
	cprocessArg, _ := processArg, cgoAllocsUnknown
	C.fz_process_shade(cctx, cshade, cctm, cprepare, cprocess, cprocessArg)
	packSMatrix(ctm, cctm)
	packSShade(shade, cshade)
	packSContext(ctx, cctx)
}

// FontFtFace function as declared in fitz/font.h:33
func FontFtFace(ctx []Context, font []Font) unsafe.Pointer {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	__ret := C.fz_font_ft_face(cctx, cfont)
	packSContext(ctx, cctx)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// FontT3Procs function as declared in fitz/font.h:44
func FontT3Procs(ctx []Context, font []Font) []*Buffer {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	__ret := C.fz_font_t3_procs(cctx, cfont)
	packSContext(ctx, cctx)
	__v := (*(*[0x7fffffff]*Buffer)(unsafe.Pointer(__ret)))[:0]
	return __v
}

// FontFlags function as declared in fitz/font.h:89
func FontFlags(font []Font) *FontFlags {
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	__ret := C.fz_font_flags(cfont)
	__v := NewFontFlagsRef(unsafe.Pointer(__ret))
	return __v
}

// FontShaperData function as declared in fitz/font.h:115
func FontShaperData(ctx []Context, font []Font) *ShaperData {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	__ret := C.fz_font_shaper_data(cctx, cfont)
	packSContext(ctx, cctx)
	__v := NewShaperDataRef(unsafe.Pointer(__ret))
	return __v
}

// FontName function as declared in fitz/font.h:125
func FontName(ctx []Context, font []Font) string {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	__ret := C.fz_font_name(cctx, cfont)
	packSContext(ctx, cctx)
	__v := packPCharString(__ret)
	return __v
}

// FontIsBold function as declared in fitz/font.h:130
func FontIsBold(ctx []Context, font []Font) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	__ret := C.fz_font_is_bold(cctx, cfont)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// FontIsItalic function as declared in fitz/font.h:135
func FontIsItalic(ctx []Context, font []Font) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	__ret := C.fz_font_is_italic(cctx, cfont)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// FontIsSerif function as declared in fitz/font.h:140
func FontIsSerif(ctx []Context, font []Font) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	__ret := C.fz_font_is_serif(cctx, cfont)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// FontIsMonospaced function as declared in fitz/font.h:145
func FontIsMonospaced(ctx []Context, font []Font) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	__ret := C.fz_font_is_monospaced(cctx, cfont)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// FontBbox function as declared in fitz/font.h:155
func FontBbox(ctx []Context, font []Font) *Rect {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	__ret := C.fz_font_bbox(cctx, cfont)
	packSContext(ctx, cctx)
	__v := NewRectRef(unsafe.Pointer(__ret))
	return __v
}

// InstallLoadSystemFontFuncs function as declared in fitz/font.h:198
func InstallLoadSystemFontFuncs(ctx []Context, f LoadSystemFontFn, fCjk LoadSystemCjkFontFn, fFallback LoadSystemFallbackFontFn) {
	cctx, _ := unpackArgSContext(ctx)
	cf, _ := f.PassRef()
	cfCjk, _ := fCjk.PassRef()
	cfFallback, _ := fFallback.PassRef()
	C.fz_install_load_system_font_funcs(cctx, cf, cfCjk, cfFallback)
	packSContext(ctx, cctx)
}

// LoadSystemFont function as declared in fitz/font.h:220
func LoadSystemFont(ctx []Context, name string, bold int32, italic int32, needsExactMetrics int32) *Font {
	cctx, _ := unpackArgSContext(ctx)
	cname, _ := unpackPCharString(name)
	cbold, _ := (C.int)(bold), cgoAllocsUnknown
	citalic, _ := (C.int)(italic), cgoAllocsUnknown
	cneedsExactMetrics, _ := (C.int)(needsExactMetrics), cgoAllocsUnknown
	__ret := C.fz_load_system_font(cctx, cname, cbold, citalic, cneedsExactMetrics)
	packSContext(ctx, cctx)
	__v := *(**Font)(unsafe.Pointer(&__ret))
	return __v
}

// LoadSystemCjkFont function as declared in fitz/font.h:235
func LoadSystemCjkFont(ctx []Context, name string, ros int32, serif int32) *Font {
	cctx, _ := unpackArgSContext(ctx)
	cname, _ := unpackPCharString(name)
	cros, _ := (C.int)(ros), cgoAllocsUnknown
	cserif, _ := (C.int)(serif), cgoAllocsUnknown
	__ret := C.fz_load_system_cjk_font(cctx, cname, cros, cserif)
	packSContext(ctx, cctx)
	__v := *(**Font)(unsafe.Pointer(&__ret))
	return __v
}

// LookupBuiltinFont function as declared in fitz/font.h:253
func LookupBuiltinFont(ctx []Context, name string, bold int32, italic int32, len []int32) string {
	cctx, _ := unpackArgSContext(ctx)
	cname, _ := unpackPCharString(name)
	cbold, _ := (C.int)(bold), cgoAllocsUnknown
	citalic, _ := (C.int)(italic), cgoAllocsUnknown
	clen, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&len)).Data)), cgoAllocsUnknown
	__ret := C.fz_lookup_builtin_font(cctx, cname, cbold, citalic, clen)
	packSContext(ctx, cctx)
	__v := packPUcharString(__ret)
	return __v
}

// LookupBase14Font function as declared in fitz/font.h:267
func LookupBase14Font(ctx []Context, name string, len []int32) string {
	cctx, _ := unpackArgSContext(ctx)
	cname, _ := unpackPCharString(name)
	clen, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&len)).Data)), cgoAllocsUnknown
	__ret := C.fz_lookup_base14_font(cctx, cname, clen)
	packSContext(ctx, cctx)
	__v := packPUcharString(__ret)
	return __v
}

// LookupIcc function as declared in fitz/font.h:279
func LookupIcc(ctx []Context, name string, len []uint) string {
	cctx, _ := unpackArgSContext(ctx)
	cname, _ := unpackPCharString(name)
	clen, _ := (*C.size_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&len)).Data)), cgoAllocsUnknown
	__ret := C.fz_lookup_icc(cctx, cname, clen)
	packSContext(ctx, cctx)
	__v := packPUcharString(__ret)
	return __v
}

// LookupCjkFont function as declared in fitz/font.h:301
func LookupCjkFont(ctx []Context, registry int32, serif int32, wmode int32, len []int32, index []int32) string {
	cctx, _ := unpackArgSContext(ctx)
	cregistry, _ := (C.int)(registry), cgoAllocsUnknown
	cserif, _ := (C.int)(serif), cgoAllocsUnknown
	cwmode, _ := (C.int)(wmode), cgoAllocsUnknown
	clen, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&len)).Data)), cgoAllocsUnknown
	cindex, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&index)).Data)), cgoAllocsUnknown
	__ret := C.fz_lookup_cjk_font(cctx, cregistry, cserif, cwmode, clen, cindex)
	packSContext(ctx, cctx)
	__v := packPUcharString(__ret)
	return __v
}

// LookupNotoFont function as declared in fitz/font.h:319
func LookupNotoFont(ctx []Context, script int32, lang int32, serif int32, len []int32) string {
	cctx, _ := unpackArgSContext(ctx)
	cscript, _ := (C.int)(script), cgoAllocsUnknown
	clang, _ := (C.int)(lang), cgoAllocsUnknown
	cserif, _ := (C.int)(serif), cgoAllocsUnknown
	clen, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&len)).Data)), cgoAllocsUnknown
	__ret := C.fz_lookup_noto_font(cctx, cscript, clang, cserif, clen)
	packSContext(ctx, cctx)
	__v := packPUcharString(__ret)
	return __v
}

// LookupNotoSymbolFont function as declared in fitz/font.h:331
func LookupNotoSymbolFont(ctx []Context, len []int32) string {
	cctx, _ := unpackArgSContext(ctx)
	clen, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&len)).Data)), cgoAllocsUnknown
	__ret := C.fz_lookup_noto_symbol_font(cctx, clen)
	packSContext(ctx, cctx)
	__v := packPUcharString(__ret)
	return __v
}

// LookupNotoEmojiFont function as declared in fitz/font.h:343
func LookupNotoEmojiFont(ctx []Context, len []int32) string {
	cctx, _ := unpackArgSContext(ctx)
	clen, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&len)).Data)), cgoAllocsUnknown
	__ret := C.fz_lookup_noto_emoji_font(cctx, clen)
	packSContext(ctx, cctx)
	__v := packPUcharString(__ret)
	return __v
}

// LoadFallbackFont function as declared in fitz/font.h:363
func LoadFallbackFont(ctx []Context, script int32, language int32, serif int32, bold int32, italic int32) *Font {
	cctx, _ := unpackArgSContext(ctx)
	cscript, _ := (C.int)(script), cgoAllocsUnknown
	clanguage, _ := (C.int)(language), cgoAllocsUnknown
	cserif, _ := (C.int)(serif), cgoAllocsUnknown
	cbold, _ := (C.int)(bold), cgoAllocsUnknown
	citalic, _ := (C.int)(italic), cgoAllocsUnknown
	__ret := C.fz_load_fallback_font(cctx, cscript, clanguage, cserif, cbold, citalic)
	packSContext(ctx, cctx)
	__v := *(**Font)(unsafe.Pointer(&__ret))
	return __v
}

// LoadFallbackSymbolFont function as declared in fitz/font.h:372
func LoadFallbackSymbolFont(ctx []Context) *Font {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_load_fallback_symbol_font(cctx)
	packSContext(ctx, cctx)
	__v := *(**Font)(unsafe.Pointer(&__ret))
	return __v
}

// LoadFallbackEmojiFont function as declared in fitz/font.h:381
func LoadFallbackEmojiFont(ctx []Context) *Font {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_load_fallback_emoji_font(cctx)
	packSContext(ctx, cctx)
	__v := *(**Font)(unsafe.Pointer(&__ret))
	return __v
}

// NewType3Font function as declared in fitz/font.h:393
func NewType3Font(ctx []Context, name string, matrix []Matrix) *Font {
	cctx, _ := unpackArgSContext(ctx)
	cname, _ := unpackPCharString(name)
	cmatrix, _ := unpackArgSMatrix(matrix)
	__ret := C.fz_new_type3_font(cctx, cname, cmatrix)
	packSMatrix(matrix, cmatrix)
	packSContext(ctx, cctx)
	__v := *(**Font)(unsafe.Pointer(&__ret))
	return __v
}

// NewFontFromMemory function as declared in fitz/font.h:411
func NewFontFromMemory(ctx []Context, name string, data string, len int32, index int32, useGlyphBbox int32) *Font {
	cctx, _ := unpackArgSContext(ctx)
	cname, _ := unpackPCharString(name)
	cdata, _ := unpackPUcharString(data)
	clen, _ := (C.int)(len), cgoAllocsUnknown
	cindex, _ := (C.int)(index), cgoAllocsUnknown
	cuseGlyphBbox, _ := (C.int)(useGlyphBbox), cgoAllocsUnknown
	__ret := C.fz_new_font_from_memory(cctx, cname, cdata, clen, cindex, cuseGlyphBbox)
	packSContext(ctx, cctx)
	__v := *(**Font)(unsafe.Pointer(&__ret))
	return __v
}

// NewFontFromBuffer function as declared in fitz/font.h:427
func NewFontFromBuffer(ctx []Context, name string, buffer []Buffer, index int32, useGlyphBbox int32) *Font {
	cctx, _ := unpackArgSContext(ctx)
	cname, _ := unpackPCharString(name)
	cbuffer, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buffer)).Data)), cgoAllocsUnknown
	cindex, _ := (C.int)(index), cgoAllocsUnknown
	cuseGlyphBbox, _ := (C.int)(useGlyphBbox), cgoAllocsUnknown
	__ret := C.fz_new_font_from_buffer(cctx, cname, cbuffer, cindex, cuseGlyphBbox)
	packSContext(ctx, cctx)
	__v := *(**Font)(unsafe.Pointer(&__ret))
	return __v
}

// NewFontFromFile function as declared in fitz/font.h:443
func NewFontFromFile(ctx []Context, name string, path string, index int32, useGlyphBbox int32) *Font {
	cctx, _ := unpackArgSContext(ctx)
	cname, _ := unpackPCharString(name)
	cpath, _ := unpackPCharString(path)
	cindex, _ := (C.int)(index), cgoAllocsUnknown
	cuseGlyphBbox, _ := (C.int)(useGlyphBbox), cgoAllocsUnknown
	__ret := C.fz_new_font_from_file(cctx, cname, cpath, cindex, cuseGlyphBbox)
	packSContext(ctx, cctx)
	__v := *(**Font)(unsafe.Pointer(&__ret))
	return __v
}

// KeepFont function as declared in fitz/font.h:452
func KeepFont(ctx []Context, font []Font) *Font {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	__ret := C.fz_keep_font(cctx, cfont)
	packSContext(ctx, cctx)
	__v := *(**Font)(unsafe.Pointer(&__ret))
	return __v
}

// DropFont function as declared in fitz/font.h:460
func DropFont(ctx []Context, font []Font) {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	C.fz_drop_font(cctx, cfont)
	packSContext(ctx, cctx)
}

// SetFontBbox function as declared in fitz/font.h:469
func SetFontBbox(ctx []Context, font []Font, xmin float32, ymin float32, xmax float32, ymax float32) {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	cxmin, _ := (C.float)(xmin), cgoAllocsUnknown
	cymin, _ := (C.float)(ymin), cgoAllocsUnknown
	cxmax, _ := (C.float)(xmax), cgoAllocsUnknown
	cymax, _ := (C.float)(ymax), cgoAllocsUnknown
	C.fz_set_font_bbox(cctx, cfont, cxmin, cymin, cxmax, cymax)
	packSContext(ctx, cctx)
}

// BoundGlyph function as declared in fitz/font.h:484
func BoundGlyph(ctx []Context, font []Font, gid int32, trm []Matrix, r []Rect) *Rect {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	cgid, _ := (C.int)(gid), cgoAllocsUnknown
	ctrm, _ := unpackArgSMatrix(trm)
	cr, _ := unpackArgSRect(r)
	__ret := C.fz_bound_glyph(cctx, cfont, cgid, ctrm, cr)
	packSRect(r, cr)
	packSMatrix(trm, ctrm)
	packSContext(ctx, cctx)
	__v := NewRectRef(unsafe.Pointer(__ret))
	return __v
}

// GlyphCacheable function as declared in fitz/font.h:498
func GlyphCacheable(ctx []Context, font []Font, gid int32) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	cgid, _ := (C.int)(gid), cgoAllocsUnknown
	__ret := C.fz_glyph_cacheable(cctx, cfont, cgid)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// RunT3Glyph function as declared in fitz/font.h:512
func RunT3Glyph(ctx []Context, font []Font, gid int32, trm []Matrix, dev []DeviceS) {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	cgid, _ := (C.int)(gid), cgoAllocsUnknown
	ctrm, _ := unpackArgSMatrix(trm)
	cdev, _ := unpackArgSDeviceS(dev)
	C.fz_run_t3_glyph(cctx, cfont, cgid, ctrm, cdev)
	packSDeviceS(dev, cdev)
	packSMatrix(trm, ctrm)
	packSContext(ctx, cctx)
}

// DecoupleType3Font function as declared in fitz/font.h:530
func DecoupleType3Font(ctx []Context, font []Font, t3doc unsafe.Pointer) {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	ct3doc, _ := t3doc, cgoAllocsUnknown
	C.fz_decouple_type3_font(cctx, cfont, ct3doc)
	packSContext(ctx, cctx)
}

// AdvanceGlyph function as declared in fitz/font.h:543
func AdvanceGlyph(ctx []Context, font []Font, glyph int32, wmode int32) float32 {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	cglyph, _ := (C.int)(glyph), cgoAllocsUnknown
	cwmode, _ := (C.int)(wmode), cgoAllocsUnknown
	__ret := C.fz_advance_glyph(cctx, cfont, cglyph, cwmode)
	packSContext(ctx, cctx)
	__v := (float32)(__ret)
	return __v
}

// EncodeCharacter function as declared in fitz/font.h:556
func EncodeCharacter(ctx []Context, font []Font, unicode int32) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	cunicode, _ := (C.int)(unicode), cgoAllocsUnknown
	__ret := C.fz_encode_character(cctx, cfont, cunicode)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// EncodeCharacterWithFallback function as declared in fitz/font.h:583
func EncodeCharacterWithFallback(ctx []Context, font []Font, unicode int32, script int32, language int32, outFont [][]Font) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	cunicode, _ := (C.int)(unicode), cgoAllocsUnknown
	cscript, _ := (C.int)(script), cgoAllocsUnknown
	clanguage, _ := (C.int)(language), cgoAllocsUnknown
	coutFont, _ := unpackArgSSFont(outFont)
	__ret := C.fz_encode_character_with_fallback(cctx, cfont, cunicode, cscript, clanguage, coutFont)
	packSSFont(outFont, coutFont)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// GetGlyphName function as declared in fitz/font.h:601
func GetGlyphName(ctx []Context, font []Font, glyph int32, buf []byte, size int32) {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	cglyph, _ := (C.int)(glyph), cgoAllocsUnknown
	cbuf, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	csize, _ := (C.int)(size), cgoAllocsUnknown
	C.fz_get_glyph_name(cctx, cfont, cglyph, cbuf, csize)
	packSContext(ctx, cctx)
}

// FontAscender function as declared in fitz/font.h:606
func FontAscender(ctx []Context, font []Font) float32 {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	__ret := C.fz_font_ascender(cctx, cfont)
	packSContext(ctx, cctx)
	__v := (float32)(__ret)
	return __v
}

// FontDescender function as declared in fitz/font.h:607
func FontDescender(ctx []Context, font []Font) float32 {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	__ret := C.fz_font_descender(cctx, cfont)
	packSContext(ctx, cctx)
	__v := (float32)(__ret)
	return __v
}

// HbLock function as declared in fitz/font.h:619
func HbLock(ctx []Context) {
	cctx, _ := unpackArgSContext(ctx)
	C.fz_hb_lock(cctx)
	packSContext(ctx, cctx)
}

// HbUnlock function as declared in fitz/font.h:625
func HbUnlock(ctx []Context) {
	cctx, _ := unpackArgSContext(ctx)
	C.fz_hb_unlock(cctx)
	packSContext(ctx, cctx)
}

// WalkPath function as declared in fitz/path.h:80
func WalkPath(ctx []Context, path []Path, walker []PathWalker, arg unsafe.Pointer) {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := (*C.fz_path)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&path)).Data)), cgoAllocsUnknown
	cwalker, _ := unpackArgSPathWalker(walker)
	carg, _ := arg, cgoAllocsUnknown
	C.fz_walk_path(cctx, cpath, cwalker, carg)
	packSPathWalker(walker, cwalker)
	packSContext(ctx, cctx)
}

// NewPath function as declared in fitz/path.h:88
func NewPath(ctx []Context) *Path {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_new_path(cctx)
	packSContext(ctx, cctx)
	__v := *(**Path)(unsafe.Pointer(&__ret))
	return __v
}

// KeepPath function as declared in fitz/path.h:100
func KeepPath(ctx []Context, path []Path) *Path {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := (*C.fz_path)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&path)).Data)), cgoAllocsUnknown
	__ret := C.fz_keep_path(cctx, cpath)
	packSContext(ctx, cctx)
	__v := *(**Path)(unsafe.Pointer(&__ret))
	return __v
}

// DropPath function as declared in fitz/path.h:109
func DropPath(ctx []Context, path []Path) {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := (*C.fz_path)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&path)).Data)), cgoAllocsUnknown
	C.fz_drop_path(cctx, cpath)
	packSContext(ctx, cctx)
}

// TrimPath function as declared in fitz/path.h:123
func TrimPath(ctx []Context, path []Path) {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := (*C.fz_path)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&path)).Data)), cgoAllocsUnknown
	C.fz_trim_path(cctx, cpath)
	packSContext(ctx, cctx)
}

// PackedPathSize function as declared in fitz/path.h:131
func PackedPathSize(path []Path) int32 {
	cpath, _ := (*C.fz_path)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&path)).Data)), cgoAllocsUnknown
	__ret := C.fz_packed_path_size(cpath)
	__v := (int32)(__ret)
	return __v
}

// PackPath function as declared in fitz/path.h:173
func PackPath(ctx []Context, pack []byte, max int32, path []Path) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cpack, _ := (*C.uint8_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&pack)).Data)), cgoAllocsUnknown
	cmax, _ := (C.int)(max), cgoAllocsUnknown
	cpath, _ := (*C.fz_path)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&path)).Data)), cgoAllocsUnknown
	__ret := C.fz_pack_path(cctx, cpack, cmax, cpath)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ClonePath function as declared in fitz/path.h:187
func ClonePath(ctx []Context, path []Path) *Path {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := (*C.fz_path)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&path)).Data)), cgoAllocsUnknown
	__ret := C.fz_clone_path(cctx, cpath)
	packSContext(ctx, cctx)
	__v := *(**Path)(unsafe.Pointer(&__ret))
	return __v
}

// Currentpoint function as declared in fitz/path.h:195
func Currentpoint(ctx []Context, path []Path) Point {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := (*C.fz_path)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&path)).Data)), cgoAllocsUnknown
	__ret := C.fz_currentpoint(cctx, cpath)
	packSContext(ctx, cctx)
	__v := *NewPointRef(unsafe.Pointer(&__ret))
	return __v
}

// Moveto function as declared in fitz/path.h:207
func Moveto(ctx []Context, path []Path, x float32, y float32) {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := (*C.fz_path)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&path)).Data)), cgoAllocsUnknown
	cx, _ := (C.float)(x), cgoAllocsUnknown
	cy, _ := (C.float)(y), cgoAllocsUnknown
	C.fz_moveto(cctx, cpath, cx, cy)
	packSContext(ctx, cctx)
}

// Lineto function as declared in fitz/path.h:218
func Lineto(ctx []Context, path []Path, x float32, y float32) {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := (*C.fz_path)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&path)).Data)), cgoAllocsUnknown
	cx, _ := (C.float)(x), cgoAllocsUnknown
	cy, _ := (C.float)(y), cgoAllocsUnknown
	C.fz_lineto(cctx, cpath, cx, cy)
	packSContext(ctx, cctx)
}

// Rectto function as declared in fitz/path.h:238
func Rectto(ctx []Context, path []Path, x0 float32, y0 float32, x1 float32, y1 float32) {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := (*C.fz_path)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&path)).Data)), cgoAllocsUnknown
	cx0, _ := (C.float)(x0), cgoAllocsUnknown
	cy0, _ := (C.float)(y0), cgoAllocsUnknown
	cx1, _ := (C.float)(x1), cgoAllocsUnknown
	cy1, _ := (C.float)(y1), cgoAllocsUnknown
	C.fz_rectto(cctx, cpath, cx0, cy0, cx1, cy1)
	packSContext(ctx, cctx)
}

// Quadto function as declared in fitz/path.h:252
func Quadto(ctx []Context, path []Path, x0 float32, y0 float32, x1 float32, y1 float32) {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := (*C.fz_path)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&path)).Data)), cgoAllocsUnknown
	cx0, _ := (C.float)(x0), cgoAllocsUnknown
	cy0, _ := (C.float)(y0), cgoAllocsUnknown
	cx1, _ := (C.float)(x1), cgoAllocsUnknown
	cy1, _ := (C.float)(y1), cgoAllocsUnknown
	C.fz_quadto(cctx, cpath, cx0, cy0, cx1, cy1)
	packSContext(ctx, cctx)
}

// Curveto function as declared in fitz/path.h:270
func Curveto(ctx []Context, path []Path, x0 float32, y0 float32, x1 float32, y1 float32, x2 float32, y2 float32) {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := (*C.fz_path)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&path)).Data)), cgoAllocsUnknown
	cx0, _ := (C.float)(x0), cgoAllocsUnknown
	cy0, _ := (C.float)(y0), cgoAllocsUnknown
	cx1, _ := (C.float)(x1), cgoAllocsUnknown
	cy1, _ := (C.float)(y1), cgoAllocsUnknown
	cx2, _ := (C.float)(x2), cgoAllocsUnknown
	cy2, _ := (C.float)(y2), cgoAllocsUnknown
	C.fz_curveto(cctx, cpath, cx0, cy0, cx1, cy1, cx2, cy2)
	packSContext(ctx, cctx)
}

// Curvetov function as declared in fitz/path.h:286
func Curvetov(ctx []Context, path []Path, x1 float32, y1 float32, x2 float32, y2 float32) {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := (*C.fz_path)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&path)).Data)), cgoAllocsUnknown
	cx1, _ := (C.float)(x1), cgoAllocsUnknown
	cy1, _ := (C.float)(y1), cgoAllocsUnknown
	cx2, _ := (C.float)(x2), cgoAllocsUnknown
	cy2, _ := (C.float)(y2), cgoAllocsUnknown
	C.fz_curvetov(cctx, cpath, cx1, cy1, cx2, cy2)
	packSContext(ctx, cctx)
}

// Curvetoy function as declared in fitz/path.h:303
func Curvetoy(ctx []Context, path []Path, x0 float32, y0 float32, x2 float32, y2 float32) {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := (*C.fz_path)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&path)).Data)), cgoAllocsUnknown
	cx0, _ := (C.float)(x0), cgoAllocsUnknown
	cy0, _ := (C.float)(y0), cgoAllocsUnknown
	cx2, _ := (C.float)(x2), cgoAllocsUnknown
	cy2, _ := (C.float)(y2), cgoAllocsUnknown
	C.fz_curvetoy(cctx, cpath, cx0, cy0, cx2, cy2)
	packSContext(ctx, cctx)
}

// Closepath function as declared in fitz/path.h:313
func Closepath(ctx []Context, path []Path) {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := (*C.fz_path)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&path)).Data)), cgoAllocsUnknown
	C.fz_closepath(cctx, cpath)
	packSContext(ctx, cctx)
}

// TransformPath function as declared in fitz/path.h:326
func TransformPath(ctx []Context, path []Path, transform []Matrix) {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := (*C.fz_path)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&path)).Data)), cgoAllocsUnknown
	ctransform, _ := unpackArgSMatrix(transform)
	C.fz_transform_path(cctx, cpath, ctransform)
	packSMatrix(transform, ctransform)
	packSContext(ctx, cctx)
}

// BoundPath function as declared in fitz/path.h:344
func BoundPath(ctx []Context, path []Path, stroke []StrokeState, ctm []Matrix, r []Rect) *Rect {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := (*C.fz_path)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&path)).Data)), cgoAllocsUnknown
	cstroke, _ := unpackArgSStrokeState(stroke)
	cctm, _ := unpackArgSMatrix(ctm)
	cr, _ := unpackArgSRect(r)
	__ret := C.fz_bound_path(cctx, cpath, cstroke, cctm, cr)
	packSRect(r, cr)
	packSMatrix(ctm, cctm)
	packSStrokeState(stroke, cstroke)
	packSContext(ctx, cctx)
	__v := NewRectRef(unsafe.Pointer(__ret))
	return __v
}

// AdjustRectForStroke function as declared in fitz/path.h:345
func AdjustRectForStroke(ctx []Context, r []Rect, stroke []StrokeState, ctm []Matrix) *Rect {
	cctx, _ := unpackArgSContext(ctx)
	cr, _ := unpackArgSRect(r)
	cstroke, _ := unpackArgSStrokeState(stroke)
	cctm, _ := unpackArgSMatrix(ctm)
	__ret := C.fz_adjust_rect_for_stroke(cctx, cr, cstroke, cctm)
	packSMatrix(ctm, cctm)
	packSStrokeState(stroke, cstroke)
	packSRect(r, cr)
	packSContext(ctx, cctx)
	__v := NewRectRef(unsafe.Pointer(__ret))
	return __v
}

var DefaultStrokeState StrokeState

// NewStrokeState function as declared in fitz/path.h:355
func NewStrokeState(ctx []Context) *StrokeState {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_new_stroke_state(cctx)
	packSContext(ctx, cctx)
	__v := NewStrokeStateRef(unsafe.Pointer(__ret))
	return __v
}

// NewStrokeStateWithDashLen function as declared in fitz/path.h:366
func NewStrokeStateWithDashLen(ctx []Context, len int32) *StrokeState {
	cctx, _ := unpackArgSContext(ctx)
	clen, _ := (C.int)(len), cgoAllocsUnknown
	__ret := C.fz_new_stroke_state_with_dash_len(cctx, clen)
	packSContext(ctx, cctx)
	__v := NewStrokeStateRef(unsafe.Pointer(__ret))
	return __v
}

// KeepStrokeState function as declared in fitz/path.h:378
func KeepStrokeState(ctx []Context, stroke []StrokeState) *StrokeState {
	cctx, _ := unpackArgSContext(ctx)
	cstroke, _ := unpackArgSStrokeState(stroke)
	__ret := C.fz_keep_stroke_state(cctx, cstroke)
	packSStrokeState(stroke, cstroke)
	packSContext(ctx, cctx)
	__v := NewStrokeStateRef(unsafe.Pointer(__ret))
	return __v
}

// DropStrokeState function as declared in fitz/path.h:387
func DropStrokeState(ctx []Context, stroke []StrokeState) {
	cctx, _ := unpackArgSContext(ctx)
	cstroke, _ := unpackArgSStrokeState(stroke)
	C.fz_drop_stroke_state(cctx, cstroke)
	packSStrokeState(stroke, cstroke)
	packSContext(ctx, cctx)
}

// UnshareStrokeState function as declared in fitz/path.h:404
func UnshareStrokeState(ctx []Context, shared []StrokeState) *StrokeState {
	cctx, _ := unpackArgSContext(ctx)
	cshared, _ := unpackArgSStrokeState(shared)
	__ret := C.fz_unshare_stroke_state(cctx, cshared)
	packSStrokeState(shared, cshared)
	packSContext(ctx, cctx)
	__v := NewStrokeStateRef(unsafe.Pointer(__ret))
	return __v
}

// UnshareStrokeStateWithDashLen function as declared in fitz/path.h:421
func UnshareStrokeStateWithDashLen(ctx []Context, shared []StrokeState, len int32) *StrokeState {
	cctx, _ := unpackArgSContext(ctx)
	cshared, _ := unpackArgSStrokeState(shared)
	clen, _ := (C.int)(len), cgoAllocsUnknown
	__ret := C.fz_unshare_stroke_state_with_dash_len(cctx, cshared, clen)
	packSStrokeState(shared, cshared)
	packSContext(ctx, cctx)
	__v := NewStrokeStateRef(unsafe.Pointer(__ret))
	return __v
}

// CloneStrokeState function as declared in fitz/path.h:432
func CloneStrokeState(ctx []Context, stroke []StrokeState) *StrokeState {
	cctx, _ := unpackArgSContext(ctx)
	cstroke, _ := unpackArgSStrokeState(stroke)
	__ret := C.fz_clone_stroke_state(cctx, cstroke)
	packSStrokeState(stroke, cstroke)
	packSContext(ctx, cctx)
	__v := NewStrokeStateRef(unsafe.Pointer(__ret))
	return __v
}

// NewText function as declared in fitz/text.h:72
func NewText(ctx []Context) *Text {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_new_text(cctx)
	packSContext(ctx, cctx)
	__v := NewTextRef(unsafe.Pointer(__ret))
	return __v
}

// KeepText function as declared in fitz/text.h:81
func KeepText(ctx []Context, text []Text) *Text {
	cctx, _ := unpackArgSContext(ctx)
	ctext, _ := unpackArgSText(text)
	__ret := C.fz_keep_text(cctx, ctext)
	packSText(text, ctext)
	packSContext(ctx, cctx)
	__v := NewTextRef(unsafe.Pointer(__ret))
	return __v
}

// DropText function as declared in fitz/text.h:89
func DropText(ctx []Context, text []Text) {
	cctx, _ := unpackArgSContext(ctx)
	ctext, _ := unpackArgSText(text)
	C.fz_drop_text(cctx, ctext)
	packSText(text, ctext)
	packSContext(ctx, cctx)
}

// ShowGlyph function as declared in fitz/text.h:116
func ShowGlyph(ctx []Context, text []Text, font []Font, trm []Matrix, glyph int32, unicode int32, wmode int32, bidiLevel int32, markupDir BidiDirection, language TextLanguage) {
	cctx, _ := unpackArgSContext(ctx)
	ctext, _ := unpackArgSText(text)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	ctrm, _ := unpackArgSMatrix(trm)
	cglyph, _ := (C.int)(glyph), cgoAllocsUnknown
	cunicode, _ := (C.int)(unicode), cgoAllocsUnknown
	cwmode, _ := (C.int)(wmode), cgoAllocsUnknown
	cbidiLevel, _ := (C.int)(bidiLevel), cgoAllocsUnknown
	cmarkupDir, _ := (C.fz_bidi_direction)(markupDir), cgoAllocsUnknown
	clanguage, _ := (C.fz_text_language)(language), cgoAllocsUnknown
	C.fz_show_glyph(cctx, ctext, cfont, ctrm, cglyph, cunicode, cwmode, cbidiLevel, cmarkupDir, clanguage)
	packSMatrix(trm, ctrm)
	packSText(text, ctext)
	packSContext(ctx, cctx)
}

// ShowString function as declared in fitz/text.h:142
func ShowString(ctx []Context, text []Text, font []Font, trm []Matrix, s string, wmode int32, bidiLevel int32, markupDir BidiDirection, language TextLanguage) {
	cctx, _ := unpackArgSContext(ctx)
	ctext, _ := unpackArgSText(text)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	ctrm, _ := unpackArgSMatrix(trm)
	cs, _ := unpackPCharString(s)
	cwmode, _ := (C.int)(wmode), cgoAllocsUnknown
	cbidiLevel, _ := (C.int)(bidiLevel), cgoAllocsUnknown
	cmarkupDir, _ := (C.fz_bidi_direction)(markupDir), cgoAllocsUnknown
	clanguage, _ := (C.fz_text_language)(language), cgoAllocsUnknown
	C.fz_show_string(cctx, ctext, cfont, ctrm, cs, cwmode, cbidiLevel, cmarkupDir, clanguage)
	packSMatrix(trm, ctrm)
	packSText(text, ctext)
	packSContext(ctx, cctx)
}

// BoundText function as declared in fitz/text.h:159
func BoundText(ctx []Context, text []Text, stroke []StrokeState, ctm []Matrix, r []Rect) *Rect {
	cctx, _ := unpackArgSContext(ctx)
	ctext, _ := unpackArgSText(text)
	cstroke, _ := unpackArgSStrokeState(stroke)
	cctm, _ := unpackArgSMatrix(ctm)
	cr, _ := unpackArgSRect(r)
	__ret := C.fz_bound_text(cctx, ctext, cstroke, cctm, cr)
	packSRect(r, cr)
	packSMatrix(ctm, cctm)
	packSStrokeState(stroke, cstroke)
	packSText(text, ctext)
	packSContext(ctx, cctx)
	__v := NewRectRef(unsafe.Pointer(__ret))
	return __v
}

// CloneText function as declared in fitz/text.h:168
func CloneText(ctx []Context, text []Text) *Text {
	cctx, _ := unpackArgSContext(ctx)
	ctext, _ := unpackArgSText(text)
	__ret := C.fz_clone_text(cctx, ctext)
	packSText(text, ctext)
	packSContext(ctx, cctx)
	__v := NewTextRef(unsafe.Pointer(__ret))
	return __v
}

// TextLanguageFromString function as declared in fitz/text.h:179
func TextLanguageFromString(str string) TextLanguage {
	cstr, _ := unpackPCharString(str)
	__ret := C.fz_text_language_from_string(cstr)
	__v := (TextLanguage)(__ret)
	return __v
}

// StringFromTextLanguage function as declared in fitz/text.h:187
func StringFromTextLanguage(str *[8]byte, lang TextLanguage) *byte {
	cstr, _ := *(**C.char)(unsafe.Pointer(&str)), cgoAllocsUnknown
	clang, _ := (C.fz_text_language)(lang), cgoAllocsUnknown
	__ret := C.fz_string_from_text_language(cstr, clang)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// GetCmmEngine function as declared in fitz/color-management.h:88
func GetCmmEngine(ctx []Context) *CmmEngine {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_get_cmm_engine(cctx)
	packSContext(ctx, cctx)
	__v := NewCmmEngineRef(unsafe.Pointer(__ret))
	return __v
}

// SetCmmEngine function as declared in fitz/color-management.h:104
func SetCmmEngine(ctx []Context, engine []CmmEngine) {
	cctx, _ := unpackArgSContext(ctx)
	cengine, _ := unpackArgSCmmEngine(engine)
	C.fz_set_cmm_engine(cctx, cengine)
	packSCmmEngine(engine, cengine)
	packSContext(ctx, cctx)
}

var CmmEngineLcms CmmEngine

// LookupBlendmode function as declared in fitz/device.h:75
func LookupBlendmode(name string) int32 {
	cname, _ := unpackPCharString(name)
	__ret := C.fz_lookup_blendmode(cname)
	__v := (int32)(__ret)
	return __v
}

// BlendmodeName function as declared in fitz/device.h:76
func BlendmodeName(blendmode int32) *byte {
	cblendmode, _ := (C.int)(blendmode), cgoAllocsUnknown
	__ret := C.fz_blendmode_name(cblendmode)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// FillPath function as declared in fitz/device.h:128
func FillPath(ctx []Context, dev []Device, path []Path, evenOdd int32, ctm []Matrix, colorspace []Colorspace, color []float32, alpha float32, colorParams []ColorParams) {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	cpath, _ := (*C.fz_path)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&path)).Data)), cgoAllocsUnknown
	cevenOdd, _ := (C.int)(evenOdd), cgoAllocsUnknown
	cctm, _ := unpackArgSMatrix(ctm)
	ccolorspace, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&colorspace)).Data)), cgoAllocsUnknown
	ccolor, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&color)).Data)), cgoAllocsUnknown
	calpha, _ := (C.float)(alpha), cgoAllocsUnknown
	ccolorParams, _ := unpackArgSColorParams(colorParams)
	C.fz_fill_path(cctx, cdev, cpath, cevenOdd, cctm, ccolorspace, ccolor, calpha, ccolorParams)
	packSColorParams(colorParams, ccolorParams)
	packSMatrix(ctm, cctm)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// StrokePath function as declared in fitz/device.h:129
func StrokePath(ctx []Context, dev []Device, path []Path, stroke []StrokeState, ctm []Matrix, colorspace []Colorspace, color []float32, alpha float32, colorParams []ColorParams) {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	cpath, _ := (*C.fz_path)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&path)).Data)), cgoAllocsUnknown
	cstroke, _ := unpackArgSStrokeState(stroke)
	cctm, _ := unpackArgSMatrix(ctm)
	ccolorspace, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&colorspace)).Data)), cgoAllocsUnknown
	ccolor, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&color)).Data)), cgoAllocsUnknown
	calpha, _ := (C.float)(alpha), cgoAllocsUnknown
	ccolorParams, _ := unpackArgSColorParams(colorParams)
	C.fz_stroke_path(cctx, cdev, cpath, cstroke, cctm, ccolorspace, ccolor, calpha, ccolorParams)
	packSColorParams(colorParams, ccolorParams)
	packSMatrix(ctm, cctm)
	packSStrokeState(stroke, cstroke)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// ClipPath function as declared in fitz/device.h:130
func ClipPath(ctx []Context, dev []Device, path []Path, evenOdd int32, ctm []Matrix, scissor []Rect) {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	cpath, _ := (*C.fz_path)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&path)).Data)), cgoAllocsUnknown
	cevenOdd, _ := (C.int)(evenOdd), cgoAllocsUnknown
	cctm, _ := unpackArgSMatrix(ctm)
	cscissor, _ := unpackArgSRect(scissor)
	C.fz_clip_path(cctx, cdev, cpath, cevenOdd, cctm, cscissor)
	packSRect(scissor, cscissor)
	packSMatrix(ctm, cctm)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// ClipStrokePath function as declared in fitz/device.h:131
func ClipStrokePath(ctx []Context, dev []Device, path []Path, stroke []StrokeState, ctm []Matrix, scissor []Rect) {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	cpath, _ := (*C.fz_path)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&path)).Data)), cgoAllocsUnknown
	cstroke, _ := unpackArgSStrokeState(stroke)
	cctm, _ := unpackArgSMatrix(ctm)
	cscissor, _ := unpackArgSRect(scissor)
	C.fz_clip_stroke_path(cctx, cdev, cpath, cstroke, cctm, cscissor)
	packSRect(scissor, cscissor)
	packSMatrix(ctm, cctm)
	packSStrokeState(stroke, cstroke)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// FillText function as declared in fitz/device.h:132
func FillText(ctx []Context, dev []Device, text []Text, ctm []Matrix, colorspace []Colorspace, color []float32, alpha float32, colorParams []ColorParams) {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	ctext, _ := unpackArgSText(text)
	cctm, _ := unpackArgSMatrix(ctm)
	ccolorspace, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&colorspace)).Data)), cgoAllocsUnknown
	ccolor, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&color)).Data)), cgoAllocsUnknown
	calpha, _ := (C.float)(alpha), cgoAllocsUnknown
	ccolorParams, _ := unpackArgSColorParams(colorParams)
	C.fz_fill_text(cctx, cdev, ctext, cctm, ccolorspace, ccolor, calpha, ccolorParams)
	packSColorParams(colorParams, ccolorParams)
	packSMatrix(ctm, cctm)
	packSText(text, ctext)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// StrokeText function as declared in fitz/device.h:133
func StrokeText(ctx []Context, dev []Device, text []Text, stroke []StrokeState, ctm []Matrix, colorspace []Colorspace, color []float32, alpha float32, colorParams []ColorParams) {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	ctext, _ := unpackArgSText(text)
	cstroke, _ := unpackArgSStrokeState(stroke)
	cctm, _ := unpackArgSMatrix(ctm)
	ccolorspace, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&colorspace)).Data)), cgoAllocsUnknown
	ccolor, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&color)).Data)), cgoAllocsUnknown
	calpha, _ := (C.float)(alpha), cgoAllocsUnknown
	ccolorParams, _ := unpackArgSColorParams(colorParams)
	C.fz_stroke_text(cctx, cdev, ctext, cstroke, cctm, ccolorspace, ccolor, calpha, ccolorParams)
	packSColorParams(colorParams, ccolorParams)
	packSMatrix(ctm, cctm)
	packSStrokeState(stroke, cstroke)
	packSText(text, ctext)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// ClipText function as declared in fitz/device.h:134
func ClipText(ctx []Context, dev []Device, text []Text, ctm []Matrix, scissor []Rect) {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	ctext, _ := unpackArgSText(text)
	cctm, _ := unpackArgSMatrix(ctm)
	cscissor, _ := unpackArgSRect(scissor)
	C.fz_clip_text(cctx, cdev, ctext, cctm, cscissor)
	packSRect(scissor, cscissor)
	packSMatrix(ctm, cctm)
	packSText(text, ctext)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// ClipStrokeText function as declared in fitz/device.h:135
func ClipStrokeText(ctx []Context, dev []Device, text []Text, stroke []StrokeState, ctm []Matrix, scissor []Rect) {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	ctext, _ := unpackArgSText(text)
	cstroke, _ := unpackArgSStrokeState(stroke)
	cctm, _ := unpackArgSMatrix(ctm)
	cscissor, _ := unpackArgSRect(scissor)
	C.fz_clip_stroke_text(cctx, cdev, ctext, cstroke, cctm, cscissor)
	packSRect(scissor, cscissor)
	packSMatrix(ctm, cctm)
	packSStrokeState(stroke, cstroke)
	packSText(text, ctext)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// IgnoreText function as declared in fitz/device.h:136
func IgnoreText(ctx []Context, dev []Device, text []Text, ctm []Matrix) {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	ctext, _ := unpackArgSText(text)
	cctm, _ := unpackArgSMatrix(ctm)
	C.fz_ignore_text(cctx, cdev, ctext, cctm)
	packSMatrix(ctm, cctm)
	packSText(text, ctext)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// PopClip function as declared in fitz/device.h:137
func PopClip(ctx []Context, dev []Device) {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	C.fz_pop_clip(cctx, cdev)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// FillShade function as declared in fitz/device.h:138
func FillShade(ctx []Context, dev []Device, shade []Shade, ctm []Matrix, alpha float32, colorParams []ColorParams) {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	cshade, _ := unpackArgSShade(shade)
	cctm, _ := unpackArgSMatrix(ctm)
	calpha, _ := (C.float)(alpha), cgoAllocsUnknown
	ccolorParams, _ := unpackArgSColorParams(colorParams)
	C.fz_fill_shade(cctx, cdev, cshade, cctm, calpha, ccolorParams)
	packSColorParams(colorParams, ccolorParams)
	packSMatrix(ctm, cctm)
	packSShade(shade, cshade)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// FillImage function as declared in fitz/device.h:139
func FillImage(ctx []Context, dev []Device, image []Image, ctm []Matrix, alpha float32, colorParams []ColorParams) {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	cimage, _ := unpackArgSImage(image)
	cctm, _ := unpackArgSMatrix(ctm)
	calpha, _ := (C.float)(alpha), cgoAllocsUnknown
	ccolorParams, _ := unpackArgSColorParams(colorParams)
	C.fz_fill_image(cctx, cdev, cimage, cctm, calpha, ccolorParams)
	packSColorParams(colorParams, ccolorParams)
	packSMatrix(ctm, cctm)
	packSImage(image, cimage)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// FillImageMask function as declared in fitz/device.h:140
func FillImageMask(ctx []Context, dev []Device, image []Image, ctm []Matrix, colorspace []Colorspace, color []float32, alpha float32, colorParams []ColorParams) {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	cimage, _ := unpackArgSImage(image)
	cctm, _ := unpackArgSMatrix(ctm)
	ccolorspace, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&colorspace)).Data)), cgoAllocsUnknown
	ccolor, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&color)).Data)), cgoAllocsUnknown
	calpha, _ := (C.float)(alpha), cgoAllocsUnknown
	ccolorParams, _ := unpackArgSColorParams(colorParams)
	C.fz_fill_image_mask(cctx, cdev, cimage, cctm, ccolorspace, ccolor, calpha, ccolorParams)
	packSColorParams(colorParams, ccolorParams)
	packSMatrix(ctm, cctm)
	packSImage(image, cimage)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// ClipImageMask function as declared in fitz/device.h:141
func ClipImageMask(ctx []Context, dev []Device, image []Image, ctm []Matrix, scissor []Rect) {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	cimage, _ := unpackArgSImage(image)
	cctm, _ := unpackArgSMatrix(ctm)
	cscissor, _ := unpackArgSRect(scissor)
	C.fz_clip_image_mask(cctx, cdev, cimage, cctm, cscissor)
	packSRect(scissor, cscissor)
	packSMatrix(ctm, cctm)
	packSImage(image, cimage)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// BeginMask function as declared in fitz/device.h:142
func BeginMask(ctx []Context, dev []Device, area []Rect, luminosity int32, colorspace []Colorspace, bc []float32, colorParams []ColorParams) {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	carea, _ := unpackArgSRect(area)
	cluminosity, _ := (C.int)(luminosity), cgoAllocsUnknown
	ccolorspace, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&colorspace)).Data)), cgoAllocsUnknown
	cbc, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&bc)).Data)), cgoAllocsUnknown
	ccolorParams, _ := unpackArgSColorParams(colorParams)
	C.fz_begin_mask(cctx, cdev, carea, cluminosity, ccolorspace, cbc, ccolorParams)
	packSColorParams(colorParams, ccolorParams)
	packSRect(area, carea)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// EndMask function as declared in fitz/device.h:143
func EndMask(ctx []Context, dev []Device) {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	C.fz_end_mask(cctx, cdev)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// BeginGroup function as declared in fitz/device.h:144
func BeginGroup(ctx []Context, dev []Device, area []Rect, cs []Colorspace, isolated int32, knockout int32, blendmode int32, alpha float32) {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	carea, _ := unpackArgSRect(area)
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	cisolated, _ := (C.int)(isolated), cgoAllocsUnknown
	cknockout, _ := (C.int)(knockout), cgoAllocsUnknown
	cblendmode, _ := (C.int)(blendmode), cgoAllocsUnknown
	calpha, _ := (C.float)(alpha), cgoAllocsUnknown
	C.fz_begin_group(cctx, cdev, carea, ccs, cisolated, cknockout, cblendmode, calpha)
	packSRect(area, carea)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// EndGroup function as declared in fitz/device.h:145
func EndGroup(ctx []Context, dev []Device) {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	C.fz_end_group(cctx, cdev)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// BeginTile function as declared in fitz/device.h:146
func BeginTile(ctx []Context, dev []Device, area []Rect, view []Rect, xstep float32, ystep float32, ctm []Matrix) {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	carea, _ := unpackArgSRect(area)
	cview, _ := unpackArgSRect(view)
	cxstep, _ := (C.float)(xstep), cgoAllocsUnknown
	cystep, _ := (C.float)(ystep), cgoAllocsUnknown
	cctm, _ := unpackArgSMatrix(ctm)
	C.fz_begin_tile(cctx, cdev, carea, cview, cxstep, cystep, cctm)
	packSMatrix(ctm, cctm)
	packSRect(view, cview)
	packSRect(area, carea)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// BeginTileId function as declared in fitz/device.h:147
func BeginTileId(ctx []Context, dev []Device, area []Rect, view []Rect, xstep float32, ystep float32, ctm []Matrix, id int32) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	carea, _ := unpackArgSRect(area)
	cview, _ := unpackArgSRect(view)
	cxstep, _ := (C.float)(xstep), cgoAllocsUnknown
	cystep, _ := (C.float)(ystep), cgoAllocsUnknown
	cctm, _ := unpackArgSMatrix(ctm)
	cid, _ := (C.int)(id), cgoAllocsUnknown
	__ret := C.fz_begin_tile_id(cctx, cdev, carea, cview, cxstep, cystep, cctm, cid)
	packSMatrix(ctm, cctm)
	packSRect(view, cview)
	packSRect(area, carea)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// EndTile function as declared in fitz/device.h:148
func EndTile(ctx []Context, dev []Device) {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	C.fz_end_tile(cctx, cdev)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// RenderFlags function as declared in fitz/device.h:149
func RenderFlags(ctx []Context, dev []Device, set int32, clear int32) {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	cset, _ := (C.int)(set), cgoAllocsUnknown
	cclear, _ := (C.int)(clear), cgoAllocsUnknown
	C.fz_render_flags(cctx, cdev, cset, cclear)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// SetDefaultColorspaces function as declared in fitz/device.h:150
func SetDefaultColorspaces(ctx []Context, dev []Device, defaultCs []DefaultColorspaces) {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	cdefaultCs, _ := (*C.fz_default_colorspaces)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&defaultCs)).Data)), cgoAllocsUnknown
	C.fz_set_default_colorspaces(cctx, cdev, cdefaultCs)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// NewDeviceOfSize function as declared in fitz/device.h:151
func NewDeviceOfSize(ctx []Context, size int32) *Device {
	cctx, _ := unpackArgSContext(ctx)
	csize, _ := (C.int)(size), cgoAllocsUnknown
	__ret := C.fz_new_device_of_size(cctx, csize)
	packSContext(ctx, cctx)
	__v := NewDeviceRef(unsafe.Pointer(__ret))
	return __v
}

// CloseDevice function as declared in fitz/device.h:160
func CloseDevice(ctx []Context, dev []Device) {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	C.fz_close_device(cctx, cdev)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// DropDevice function as declared in fitz/device.h:167
func DropDevice(ctx []Context, dev []Device) {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	C.fz_drop_device(cctx, cdev)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// KeepDevice function as declared in fitz/device.h:169
func KeepDevice(ctx []Context, dev []Device) *Device {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	__ret := C.fz_keep_device(cctx, cdev)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
	__v := NewDeviceRef(unsafe.Pointer(__ret))
	return __v
}

// EnableDeviceHints function as declared in fitz/device.h:176
func EnableDeviceHints(ctx []Context, dev []Device, hints int32) {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	chints, _ := (C.int)(hints), cgoAllocsUnknown
	C.fz_enable_device_hints(cctx, cdev, chints)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// DisableDeviceHints function as declared in fitz/device.h:183
func DisableDeviceHints(ctx []Context, dev []Device, hints int32) {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	chints, _ := (C.int)(hints), cgoAllocsUnknown
	C.fz_disable_device_hints(cctx, cdev, chints)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// DeviceCurrentScissor function as declared in fitz/device.h:188
func DeviceCurrentScissor(ctx []Context, dev []Device) *Rect {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	__ret := C.fz_device_current_scissor(cctx, cdev)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
	__v := NewRectRef(unsafe.Pointer(__ret))
	return __v
}

// NewTraceDevice function as declared in fitz/device.h:263
func NewTraceDevice(ctx []Context, out []Output) *Device {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	__ret := C.fz_new_trace_device(cctx, cout)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
	__v := NewDeviceRef(unsafe.Pointer(__ret))
	return __v
}

// NewBboxDevice function as declared in fitz/device.h:272
func NewBboxDevice(ctx []Context, rectp []Rect) *Device {
	cctx, _ := unpackArgSContext(ctx)
	crectp, _ := unpackArgSRect(rectp)
	__ret := C.fz_new_bbox_device(cctx, crectp)
	packSRect(rectp, crectp)
	packSContext(ctx, cctx)
	__v := NewDeviceRef(unsafe.Pointer(__ret))
	return __v
}

// NewTestDevice function as declared in fitz/device.h:300
func NewTestDevice(ctx []Context, isColor []int32, threshold float32, options int32, passthrough []Device) *Device {
	cctx, _ := unpackArgSContext(ctx)
	cisColor, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&isColor)).Data)), cgoAllocsUnknown
	cthreshold, _ := (C.float)(threshold), cgoAllocsUnknown
	coptions, _ := (C.int)(options), cgoAllocsUnknown
	cpassthrough, _ := unpackArgSDevice(passthrough)
	__ret := C.fz_new_test_device(cctx, cisColor, cthreshold, coptions, cpassthrough)
	packSDevice(passthrough, cpassthrough)
	packSContext(ctx, cctx)
	__v := NewDeviceRef(unsafe.Pointer(__ret))
	return __v
}

// NewDrawDevice function as declared in fitz/device.h:324
func NewDrawDevice(ctx []Context, transform []Matrix, dest []Pixmap) *Device {
	cctx, _ := unpackArgSContext(ctx)
	ctransform, _ := unpackArgSMatrix(transform)
	cdest, _ := unpackArgSPixmap(dest)
	__ret := C.fz_new_draw_device(cctx, ctransform, cdest)
	packSPixmap(dest, cdest)
	packSMatrix(transform, ctransform)
	packSContext(ctx, cctx)
	__v := NewDeviceRef(unsafe.Pointer(__ret))
	return __v
}

// NewDrawDeviceWithBbox function as declared in fitz/device.h:340
func NewDrawDeviceWithBbox(ctx []Context, transform []Matrix, dest []Pixmap, clip []Irect) *Device {
	cctx, _ := unpackArgSContext(ctx)
	ctransform, _ := unpackArgSMatrix(transform)
	cdest, _ := unpackArgSPixmap(dest)
	cclip, _ := unpackArgSIrect(clip)
	__ret := C.fz_new_draw_device_with_bbox(cctx, ctransform, cdest, cclip)
	packSIrect(clip, cclip)
	packSPixmap(dest, cdest)
	packSMatrix(transform, ctransform)
	packSContext(ctx, cctx)
	__v := NewDeviceRef(unsafe.Pointer(__ret))
	return __v
}

// NewDrawDeviceType3 function as declared in fitz/device.h:342
func NewDrawDeviceType3(ctx []Context, transform []Matrix, dest []Pixmap) *Device {
	cctx, _ := unpackArgSContext(ctx)
	ctransform, _ := unpackArgSMatrix(transform)
	cdest, _ := unpackArgSPixmap(dest)
	__ret := C.fz_new_draw_device_type3(cctx, ctransform, cdest)
	packSPixmap(dest, cdest)
	packSMatrix(transform, ctransform)
	packSContext(ctx, cctx)
	__v := NewDeviceRef(unsafe.Pointer(__ret))
	return __v
}

// ParseDrawOptions function as declared in fitz/device.h:367
func ParseDrawOptions(ctx []Context, options []DrawOptions, string string) *DrawOptions {
	cctx, _ := unpackArgSContext(ctx)
	coptions, _ := unpackArgSDrawOptions(options)
	cstring, _ := unpackPCharString(string)
	__ret := C.fz_parse_draw_options(cctx, coptions, cstring)
	packSDrawOptions(options, coptions)
	packSContext(ctx, cctx)
	__v := NewDrawOptionsRef(unsafe.Pointer(__ret))
	return __v
}

// NewDrawDeviceWithOptions function as declared in fitz/device.h:376
func NewDrawDeviceWithOptions(ctx []Context, options []DrawOptions, mediabox []Rect, pixmap [][]Pixmap) *Device {
	cctx, _ := unpackArgSContext(ctx)
	coptions, _ := unpackArgSDrawOptions(options)
	cmediabox, _ := unpackArgSRect(mediabox)
	cpixmap, _ := unpackArgSSPixmap(pixmap)
	__ret := C.fz_new_draw_device_with_options(cctx, coptions, cmediabox, cpixmap)
	packSSPixmap(pixmap, cpixmap)
	packSRect(mediabox, cmediabox)
	packSDrawOptions(options, coptions)
	packSContext(ctx, cctx)
	__v := NewDeviceRef(unsafe.Pointer(__ret))
	return __v
}

// NewDisplayList function as declared in fitz/display-list.h:35
func NewDisplayList(ctx []Context, mediabox []Rect) *DisplayList {
	cctx, _ := unpackArgSContext(ctx)
	cmediabox, _ := unpackArgSRect(mediabox)
	__ret := C.fz_new_display_list(cctx, cmediabox)
	packSRect(mediabox, cmediabox)
	packSContext(ctx, cctx)
	__v := *(**DisplayList)(unsafe.Pointer(&__ret))
	return __v
}

// NewListDevice function as declared in fitz/display-list.h:49
func NewListDevice(ctx []Context, list []DisplayList) *Device {
	cctx, _ := unpackArgSContext(ctx)
	clist, _ := (*C.fz_display_list)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&list)).Data)), cgoAllocsUnknown
	__ret := C.fz_new_list_device(cctx, clist)
	packSContext(ctx, cctx)
	__v := NewDeviceRef(unsafe.Pointer(__ret))
	return __v
}

// RunDisplayList function as declared in fitz/display-list.h:76
func RunDisplayList(ctx []Context, list []DisplayList, dev []Device, ctm []Matrix, area []Rect, cookie []Cookie) {
	cctx, _ := unpackArgSContext(ctx)
	clist, _ := (*C.fz_display_list)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&list)).Data)), cgoAllocsUnknown
	cdev, _ := unpackArgSDevice(dev)
	cctm, _ := unpackArgSMatrix(ctm)
	carea, _ := unpackArgSRect(area)
	ccookie, _ := unpackArgSCookie(cookie)
	C.fz_run_display_list(cctx, clist, cdev, cctm, carea, ccookie)
	packSCookie(cookie, ccookie)
	packSRect(area, carea)
	packSMatrix(ctm, cctm)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// KeepDisplayList function as declared in fitz/display-list.h:81
func KeepDisplayList(ctx []Context, list []DisplayList) *DisplayList {
	cctx, _ := unpackArgSContext(ctx)
	clist, _ := (*C.fz_display_list)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&list)).Data)), cgoAllocsUnknown
	__ret := C.fz_keep_display_list(cctx, clist)
	packSContext(ctx, cctx)
	__v := *(**DisplayList)(unsafe.Pointer(&__ret))
	return __v
}

// DropDisplayList function as declared in fitz/display-list.h:87
func DropDisplayList(ctx []Context, list []DisplayList) {
	cctx, _ := unpackArgSContext(ctx)
	clist, _ := (*C.fz_display_list)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&list)).Data)), cgoAllocsUnknown
	C.fz_drop_display_list(cctx, clist)
	packSContext(ctx, cctx)
}

// BoundDisplayList function as declared in fitz/display-list.h:92
func BoundDisplayList(ctx []Context, list []DisplayList, bounds []Rect) *Rect {
	cctx, _ := unpackArgSContext(ctx)
	clist, _ := (*C.fz_display_list)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&list)).Data)), cgoAllocsUnknown
	cbounds, _ := unpackArgSRect(bounds)
	__ret := C.fz_bound_display_list(cctx, clist, cbounds)
	packSRect(bounds, cbounds)
	packSContext(ctx, cctx)
	__v := NewRectRef(unsafe.Pointer(__ret))
	return __v
}

// NewImageFromDisplayList function as declared in fitz/display-list.h:104
func NewImageFromDisplayList(ctx []Context, w float32, h float32, list []DisplayList) *Image {
	cctx, _ := unpackArgSContext(ctx)
	cw, _ := (C.float)(w), cgoAllocsUnknown
	ch, _ := (C.float)(h), cgoAllocsUnknown
	clist, _ := (*C.fz_display_list)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&list)).Data)), cgoAllocsUnknown
	__ret := C.fz_new_image_from_display_list(cctx, cw, ch, clist)
	packSContext(ctx, cctx)
	__v := NewImageRef(unsafe.Pointer(__ret))
	return __v
}

// DisplayListIsEmpty function as declared in fitz/display-list.h:113
func DisplayListIsEmpty(ctx []Context, list []DisplayList) int32 {
	cctx, _ := unpackArgSContext(ctx)
	clist, _ := (*C.fz_display_list)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&list)).Data)), cgoAllocsUnknown
	__ret := C.fz_display_list_is_empty(cctx, clist)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// StextCharCount function as declared in fitz/structured-text.h:106
func StextCharCount(ctx []Context, page []StextPage) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSStextPage(page)
	__ret := C.fz_stext_char_count(cctx, cpage)
	packSStextPage(page, cpage)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// StextCharAt function as declared in fitz/structured-text.h:107
func StextCharAt(ctx []Context, page []StextPage, idx int32) *StextChar {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSStextPage(page)
	cidx, _ := (C.int)(idx), cgoAllocsUnknown
	__ret := C.fz_stext_char_at(cctx, cpage, cidx)
	packSStextPage(page, cpage)
	packSContext(ctx, cctx)
	__v := NewStextCharRef(unsafe.Pointer(__ret))
	return __v
}

// NewStextPage function as declared in fitz/structured-text.h:117
func NewStextPage(ctx []Context, mediabox []Rect) *StextPage {
	cctx, _ := unpackArgSContext(ctx)
	cmediabox, _ := unpackArgSRect(mediabox)
	__ret := C.fz_new_stext_page(cctx, cmediabox)
	packSRect(mediabox, cmediabox)
	packSContext(ctx, cctx)
	__v := NewStextPageRef(unsafe.Pointer(__ret))
	return __v
}

// DropStextPage function as declared in fitz/structured-text.h:118
func DropStextPage(ctx []Context, page []StextPage) {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSStextPage(page)
	C.fz_drop_stext_page(cctx, cpage)
	packSStextPage(page, cpage)
	packSContext(ctx, cctx)
}

// PrintStextPageAsHtml function as declared in fitz/structured-text.h:123
func PrintStextPageAsHtml(ctx []Context, out []Output, page []StextPage) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cpage, _ := unpackArgSStextPage(page)
	C.fz_print_stext_page_as_html(cctx, cout, cpage)
	packSStextPage(page, cpage)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// PrintStextHeaderAsHtml function as declared in fitz/structured-text.h:124
func PrintStextHeaderAsHtml(ctx []Context, out []Output) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	C.fz_print_stext_header_as_html(cctx, cout)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// PrintStextTrailerAsHtml function as declared in fitz/structured-text.h:125
func PrintStextTrailerAsHtml(ctx []Context, out []Output) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	C.fz_print_stext_trailer_as_html(cctx, cout)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// PrintStextPageAsXhtml function as declared in fitz/structured-text.h:130
func PrintStextPageAsXhtml(ctx []Context, out []Output, page []StextPage) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cpage, _ := unpackArgSStextPage(page)
	C.fz_print_stext_page_as_xhtml(cctx, cout, cpage)
	packSStextPage(page, cpage)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// PrintStextHeaderAsXhtml function as declared in fitz/structured-text.h:131
func PrintStextHeaderAsXhtml(ctx []Context, out []Output) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	C.fz_print_stext_header_as_xhtml(cctx, cout)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// PrintStextTrailerAsXhtml function as declared in fitz/structured-text.h:132
func PrintStextTrailerAsXhtml(ctx []Context, out []Output) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	C.fz_print_stext_trailer_as_xhtml(cctx, cout)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// PrintStextPageAsXml function as declared in fitz/structured-text.h:137
func PrintStextPageAsXml(ctx []Context, out []Output, page []StextPage) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cpage, _ := unpackArgSStextPage(page)
	C.fz_print_stext_page_as_xml(cctx, cout, cpage)
	packSStextPage(page, cpage)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// PrintStextPageAsText function as declared in fitz/structured-text.h:142
func PrintStextPageAsText(ctx []Context, out []Output, page []StextPage) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cpage, _ := unpackArgSStextPage(page)
	C.fz_print_stext_page_as_text(cctx, cout, cpage)
	packSStextPage(page, cpage)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// SearchStextPage function as declared in fitz/structured-text.h:151
func SearchStextPage(ctx []Context, text []StextPage, needle string, hitBbox []Rect, hitMax int32) int32 {
	cctx, _ := unpackArgSContext(ctx)
	ctext, _ := unpackArgSStextPage(text)
	cneedle, _ := unpackPCharString(needle)
	chitBbox, _ := unpackArgSRect(hitBbox)
	chitMax, _ := (C.int)(hitMax), cgoAllocsUnknown
	__ret := C.fz_search_stext_page(cctx, ctext, cneedle, chitBbox, chitMax)
	packSRect(hitBbox, chitBbox)
	packSStextPage(text, ctext)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// HighlightSelection function as declared in fitz/structured-text.h:158
func HighlightSelection(ctx []Context, page []StextPage, rect Rect, hitBbox []Rect, hitMax int32) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSStextPage(page)
	crect, _ := rect.PassValue()
	chitBbox, _ := unpackArgSRect(hitBbox)
	chitMax, _ := (C.int)(hitMax), cgoAllocsUnknown
	__ret := C.fz_highlight_selection(cctx, cpage, crect, chitBbox, chitMax)
	packSRect(hitBbox, chitBbox)
	packSStextPage(page, cpage)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// CopySelection function as declared in fitz/structured-text.h:165
func CopySelection(ctx []Context, page []StextPage, rect Rect) *byte {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSStextPage(page)
	crect, _ := rect.PassValue()
	__ret := C.fz_copy_selection(cctx, cpage, crect)
	packSStextPage(page, cpage)
	packSContext(ctx, cctx)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// ParseStextOptions function as declared in fitz/structured-text.h:180
func ParseStextOptions(ctx []Context, opts []StextOptions, string string) *StextOptions {
	cctx, _ := unpackArgSContext(ctx)
	copts, _ := unpackArgSStextOptions(opts)
	cstring, _ := unpackPCharString(string)
	__ret := C.fz_parse_stext_options(cctx, copts, cstring)
	packSStextOptions(opts, copts)
	packSContext(ctx, cctx)
	__v := NewStextOptionsRef(unsafe.Pointer(__ret))
	return __v
}

// NewStextDevice function as declared in fitz/structured-text.h:197
func NewStextDevice(ctx []Context, page []StextPage, options []StextOptions) *Device {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSStextPage(page)
	coptions, _ := unpackArgSStextOptions(options)
	__ret := C.fz_new_stext_device(cctx, cpage, coptions)
	packSStextOptions(options, coptions)
	packSStextPage(page, cpage)
	packSContext(ctx, cctx)
	__v := NewDeviceRef(unsafe.Pointer(__ret))
	return __v
}

// GenerateTransition function as declared in fitz/transition.h:52
func GenerateTransition(ctx []Context, tpix []Pixmap, opix []Pixmap, npix []Pixmap, time int32, trans []Transition) int32 {
	cctx, _ := unpackArgSContext(ctx)
	ctpix, _ := unpackArgSPixmap(tpix)
	copix, _ := unpackArgSPixmap(opix)
	cnpix, _ := unpackArgSPixmap(npix)
	ctime, _ := (C.int)(time), cgoAllocsUnknown
	ctrans, _ := unpackArgSTransition(trans)
	__ret := C.fz_generate_transition(cctx, ctpix, copix, cnpix, ctime, ctrans)
	packSTransition(trans, ctrans)
	packSPixmap(npix, cnpix)
	packSPixmap(opix, copix)
	packSPixmap(tpix, ctpix)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// PurgeGlyphCache function as declared in fitz/glyph-cache.h:9
func PurgeGlyphCache(ctx []Context) {
	cctx, _ := unpackArgSContext(ctx)
	C.fz_purge_glyph_cache(cctx)
	packSContext(ctx, cctx)
}

// RenderGlyphPixmap function as declared in fitz/glyph-cache.h:10
func RenderGlyphPixmap(ctx []Context, arg1 []Font, arg2 int32, arg3 []Matrix, scissor []Irect, aa int32) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	carg1, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&arg1)).Data)), cgoAllocsUnknown
	carg2, _ := (C.int)(arg2), cgoAllocsUnknown
	carg3, _ := unpackArgSMatrix(arg3)
	cscissor, _ := unpackArgSIrect(scissor)
	caa, _ := (C.int)(aa), cgoAllocsUnknown
	__ret := C.fz_render_glyph_pixmap(cctx, carg1, carg2, carg3, cscissor, caa)
	packSIrect(scissor, cscissor)
	packSMatrix(arg3, carg3)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// RenderT3GlyphDirect function as declared in fitz/glyph-cache.h:11
func RenderT3GlyphDirect(ctx []Context, dev []Device, font []Font, gid int32, trm []Matrix, gstate unsafe.Pointer, nesteddepth int32) {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	cgid, _ := (C.int)(gid), cgoAllocsUnknown
	ctrm, _ := unpackArgSMatrix(trm)
	cgstate, _ := gstate, cgoAllocsUnknown
	cnesteddepth, _ := (C.int)(nesteddepth), cgoAllocsUnknown
	C.fz_render_t3_glyph_direct(cctx, cdev, cfont, cgid, ctrm, cgstate, cnesteddepth)
	packSMatrix(trm, ctrm)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
}

// PrepareT3Glyph function as declared in fitz/glyph-cache.h:12
func PrepareT3Glyph(ctx []Context, font []Font, gid int32, nesteddepth int32) {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	cgid, _ := (C.int)(gid), cgoAllocsUnknown
	cnesteddepth, _ := (C.int)(nesteddepth), cgoAllocsUnknown
	C.fz_prepare_t3_glyph(cctx, cfont, cgid, cnesteddepth)
	packSContext(ctx, cctx)
}

// DumpGlyphCacheStats function as declared in fitz/glyph-cache.h:13
func DumpGlyphCacheStats(ctx []Context) {
	cctx, _ := unpackArgSContext(ctx)
	C.fz_dump_glyph_cache_stats(cctx)
	packSContext(ctx, cctx)
}

// SubpixelAdjust function as declared in fitz/glyph-cache.h:14
func SubpixelAdjust(ctx []Context, ctm []Matrix, subpixCtm []Matrix, qe []byte, qf []byte) float32 {
	cctx, _ := unpackArgSContext(ctx)
	cctm, _ := unpackArgSMatrix(ctm)
	csubpixCtm, _ := unpackArgSMatrix(subpixCtm)
	cqe, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&qe)).Data)), cgoAllocsUnknown
	cqf, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&qf)).Data)), cgoAllocsUnknown
	__ret := C.fz_subpixel_adjust(cctx, cctm, csubpixCtm, cqe, cqf)
	packSMatrix(subpixCtm, csubpixCtm)
	packSMatrix(ctm, cctm)
	packSContext(ctx, cctx)
	__v := (float32)(__ret)
	return __v
}

// NewLink function as declared in fitz/link.h:42
func NewLink(ctx []Context, bbox []Rect, doc unsafe.Pointer, uri string) *Link {
	cctx, _ := unpackArgSContext(ctx)
	cbbox, _ := unpackArgSRect(bbox)
	cdoc, _ := doc, cgoAllocsUnknown
	curi, _ := unpackPCharString(uri)
	__ret := C.fz_new_link(cctx, cbbox, cdoc, curi)
	packSRect(bbox, cbbox)
	packSContext(ctx, cctx)
	__v := NewLinkRef(unsafe.Pointer(__ret))
	return __v
}

// KeepLink function as declared in fitz/link.h:43
func KeepLink(ctx []Context, link []Link) *Link {
	cctx, _ := unpackArgSContext(ctx)
	clink, _ := unpackArgSLink(link)
	__ret := C.fz_keep_link(cctx, clink)
	packSLink(link, clink)
	packSContext(ctx, cctx)
	__v := NewLinkRef(unsafe.Pointer(__ret))
	return __v
}

// IsExternalLink function as declared in fitz/link.h:48
func IsExternalLink(ctx []Context, uri string) int32 {
	cctx, _ := unpackArgSContext(ctx)
	curi, _ := unpackPCharString(uri)
	__ret := C.fz_is_external_link(cctx, curi)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// DropLink function as declared in fitz/link.h:53
func DropLink(ctx []Context, link []Link) {
	cctx, _ := unpackArgSContext(ctx)
	clink, _ := unpackArgSLink(link)
	C.fz_drop_link(cctx, clink)
	packSLink(link, clink)
	packSContext(ctx, cctx)
}

// NewOutline function as declared in fitz/outline.h:45
func NewOutline(ctx []Context) *Outline {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.fz_new_outline(cctx)
	packSContext(ctx, cctx)
	__v := NewOutlineRef(unsafe.Pointer(__ret))
	return __v
}

// KeepOutline function as declared in fitz/outline.h:46
func KeepOutline(ctx []Context, outline []Outline) *Outline {
	cctx, _ := unpackArgSContext(ctx)
	coutline, _ := unpackArgSOutline(outline)
	__ret := C.fz_keep_outline(cctx, coutline)
	packSOutline(outline, coutline)
	packSContext(ctx, cctx)
	__v := NewOutlineRef(unsafe.Pointer(__ret))
	return __v
}

// DropOutline function as declared in fitz/outline.h:47
func DropOutline(ctx []Context, outline []Outline) {
	cctx, _ := unpackArgSContext(ctx)
	coutline, _ := unpackArgSOutline(outline)
	C.fz_drop_outline(cctx, coutline)
	packSOutline(outline, coutline)
	packSContext(ctx, cctx)
}

// RegisterDocumentHandler function as declared in fitz/document.h:292
func RegisterDocumentHandler(ctx []Context, handler []DocumentHandler) {
	cctx, _ := unpackArgSContext(ctx)
	chandler, _ := unpackArgSDocumentHandler(handler)
	C.fz_register_document_handler(cctx, chandler)
	packSDocumentHandler(handler, chandler)
	packSContext(ctx, cctx)
}

// RegisterDocumentHandlers function as declared in fitz/document.h:299
func RegisterDocumentHandlers(ctx []Context) {
	cctx, _ := unpackArgSContext(ctx)
	C.fz_register_document_handlers(cctx)
	packSContext(ctx, cctx)
}

// RecognizeDocument function as declared in fitz/document.h:308
func RecognizeDocument(ctx []Context, magic string) *DocumentHandler {
	cctx, _ := unpackArgSContext(ctx)
	cmagic, _ := unpackPCharString(magic)
	__ret := C.fz_recognize_document(cctx, cmagic)
	packSContext(ctx, cctx)
	__v := NewDocumentHandlerRef(unsafe.Pointer(__ret))
	return __v
}

// OpenDocument function as declared in fitz/document.h:322
func OpenDocument(ctx []Context, filename string) *Document {
	cctx, _ := unpackArgSContext(ctx)
	cfilename, _ := unpackPCharString(filename)
	__ret := C.fz_open_document(cctx, cfilename)
	packSContext(ctx, cctx)
	__v := NewDocumentRef(unsafe.Pointer(__ret))
	return __v
}

// OpenDocumentWithStream function as declared in fitz/document.h:332
func OpenDocumentWithStream(ctx []Context, magic string, stream []Stream) *Document {
	cctx, _ := unpackArgSContext(ctx)
	cmagic, _ := unpackPCharString(magic)
	cstream, _ := unpackArgSStream(stream)
	__ret := C.fz_open_document_with_stream(cctx, cmagic, cstream)
	packSStream(stream, cstream)
	packSContext(ctx, cctx)
	__v := NewDocumentRef(unsafe.Pointer(__ret))
	return __v
}

// NewDocumentOfSize function as declared in fitz/document.h:337
func NewDocumentOfSize(ctx []Context, size int32) unsafe.Pointer {
	cctx, _ := unpackArgSContext(ctx)
	csize, _ := (C.int)(size), cgoAllocsUnknown
	__ret := C.fz_new_document_of_size(cctx, csize)
	packSContext(ctx, cctx)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// KeepDocument function as declared in fitz/document.h:344
func KeepDocument(ctx []Context, doc []Document) *Document {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.fz_keep_document(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewDocumentRef(unsafe.Pointer(__ret))
	return __v
}

// DropDocument function as declared in fitz/document.h:353
func DropDocument(ctx []Context, doc []Document) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	C.fz_drop_document(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// NeedsPassword function as declared in fitz/document.h:359
func NeedsPassword(ctx []Context, doc []Document) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.fz_needs_password(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// AuthenticatePassword function as declared in fitz/document.h:378
func AuthenticatePassword(ctx []Context, doc []Document, password string) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cpassword, _ := unpackPCharString(password)
	__ret := C.fz_authenticate_password(cctx, cdoc, cpassword)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// LoadOutline function as declared in fitz/document.h:385
func LoadOutline(ctx []Context, doc []Document) *Outline {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.fz_load_outline(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewOutlineRef(unsafe.Pointer(__ret))
	return __v
}

// IsDocumentReflowable function as declared in fitz/document.h:392
func IsDocumentReflowable(ctx []Context, doc []Document) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.fz_is_document_reflowable(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// LayoutDocument function as declared in fitz/document.h:400
func LayoutDocument(ctx []Context, doc []Document, w float32, h float32, em float32) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cw, _ := (C.float)(w), cgoAllocsUnknown
	ch, _ := (C.float)(h), cgoAllocsUnknown
	cem, _ := (C.float)(em), cgoAllocsUnknown
	C.fz_layout_document(cctx, cdoc, cw, ch, cem)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// MakeBookmark function as declared in fitz/document.h:407
func MakeBookmark(ctx []Context, doc []Document, page int32) Bookmark {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cpage, _ := (C.int)(page), cgoAllocsUnknown
	__ret := C.fz_make_bookmark(cctx, cdoc, cpage)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (Bookmark)(__ret)
	return __v
}

// LookupBookmark function as declared in fitz/document.h:412
func LookupBookmark(ctx []Context, doc []Document, mark Bookmark) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cmark, _ := (C.fz_bookmark)(mark), cgoAllocsUnknown
	__ret := C.fz_lookup_bookmark(cctx, cdoc, cmark)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// CountPages function as declared in fitz/document.h:419
func CountPages(ctx []Context, doc []Document) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.fz_count_pages(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ResolveLink function as declared in fitz/document.h:428
func ResolveLink(ctx []Context, doc []Document, uri string, xp []float32, yp []float32) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	curi, _ := unpackPCharString(uri)
	cxp, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&xp)).Data)), cgoAllocsUnknown
	cyp, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&yp)).Data)), cgoAllocsUnknown
	__ret := C.fz_resolve_link(cctx, cdoc, curi, cxp, cyp)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// LoadPage function as declared in fitz/document.h:439
func LoadPage(ctx []Context, doc []Document, number int32) *Page {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cnumber, _ := (C.int)(number), cgoAllocsUnknown
	__ret := C.fz_load_page(cctx, cdoc, cnumber)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewPageRef(unsafe.Pointer(__ret))
	return __v
}

// LoadLinks function as declared in fitz/document.h:451
func LoadLinks(ctx []Context, page []Page) *Link {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	__ret := C.fz_load_links(cctx, cpage)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
	__v := NewLinkRef(unsafe.Pointer(__ret))
	return __v
}

// NewPageOfSize function as declared in fitz/document.h:456
func NewPageOfSize(ctx []Context, size int32) *Page {
	cctx, _ := unpackArgSContext(ctx)
	csize, _ := (C.int)(size), cgoAllocsUnknown
	__ret := C.fz_new_page_of_size(cctx, csize)
	packSContext(ctx, cctx)
	__v := NewPageRef(unsafe.Pointer(__ret))
	return __v
}

// BoundPage function as declared in fitz/document.h:465
func BoundPage(ctx []Context, page []Page, rect []Rect) *Rect {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	crect, _ := unpackArgSRect(rect)
	__ret := C.fz_bound_page(cctx, cpage, crect)
	packSRect(rect, crect)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
	__v := NewRectRef(unsafe.Pointer(__ret))
	return __v
}

// RunPage function as declared in fitz/document.h:486
func RunPage(ctx []Context, page []Page, dev []Device, transform []Matrix, cookie []Cookie) {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	cdev, _ := unpackArgSDevice(dev)
	ctransform, _ := unpackArgSMatrix(transform)
	ccookie, _ := unpackArgSCookie(cookie)
	C.fz_run_page(cctx, cpage, cdev, ctransform, ccookie)
	packSCookie(cookie, ccookie)
	packSMatrix(transform, ctransform)
	packSDevice(dev, cdev)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
}

// RunPageContents function as declared in fitz/document.h:508
func RunPageContents(ctx []Context, page []Page, dev []Device, transform []Matrix, cookie []Cookie) {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	cdev, _ := unpackArgSDevice(dev)
	ctransform, _ := unpackArgSMatrix(transform)
	ccookie, _ := unpackArgSCookie(cookie)
	C.fz_run_page_contents(cctx, cpage, cdev, ctransform, ccookie)
	packSCookie(cookie, ccookie)
	packSMatrix(transform, ctransform)
	packSDevice(dev, cdev)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
}

// RunAnnot function as declared in fitz/document.h:531
func RunAnnot(ctx []Context, annot []Annot, dev []Device, transform []Matrix, cookie []Cookie) {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	cdev, _ := unpackArgSDevice(dev)
	ctransform, _ := unpackArgSMatrix(transform)
	ccookie, _ := unpackArgSCookie(cookie)
	C.fz_run_annot(cctx, cannot, cdev, ctransform, ccookie)
	packSCookie(cookie, ccookie)
	packSMatrix(transform, ctransform)
	packSDevice(dev, cdev)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
}

// KeepPage function as declared in fitz/document.h:536
func KeepPage(ctx []Context, page []Page) *Page {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	__ret := C.fz_keep_page(cctx, cpage)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
	__v := NewPageRef(unsafe.Pointer(__ret))
	return __v
}

// DropPage function as declared in fitz/document.h:541
func DropPage(ctx []Context, page []Page) {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	C.fz_drop_page(cctx, cpage)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
}

// PagePresentation function as declared in fitz/document.h:554
func PagePresentation(ctx []Context, page []Page, transition []Transition, duration []float32) *Transition {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	ctransition, _ := unpackArgSTransition(transition)
	cduration, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&duration)).Data)), cgoAllocsUnknown
	__ret := C.fz_page_presentation(cctx, cpage, ctransition, cduration)
	packSTransition(transition, ctransition)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
	__v := NewTransitionRef(unsafe.Pointer(__ret))
	return __v
}

// HasPermission function as declared in fitz/document.h:559
func HasPermission(ctx []Context, doc []Document, p Permission) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cp, _ := (C.fz_permission)(p), cgoAllocsUnknown
	__ret := C.fz_has_permission(cctx, cdoc, cp)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// LookupMetadata function as declared in fitz/document.h:589
func LookupMetadata(ctx []Context, doc []Document, key string, buf []byte, size int32) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	ckey, _ := unpackPCharString(key)
	cbuf, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	csize, _ := (C.int)(size), cgoAllocsUnknown
	__ret := C.fz_lookup_metadata(cctx, cdoc, ckey, cbuf, csize)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// DocumentOutputIntent function as declared in fitz/document.h:600
func DocumentOutputIntent(ctx []Context, doc []Document) *Colorspace {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.fz_document_output_intent(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Colorspace)(unsafe.Pointer(&__ret))
	return __v
}

// PageSeparations function as declared in fitz/document.h:610
func PageSeparations(ctx []Context, page []Page) *Separations {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	__ret := C.fz_page_separations(cctx, cpage)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
	__v := *(**Separations)(unsafe.Pointer(&__ret))
	return __v
}

// SaveGproof function as declared in fitz/document.h:628
func SaveGproof(ctx []Context, docFilename string, doc []Document, filename string, res int32, printProfile string, displayProfile string) {
	cctx, _ := unpackArgSContext(ctx)
	cdocFilename, _ := unpackPCharString(docFilename)
	cdoc, _ := unpackArgSDocument(doc)
	cfilename, _ := unpackPCharString(filename)
	cres, _ := (C.int)(res), cgoAllocsUnknown
	cprintProfile, _ := unpackPCharString(printProfile)
	cdisplayProfile, _ := unpackPCharString(displayProfile)
	C.fz_save_gproof(cctx, cdocFilename, cdoc, cfilename, cres, cprintProfile, cdisplayProfile)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// NewAnnotOfSize function as declared in fitz/annotation.h:12
func NewAnnotOfSize(ctx []Context, size int32) *Annot {
	cctx, _ := unpackArgSContext(ctx)
	csize, _ := (C.int)(size), cgoAllocsUnknown
	__ret := C.fz_new_annot_of_size(cctx, csize)
	packSContext(ctx, cctx)
	__v := NewAnnotRef(unsafe.Pointer(__ret))
	return __v
}

// KeepAnnot function as declared in fitz/annotation.h:20
func KeepAnnot(ctx []Context, annot []Annot) *Annot {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	__ret := C.fz_keep_annot(cctx, cannot)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
	__v := NewAnnotRef(unsafe.Pointer(__ret))
	return __v
}

// DropAnnot function as declared in fitz/annotation.h:26
func DropAnnot(ctx []Context, annot []Annot) {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	C.fz_drop_annot(cctx, cannot)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
}

// FirstAnnot function as declared in fitz/annotation.h:31
func FirstAnnot(ctx []Context, page []Page) *Annot {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	__ret := C.fz_first_annot(cctx, cpage)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
	__v := NewAnnotRef(unsafe.Pointer(__ret))
	return __v
}

// NextAnnot function as declared in fitz/annotation.h:36
func NextAnnot(ctx []Context, annot []Annot) *Annot {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	__ret := C.fz_next_annot(cctx, cannot)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
	__v := NewAnnotRef(unsafe.Pointer(__ret))
	return __v
}

// BoundAnnot function as declared in fitz/annotation.h:41
func BoundAnnot(ctx []Context, annot []Annot, rect []Rect) *Rect {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	crect, _ := unpackArgSRect(rect)
	__ret := C.fz_bound_annot(cctx, cannot, crect)
	packSRect(rect, crect)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
	__v := NewRectRef(unsafe.Pointer(__ret))
	return __v
}

// NewDisplayListFromPage function as declared in fitz/util.h:15
func NewDisplayListFromPage(ctx []Context, page []Page) *DisplayList {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	__ret := C.fz_new_display_list_from_page(cctx, cpage)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
	__v := *(**DisplayList)(unsafe.Pointer(&__ret))
	return __v
}

// NewDisplayListFromPageNumber function as declared in fitz/util.h:16
func NewDisplayListFromPageNumber(ctx []Context, doc []Document, number int32) *DisplayList {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cnumber, _ := (C.int)(number), cgoAllocsUnknown
	__ret := C.fz_new_display_list_from_page_number(cctx, cdoc, cnumber)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**DisplayList)(unsafe.Pointer(&__ret))
	return __v
}

// NewDisplayListFromPageContents function as declared in fitz/util.h:17
func NewDisplayListFromPageContents(ctx []Context, page []Page) *DisplayList {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	__ret := C.fz_new_display_list_from_page_contents(cctx, cpage)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
	__v := *(**DisplayList)(unsafe.Pointer(&__ret))
	return __v
}

// NewDisplayListFromAnnot function as declared in fitz/util.h:18
func NewDisplayListFromAnnot(ctx []Context, annot []Annot) *DisplayList {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	__ret := C.fz_new_display_list_from_annot(cctx, cannot)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
	__v := *(**DisplayList)(unsafe.Pointer(&__ret))
	return __v
}

// NewPixmapFromDisplayList function as declared in fitz/util.h:23
func NewPixmapFromDisplayList(ctx []Context, list []DisplayList, ctm []Matrix, cs []Colorspace, alpha int32) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	clist, _ := (*C.fz_display_list)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&list)).Data)), cgoAllocsUnknown
	cctm, _ := unpackArgSMatrix(ctm)
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	calpha, _ := (C.int)(alpha), cgoAllocsUnknown
	__ret := C.fz_new_pixmap_from_display_list(cctx, clist, cctm, ccs, calpha)
	packSMatrix(ctm, cctm)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// NewPixmapFromPage function as declared in fitz/util.h:24
func NewPixmapFromPage(ctx []Context, page []Page, ctm []Matrix, cs []Colorspace, alpha int32) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	cctm, _ := unpackArgSMatrix(ctm)
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	calpha, _ := (C.int)(alpha), cgoAllocsUnknown
	__ret := C.fz_new_pixmap_from_page(cctx, cpage, cctm, ccs, calpha)
	packSMatrix(ctm, cctm)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// NewPixmapFromPageNumber function as declared in fitz/util.h:25
func NewPixmapFromPageNumber(ctx []Context, doc []Document, number int32, ctm []Matrix, cs []Colorspace, alpha int32) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cnumber, _ := (C.int)(number), cgoAllocsUnknown
	cctm, _ := unpackArgSMatrix(ctm)
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	calpha, _ := (C.int)(alpha), cgoAllocsUnknown
	__ret := C.fz_new_pixmap_from_page_number(cctx, cdoc, cnumber, cctm, ccs, calpha)
	packSMatrix(ctm, cctm)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// NewPixmapFromPageContents function as declared in fitz/util.h:30
func NewPixmapFromPageContents(ctx []Context, page []Page, ctm []Matrix, cs []Colorspace, alpha int32) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	cctm, _ := unpackArgSMatrix(ctm)
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	calpha, _ := (C.int)(alpha), cgoAllocsUnknown
	__ret := C.fz_new_pixmap_from_page_contents(cctx, cpage, cctm, ccs, calpha)
	packSMatrix(ctm, cctm)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// NewPixmapFromAnnot function as declared in fitz/util.h:36
func NewPixmapFromAnnot(ctx []Context, annot []Annot, ctm []Matrix, cs []Colorspace, alpha int32) *Pixmap {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	cctm, _ := unpackArgSMatrix(ctm)
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	calpha, _ := (C.int)(alpha), cgoAllocsUnknown
	__ret := C.fz_new_pixmap_from_annot(cctx, cannot, cctm, ccs, calpha)
	packSMatrix(ctm, cctm)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
	__v := NewPixmapRef(unsafe.Pointer(__ret))
	return __v
}

// NewStextPageFromPage function as declared in fitz/util.h:41
func NewStextPageFromPage(ctx []Context, page []Page, options []StextOptions) *StextPage {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	coptions, _ := unpackArgSStextOptions(options)
	__ret := C.fz_new_stext_page_from_page(cctx, cpage, coptions)
	packSStextOptions(options, coptions)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
	__v := NewStextPageRef(unsafe.Pointer(__ret))
	return __v
}

// NewStextPageFromPageNumber function as declared in fitz/util.h:42
func NewStextPageFromPageNumber(ctx []Context, doc []Document, number int32, options []StextOptions) *StextPage {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cnumber, _ := (C.int)(number), cgoAllocsUnknown
	coptions, _ := unpackArgSStextOptions(options)
	__ret := C.fz_new_stext_page_from_page_number(cctx, cdoc, cnumber, coptions)
	packSStextOptions(options, coptions)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewStextPageRef(unsafe.Pointer(__ret))
	return __v
}

// NewStextPageFromDisplayList function as declared in fitz/util.h:43
func NewStextPageFromDisplayList(ctx []Context, list []DisplayList, options []StextOptions) *StextPage {
	cctx, _ := unpackArgSContext(ctx)
	clist, _ := (*C.fz_display_list)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&list)).Data)), cgoAllocsUnknown
	coptions, _ := unpackArgSStextOptions(options)
	__ret := C.fz_new_stext_page_from_display_list(cctx, clist, coptions)
	packSStextOptions(options, coptions)
	packSContext(ctx, cctx)
	__v := NewStextPageRef(unsafe.Pointer(__ret))
	return __v
}

// NewBufferFromStextPage function as declared in fitz/util.h:50
func NewBufferFromStextPage(ctx []Context, text []StextPage, sel []Rect, crlf int32) *Buffer {
	cctx, _ := unpackArgSContext(ctx)
	ctext, _ := unpackArgSStextPage(text)
	csel, _ := unpackArgSRect(sel)
	ccrlf, _ := (C.int)(crlf), cgoAllocsUnknown
	__ret := C.fz_new_buffer_from_stext_page(cctx, ctext, csel, ccrlf)
	packSRect(sel, csel)
	packSStextPage(text, ctext)
	packSContext(ctx, cctx)
	__v := *(**Buffer)(unsafe.Pointer(&__ret))
	return __v
}

// NewBufferFromPage function as declared in fitz/util.h:51
func NewBufferFromPage(ctx []Context, page []Page, sel []Rect, crlf int32, options []StextOptions) *Buffer {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	csel, _ := unpackArgSRect(sel)
	ccrlf, _ := (C.int)(crlf), cgoAllocsUnknown
	coptions, _ := unpackArgSStextOptions(options)
	__ret := C.fz_new_buffer_from_page(cctx, cpage, csel, ccrlf, coptions)
	packSStextOptions(options, coptions)
	packSRect(sel, csel)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
	__v := *(**Buffer)(unsafe.Pointer(&__ret))
	return __v
}

// NewBufferFromPageNumber function as declared in fitz/util.h:52
func NewBufferFromPageNumber(ctx []Context, doc []Document, number int32, sel []Rect, crlf int32, options []StextOptions) *Buffer {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cnumber, _ := (C.int)(number), cgoAllocsUnknown
	csel, _ := unpackArgSRect(sel)
	ccrlf, _ := (C.int)(crlf), cgoAllocsUnknown
	coptions, _ := unpackArgSStextOptions(options)
	__ret := C.fz_new_buffer_from_page_number(cctx, cdoc, cnumber, csel, ccrlf, coptions)
	packSStextOptions(options, coptions)
	packSRect(sel, csel)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Buffer)(unsafe.Pointer(&__ret))
	return __v
}

// NewBufferFromDisplayList function as declared in fitz/util.h:53
func NewBufferFromDisplayList(ctx []Context, list []DisplayList, sel []Rect, crlf int32, options []StextOptions) *Buffer {
	cctx, _ := unpackArgSContext(ctx)
	clist, _ := (*C.fz_display_list)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&list)).Data)), cgoAllocsUnknown
	csel, _ := unpackArgSRect(sel)
	ccrlf, _ := (C.int)(crlf), cgoAllocsUnknown
	coptions, _ := unpackArgSStextOptions(options)
	__ret := C.fz_new_buffer_from_display_list(cctx, clist, csel, ccrlf, coptions)
	packSStextOptions(options, coptions)
	packSRect(sel, csel)
	packSContext(ctx, cctx)
	__v := *(**Buffer)(unsafe.Pointer(&__ret))
	return __v
}

// SearchPage function as declared in fitz/util.h:60
func SearchPage(ctx []Context, page []Page, needle string, hitBbox []Rect, hitMax int32) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	cneedle, _ := unpackPCharString(needle)
	chitBbox, _ := unpackArgSRect(hitBbox)
	chitMax, _ := (C.int)(hitMax), cgoAllocsUnknown
	__ret := C.fz_search_page(cctx, cpage, cneedle, chitBbox, chitMax)
	packSRect(hitBbox, chitBbox)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// SearchPageNumber function as declared in fitz/util.h:61
func SearchPageNumber(ctx []Context, doc []Document, number int32, needle string, hitBbox []Rect, hitMax int32) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cnumber, _ := (C.int)(number), cgoAllocsUnknown
	cneedle, _ := unpackPCharString(needle)
	chitBbox, _ := unpackArgSRect(hitBbox)
	chitMax, _ := (C.int)(hitMax), cgoAllocsUnknown
	__ret := C.fz_search_page_number(cctx, cdoc, cnumber, cneedle, chitBbox, chitMax)
	packSRect(hitBbox, chitBbox)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// SearchDisplayList function as declared in fitz/util.h:62
func SearchDisplayList(ctx []Context, list []DisplayList, needle string, hitBbox []Rect, hitMax int32) int32 {
	cctx, _ := unpackArgSContext(ctx)
	clist, _ := (*C.fz_display_list)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&list)).Data)), cgoAllocsUnknown
	cneedle, _ := unpackPCharString(needle)
	chitBbox, _ := unpackArgSRect(hitBbox)
	chitMax, _ := (C.int)(hitMax), cgoAllocsUnknown
	__ret := C.fz_search_display_list(cctx, clist, cneedle, chitBbox, chitMax)
	packSRect(hitBbox, chitBbox)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// NewDisplayListFromSvg function as declared in fitz/util.h:67
func NewDisplayListFromSvg(ctx []Context, buf []Buffer, w []float32, h []float32) *DisplayList {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	cw, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&w)).Data)), cgoAllocsUnknown
	ch, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&h)).Data)), cgoAllocsUnknown
	__ret := C.fz_new_display_list_from_svg(cctx, cbuf, cw, ch)
	packSContext(ctx, cctx)
	__v := *(**DisplayList)(unsafe.Pointer(&__ret))
	return __v
}

// NewImageFromSvg function as declared in fitz/util.h:72
func NewImageFromSvg(ctx []Context, buf []Buffer) *Image {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	__ret := C.fz_new_image_from_svg(cctx, cbuf)
	packSContext(ctx, cctx)
	__v := NewImageRef(unsafe.Pointer(__ret))
	return __v
}

// WriteImageAsDataUri function as declared in fitz/util.h:77
func WriteImageAsDataUri(ctx []Context, out []Output, image []Image) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cimage, _ := unpackArgSImage(image)
	C.fz_write_image_as_data_uri(cctx, cout, cimage)
	packSImage(image, cimage)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// NewDocumentWriterOfSize function as declared in fitz/writer.h:69
func NewDocumentWriterOfSize(ctx []Context, size uint, beginPage DocumentWriterBeginPageFn, endPage DocumentWriterEndPageFn, close DocumentWriterCloseWriterFn, drop DocumentWriterDropWriterFn) *DocumentWriter {
	cctx, _ := unpackArgSContext(ctx)
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	cbeginPage, _ := beginPage.PassRef()
	cendPage, _ := endPage.PassRef()
	cclose, _ := close.PassRef()
	cdrop, _ := drop.PassRef()
	__ret := C.fz_new_document_writer_of_size(cctx, csize, cbeginPage, cendPage, cclose, cdrop)
	packSContext(ctx, cctx)
	__v := NewDocumentWriterRef(unsafe.Pointer(__ret))
	return __v
}

// HasOption function as declared in fitz/writer.h:78
func HasOption(ctx []Context, opts string, key string, val []string) int32 {
	cctx, _ := unpackArgSContext(ctx)
	copts, _ := unpackPCharString(opts)
	ckey, _ := unpackPCharString(key)
	cval, _ := unpackArgSString(val)
	__ret := C.fz_has_option(cctx, copts, ckey, cval)
	packSString(val, cval)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// OptionEq function as declared in fitz/writer.h:79
func OptionEq(a string, b string) int32 {
	ca, _ := unpackPCharString(a)
	cb, _ := unpackPCharString(b)
	__ret := C.fz_option_eq(ca, cb)
	__v := (int32)(__ret)
	return __v
}

// NewDocumentWriter function as declared in fitz/writer.h:93
func NewDocumentWriter(ctx []Context, path string, format string, options string) *DocumentWriter {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := unpackPCharString(path)
	cformat, _ := unpackPCharString(format)
	coptions, _ := unpackPCharString(options)
	__ret := C.fz_new_document_writer(cctx, cpath, cformat, coptions)
	packSContext(ctx, cctx)
	__v := NewDocumentWriterRef(unsafe.Pointer(__ret))
	return __v
}

// New_Writer function as declared in fitz/writer.h:95
func New_Writer(ctx []Context, path string, options string) *DocumentWriter {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := unpackPCharString(path)
	coptions, _ := unpackPCharString(options)
	__ret := C.fz_new_pdf_writer(cctx, cpath, coptions)
	packSContext(ctx, cctx)
	__v := NewDocumentWriterRef(unsafe.Pointer(__ret))
	return __v
}

// NewSvgWriter function as declared in fitz/writer.h:96
func NewSvgWriter(ctx []Context, path string, options string) *DocumentWriter {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := unpackPCharString(path)
	coptions, _ := unpackPCharString(options)
	__ret := C.fz_new_svg_writer(cctx, cpath, coptions)
	packSContext(ctx, cctx)
	__v := NewDocumentWriterRef(unsafe.Pointer(__ret))
	return __v
}

// NewTextWriter function as declared in fitz/writer.h:98
func NewTextWriter(ctx []Context, format string, path string, options string) *DocumentWriter {
	cctx, _ := unpackArgSContext(ctx)
	cformat, _ := unpackPCharString(format)
	cpath, _ := unpackPCharString(path)
	coptions, _ := unpackPCharString(options)
	__ret := C.fz_new_text_writer(cctx, cformat, cpath, coptions)
	packSContext(ctx, cctx)
	__v := NewDocumentWriterRef(unsafe.Pointer(__ret))
	return __v
}

// NewPsWriter function as declared in fitz/writer.h:100
func NewPsWriter(ctx []Context, path string, options string) *DocumentWriter {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := unpackPCharString(path)
	coptions, _ := unpackPCharString(options)
	__ret := C.fz_new_ps_writer(cctx, cpath, coptions)
	packSContext(ctx, cctx)
	__v := NewDocumentWriterRef(unsafe.Pointer(__ret))
	return __v
}

// NewPclWriter function as declared in fitz/writer.h:101
func NewPclWriter(ctx []Context, path string, options string) *DocumentWriter {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := unpackPCharString(path)
	coptions, _ := unpackPCharString(options)
	__ret := C.fz_new_pcl_writer(cctx, cpath, coptions)
	packSContext(ctx, cctx)
	__v := NewDocumentWriterRef(unsafe.Pointer(__ret))
	return __v
}

// NewPwgWriter function as declared in fitz/writer.h:102
func NewPwgWriter(ctx []Context, path string, options string) *DocumentWriter {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := unpackPCharString(path)
	coptions, _ := unpackPCharString(options)
	__ret := C.fz_new_pwg_writer(cctx, cpath, coptions)
	packSContext(ctx, cctx)
	__v := NewDocumentWriterRef(unsafe.Pointer(__ret))
	return __v
}

// NewCbzWriter function as declared in fitz/writer.h:104
func NewCbzWriter(ctx []Context, path string, options string) *DocumentWriter {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := unpackPCharString(path)
	coptions, _ := unpackPCharString(options)
	__ret := C.fz_new_cbz_writer(cctx, cpath, coptions)
	packSContext(ctx, cctx)
	__v := NewDocumentWriterRef(unsafe.Pointer(__ret))
	return __v
}

// NewPngPixmapWriter function as declared in fitz/writer.h:105
func NewPngPixmapWriter(ctx []Context, path string, options string) *DocumentWriter {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := unpackPCharString(path)
	coptions, _ := unpackPCharString(options)
	__ret := C.fz_new_png_pixmap_writer(cctx, cpath, coptions)
	packSContext(ctx, cctx)
	__v := NewDocumentWriterRef(unsafe.Pointer(__ret))
	return __v
}

// NewTgaPixmapWriter function as declared in fitz/writer.h:106
func NewTgaPixmapWriter(ctx []Context, path string, options string) *DocumentWriter {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := unpackPCharString(path)
	coptions, _ := unpackPCharString(options)
	__ret := C.fz_new_tga_pixmap_writer(cctx, cpath, coptions)
	packSContext(ctx, cctx)
	__v := NewDocumentWriterRef(unsafe.Pointer(__ret))
	return __v
}

// NewPamPixmapWriter function as declared in fitz/writer.h:107
func NewPamPixmapWriter(ctx []Context, path string, options string) *DocumentWriter {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := unpackPCharString(path)
	coptions, _ := unpackPCharString(options)
	__ret := C.fz_new_pam_pixmap_writer(cctx, cpath, coptions)
	packSContext(ctx, cctx)
	__v := NewDocumentWriterRef(unsafe.Pointer(__ret))
	return __v
}

// NewPnmPixmapWriter function as declared in fitz/writer.h:108
func NewPnmPixmapWriter(ctx []Context, path string, options string) *DocumentWriter {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := unpackPCharString(path)
	coptions, _ := unpackPCharString(options)
	__ret := C.fz_new_pnm_pixmap_writer(cctx, cpath, coptions)
	packSContext(ctx, cctx)
	__v := NewDocumentWriterRef(unsafe.Pointer(__ret))
	return __v
}

// NewPgmPixmapWriter function as declared in fitz/writer.h:109
func NewPgmPixmapWriter(ctx []Context, path string, options string) *DocumentWriter {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := unpackPCharString(path)
	coptions, _ := unpackPCharString(options)
	__ret := C.fz_new_pgm_pixmap_writer(cctx, cpath, coptions)
	packSContext(ctx, cctx)
	__v := NewDocumentWriterRef(unsafe.Pointer(__ret))
	return __v
}

// NewPpmPixmapWriter function as declared in fitz/writer.h:110
func NewPpmPixmapWriter(ctx []Context, path string, options string) *DocumentWriter {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := unpackPCharString(path)
	coptions, _ := unpackPCharString(options)
	__ret := C.fz_new_ppm_pixmap_writer(cctx, cpath, coptions)
	packSContext(ctx, cctx)
	__v := NewDocumentWriterRef(unsafe.Pointer(__ret))
	return __v
}

// NewPbmPixmapWriter function as declared in fitz/writer.h:111
func NewPbmPixmapWriter(ctx []Context, path string, options string) *DocumentWriter {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := unpackPCharString(path)
	coptions, _ := unpackPCharString(options)
	__ret := C.fz_new_pbm_pixmap_writer(cctx, cpath, coptions)
	packSContext(ctx, cctx)
	__v := NewDocumentWriterRef(unsafe.Pointer(__ret))
	return __v
}

// NewPkmPixmapWriter function as declared in fitz/writer.h:112
func NewPkmPixmapWriter(ctx []Context, path string, options string) *DocumentWriter {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := unpackPCharString(path)
	coptions, _ := unpackPCharString(options)
	__ret := C.fz_new_pkm_pixmap_writer(cctx, cpath, coptions)
	packSContext(ctx, cctx)
	__v := NewDocumentWriterRef(unsafe.Pointer(__ret))
	return __v
}

// BeginPage function as declared in fitz/writer.h:122
func BeginPage(ctx []Context, wri []DocumentWriter, mediabox []Rect) *Device {
	cctx, _ := unpackArgSContext(ctx)
	cwri, _ := unpackArgSDocumentWriter(wri)
	cmediabox, _ := unpackArgSRect(mediabox)
	__ret := C.fz_begin_page(cctx, cwri, cmediabox)
	packSRect(mediabox, cmediabox)
	packSDocumentWriter(wri, cwri)
	packSContext(ctx, cctx)
	__v := NewDeviceRef(unsafe.Pointer(__ret))
	return __v
}

// EndPage function as declared in fitz/writer.h:128
func EndPage(ctx []Context, wri []DocumentWriter) {
	cctx, _ := unpackArgSContext(ctx)
	cwri, _ := unpackArgSDocumentWriter(wri)
	C.fz_end_page(cctx, cwri)
	packSDocumentWriter(wri, cwri)
	packSContext(ctx, cctx)
}

// CloseDocumentWriter function as declared in fitz/writer.h:137
func CloseDocumentWriter(ctx []Context, wri []DocumentWriter) {
	cctx, _ := unpackArgSContext(ctx)
	cwri, _ := unpackArgSDocumentWriter(wri)
	C.fz_close_document_writer(cctx, cwri)
	packSDocumentWriter(wri, cwri)
	packSContext(ctx, cctx)
}

// DropDocumentWriter function as declared in fitz/writer.h:147
func DropDocumentWriter(ctx []Context, wri []DocumentWriter) {
	cctx, _ := unpackArgSContext(ctx)
	cwri, _ := unpackArgSDocumentWriter(wri)
	C.fz_drop_document_writer(cctx, cwri)
	packSDocumentWriter(wri, cwri)
	packSContext(ctx, cctx)
}

// NewPixmapWriter function as declared in fitz/writer.h:149
func NewPixmapWriter(ctx []Context, path string, options string, defaultPath string, n int32, save *func(ctx []Context, pix []Pixmap, filename string)) *DocumentWriter {
	cctx, _ := unpackArgSContext(ctx)
	cpath, _ := unpackPCharString(path)
	coptions, _ := unpackPCharString(options)
	cdefaultPath, _ := unpackPCharString(defaultPath)
	cn, _ := (C.int)(n), cgoAllocsUnknown
	csave, _ := save.PassRef()
	__ret := C.fz_new_pixmap_writer(cctx, cpath, coptions, cdefaultPath, cn, csave)
	packSContext(ctx, cctx)
	__v := NewDocumentWriterRef(unsafe.Pointer(__ret))
	return __v
}

// NewBandWriterOfSize function as declared in fitz/band-writer.h:37
func NewBandWriterOfSize(ctx []Context, size uint, out []Output) *BandWriter {
	cctx, _ := unpackArgSContext(ctx)
	csize, _ := (C.size_t)(size), cgoAllocsUnknown
	cout, _ := unpackArgSOutput(out)
	__ret := C.fz_new_band_writer_of_size(cctx, csize, cout)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
	__v := NewBandWriterRef(unsafe.Pointer(__ret))
	return __v
}

// WriteHeader function as declared in fitz/band-writer.h:62
func WriteHeader(ctx []Context, writer []BandWriter, w int32, h int32, n int32, alpha int32, xres int32, yres int32, pagenum int32, cs []Colorspace, seps []Separations) {
	cctx, _ := unpackArgSContext(ctx)
	cwriter, _ := unpackArgSBandWriter(writer)
	cw, _ := (C.int)(w), cgoAllocsUnknown
	ch, _ := (C.int)(h), cgoAllocsUnknown
	cn, _ := (C.int)(n), cgoAllocsUnknown
	calpha, _ := (C.int)(alpha), cgoAllocsUnknown
	cxres, _ := (C.int)(xres), cgoAllocsUnknown
	cyres, _ := (C.int)(yres), cgoAllocsUnknown
	cpagenum, _ := (C.int)(pagenum), cgoAllocsUnknown
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	cseps, _ := (*C.fz_separations)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&seps)).Data)), cgoAllocsUnknown
	C.fz_write_header(cctx, cwriter, cw, ch, cn, calpha, cxres, cyres, cpagenum, ccs, cseps)
	packSBandWriter(writer, cwriter)
	packSContext(ctx, cctx)
}

// WriteBand function as declared in fitz/band-writer.h:76
func WriteBand(ctx []Context, writer []BandWriter, stride int32, bandHeight int32, samples string) {
	cctx, _ := unpackArgSContext(ctx)
	cwriter, _ := unpackArgSBandWriter(writer)
	cstride, _ := (C.int)(stride), cgoAllocsUnknown
	cbandHeight, _ := (C.int)(bandHeight), cgoAllocsUnknown
	csamples, _ := unpackPUcharString(samples)
	C.fz_write_band(cctx, cwriter, cstride, cbandHeight, csamples)
	packSBandWriter(writer, cwriter)
	packSContext(ctx, cctx)
}

// DropBandWriter function as declared in fitz/band-writer.h:78
func DropBandWriter(ctx []Context, writer []BandWriter) {
	cctx, _ := unpackArgSContext(ctx)
	cwriter, _ := unpackArgSBandWriter(writer)
	C.fz_drop_band_writer(cctx, cwriter)
	packSBandWriter(writer, cwriter)
	packSContext(ctx, cctx)
}

// SavePixmapAsPnm function as declared in fitz/output-pnm.h:14
func SavePixmapAsPnm(ctx []Context, pixmap []Pixmap, filename string) {
	cctx, _ := unpackArgSContext(ctx)
	cpixmap, _ := unpackArgSPixmap(pixmap)
	cfilename, _ := unpackPCharString(filename)
	C.fz_save_pixmap_as_pnm(cctx, cpixmap, cfilename)
	packSPixmap(pixmap, cpixmap)
	packSContext(ctx, cctx)
}

// WritePixmapAsPnm function as declared in fitz/output-pnm.h:16
func WritePixmapAsPnm(ctx []Context, out []Output, pixmap []Pixmap) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cpixmap, _ := unpackArgSPixmap(pixmap)
	C.fz_write_pixmap_as_pnm(cctx, cout, cpixmap)
	packSPixmap(pixmap, cpixmap)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// NewPnmBandWriter function as declared in fitz/output-pnm.h:18
func NewPnmBandWriter(ctx []Context, out []Output) *BandWriter {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	__ret := C.fz_new_pnm_band_writer(cctx, cout)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
	__v := NewBandWriterRef(unsafe.Pointer(__ret))
	return __v
}

// SavePixmapAsPam function as declared in fitz/output-pnm.h:23
func SavePixmapAsPam(ctx []Context, pixmap []Pixmap, filename string) {
	cctx, _ := unpackArgSContext(ctx)
	cpixmap, _ := unpackArgSPixmap(pixmap)
	cfilename, _ := unpackPCharString(filename)
	C.fz_save_pixmap_as_pam(cctx, cpixmap, cfilename)
	packSPixmap(pixmap, cpixmap)
	packSContext(ctx, cctx)
}

// WritePixmapAsPam function as declared in fitz/output-pnm.h:25
func WritePixmapAsPam(ctx []Context, out []Output, pixmap []Pixmap) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cpixmap, _ := unpackArgSPixmap(pixmap)
	C.fz_write_pixmap_as_pam(cctx, cout, cpixmap)
	packSPixmap(pixmap, cpixmap)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// NewPamBandWriter function as declared in fitz/output-pnm.h:27
func NewPamBandWriter(ctx []Context, out []Output) *BandWriter {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	__ret := C.fz_new_pam_band_writer(cctx, cout)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
	__v := NewBandWriterRef(unsafe.Pointer(__ret))
	return __v
}

// SaveBitmapAsPbm function as declared in fitz/output-pnm.h:32
func SaveBitmapAsPbm(ctx []Context, bitmap []Bitmap, filename string) {
	cctx, _ := unpackArgSContext(ctx)
	cbitmap, _ := unpackArgSBitmap(bitmap)
	cfilename, _ := unpackPCharString(filename)
	C.fz_save_bitmap_as_pbm(cctx, cbitmap, cfilename)
	packSBitmap(bitmap, cbitmap)
	packSContext(ctx, cctx)
}

// WriteBitmapAsPbm function as declared in fitz/output-pnm.h:34
func WriteBitmapAsPbm(ctx []Context, out []Output, bitmap []Bitmap) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cbitmap, _ := unpackArgSBitmap(bitmap)
	C.fz_write_bitmap_as_pbm(cctx, cout, cbitmap)
	packSBitmap(bitmap, cbitmap)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// NewPbmBandWriter function as declared in fitz/output-pnm.h:36
func NewPbmBandWriter(ctx []Context, out []Output) *BandWriter {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	__ret := C.fz_new_pbm_band_writer(cctx, cout)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
	__v := NewBandWriterRef(unsafe.Pointer(__ret))
	return __v
}

// SavePixmapAsPbm function as declared in fitz/output-pnm.h:38
func SavePixmapAsPbm(ctx []Context, pixmap []Pixmap, filename string) {
	cctx, _ := unpackArgSContext(ctx)
	cpixmap, _ := unpackArgSPixmap(pixmap)
	cfilename, _ := unpackPCharString(filename)
	C.fz_save_pixmap_as_pbm(cctx, cpixmap, cfilename)
	packSPixmap(pixmap, cpixmap)
	packSContext(ctx, cctx)
}

// SaveBitmapAsPkm function as declared in fitz/output-pnm.h:43
func SaveBitmapAsPkm(ctx []Context, bitmap []Bitmap, filename string) {
	cctx, _ := unpackArgSContext(ctx)
	cbitmap, _ := unpackArgSBitmap(bitmap)
	cfilename, _ := unpackPCharString(filename)
	C.fz_save_bitmap_as_pkm(cctx, cbitmap, cfilename)
	packSBitmap(bitmap, cbitmap)
	packSContext(ctx, cctx)
}

// WriteBitmapAsPkm function as declared in fitz/output-pnm.h:45
func WriteBitmapAsPkm(ctx []Context, out []Output, bitmap []Bitmap) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cbitmap, _ := unpackArgSBitmap(bitmap)
	C.fz_write_bitmap_as_pkm(cctx, cout, cbitmap)
	packSBitmap(bitmap, cbitmap)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// NewPkmBandWriter function as declared in fitz/output-pnm.h:47
func NewPkmBandWriter(ctx []Context, out []Output) *BandWriter {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	__ret := C.fz_new_pkm_band_writer(cctx, cout)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
	__v := NewBandWriterRef(unsafe.Pointer(__ret))
	return __v
}

// SavePixmapAsPkm function as declared in fitz/output-pnm.h:49
func SavePixmapAsPkm(ctx []Context, pixmap []Pixmap, filename string) {
	cctx, _ := unpackArgSContext(ctx)
	cpixmap, _ := unpackArgSPixmap(pixmap)
	cfilename, _ := unpackPCharString(filename)
	C.fz_save_pixmap_as_pkm(cctx, cpixmap, cfilename)
	packSPixmap(pixmap, cpixmap)
	packSContext(ctx, cctx)
}

// SavePixmapAsPng function as declared in fitz/output-png.h:17
func SavePixmapAsPng(ctx []Context, pixmap []Pixmap, filename string) {
	cctx, _ := unpackArgSContext(ctx)
	cpixmap, _ := unpackArgSPixmap(pixmap)
	cfilename, _ := unpackPCharString(filename)
	C.fz_save_pixmap_as_png(cctx, cpixmap, cfilename)
	packSPixmap(pixmap, cpixmap)
	packSContext(ctx, cctx)
}

// WritePixmapAsPng function as declared in fitz/output-png.h:22
func WritePixmapAsPng(ctx []Context, out []Output, pixmap []Pixmap) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cpixmap, _ := unpackArgSPixmap(pixmap)
	C.fz_write_pixmap_as_png(cctx, cout, cpixmap)
	packSPixmap(pixmap, cpixmap)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// NewPngBandWriter function as declared in fitz/output-png.h:28
func NewPngBandWriter(ctx []Context, out []Output) *BandWriter {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	__ret := C.fz_new_png_band_writer(cctx, cout)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
	__v := NewBandWriterRef(unsafe.Pointer(__ret))
	return __v
}

// NewBufferFromImageAsPng function as declared in fitz/output-png.h:33
func NewBufferFromImageAsPng(ctx []Context, image []Image, colorParams []ColorParams) *Buffer {
	cctx, _ := unpackArgSContext(ctx)
	cimage, _ := unpackArgSImage(image)
	ccolorParams, _ := unpackArgSColorParams(colorParams)
	__ret := C.fz_new_buffer_from_image_as_png(cctx, cimage, ccolorParams)
	packSColorParams(colorParams, ccolorParams)
	packSImage(image, cimage)
	packSContext(ctx, cctx)
	__v := *(**Buffer)(unsafe.Pointer(&__ret))
	return __v
}

// NewBufferFromPixmapAsPng function as declared in fitz/output-png.h:34
func NewBufferFromPixmapAsPng(ctx []Context, pixmap []Pixmap, colorParams []ColorParams) *Buffer {
	cctx, _ := unpackArgSContext(ctx)
	cpixmap, _ := unpackArgSPixmap(pixmap)
	ccolorParams, _ := unpackArgSColorParams(colorParams)
	__ret := C.fz_new_buffer_from_pixmap_as_png(cctx, cpixmap, ccolorParams)
	packSColorParams(colorParams, ccolorParams)
	packSPixmap(pixmap, cpixmap)
	packSContext(ctx, cctx)
	__v := *(**Buffer)(unsafe.Pointer(&__ret))
	return __v
}

// SavePixmapAsPwg function as declared in fitz/output-pwg.h:65
func SavePixmapAsPwg(ctx []Context, pixmap []Pixmap, filename []byte, append int32, pwg []PwgOptions) {
	cctx, _ := unpackArgSContext(ctx)
	cpixmap, _ := unpackArgSPixmap(pixmap)
	cfilename, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&filename)).Data)), cgoAllocsUnknown
	cappend, _ := (C.int)(append), cgoAllocsUnknown
	cpwg, _ := unpackArgSPwgOptions(pwg)
	C.fz_save_pixmap_as_pwg(cctx, cpixmap, cfilename, cappend, cpwg)
	packSPwgOptions(pwg, cpwg)
	packSPixmap(pixmap, cpixmap)
	packSContext(ctx, cctx)
}

// SaveBitmapAsPwg function as declared in fitz/output-pwg.h:77
func SaveBitmapAsPwg(ctx []Context, bitmap []Bitmap, filename []byte, append int32, pwg []PwgOptions) {
	cctx, _ := unpackArgSContext(ctx)
	cbitmap, _ := unpackArgSBitmap(bitmap)
	cfilename, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&filename)).Data)), cgoAllocsUnknown
	cappend, _ := (C.int)(append), cgoAllocsUnknown
	cpwg, _ := unpackArgSPwgOptions(pwg)
	C.fz_save_bitmap_as_pwg(cctx, cbitmap, cfilename, cappend, cpwg)
	packSPwgOptions(pwg, cpwg)
	packSBitmap(bitmap, cbitmap)
	packSContext(ctx, cctx)
}

// WritePixmapAsPwg function as declared in fitz/output-pwg.h:82
func WritePixmapAsPwg(ctx []Context, out []Output, pixmap []Pixmap, pwg []PwgOptions) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cpixmap, _ := unpackArgSPixmap(pixmap)
	cpwg, _ := unpackArgSPwgOptions(pwg)
	C.fz_write_pixmap_as_pwg(cctx, cout, cpixmap, cpwg)
	packSPwgOptions(pwg, cpwg)
	packSPixmap(pixmap, cpixmap)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// WriteBitmapAsPwg function as declared in fitz/output-pwg.h:87
func WriteBitmapAsPwg(ctx []Context, out []Output, bitmap []Bitmap, pwg []PwgOptions) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cbitmap, _ := unpackArgSBitmap(bitmap)
	cpwg, _ := unpackArgSPwgOptions(pwg)
	C.fz_write_bitmap_as_pwg(cctx, cout, cbitmap, cpwg)
	packSPwgOptions(pwg, cpwg)
	packSBitmap(bitmap, cbitmap)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// WritePwgFileHeader function as declared in fitz/output-pwg.h:92
func WritePwgFileHeader(ctx []Context, out []Output) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	C.fz_write_pwg_file_header(cctx, cout)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// WritePixmapAsPwgPage function as declared in fitz/output-pwg.h:97
func WritePixmapAsPwgPage(ctx []Context, out []Output, pixmap []Pixmap, pwg []PwgOptions) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cpixmap, _ := unpackArgSPixmap(pixmap)
	cpwg, _ := unpackArgSPwgOptions(pwg)
	C.fz_write_pixmap_as_pwg_page(cctx, cout, cpixmap, cpwg)
	packSPwgOptions(pwg, cpwg)
	packSPixmap(pixmap, cpixmap)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// WriteBitmapAsPwgPage function as declared in fitz/output-pwg.h:102
func WriteBitmapAsPwgPage(ctx []Context, out []Output, bitmap []Bitmap, pwg []PwgOptions) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cbitmap, _ := unpackArgSBitmap(bitmap)
	cpwg, _ := unpackArgSPwgOptions(pwg)
	C.fz_write_bitmap_as_pwg_page(cctx, cout, cbitmap, cpwg)
	packSPwgOptions(pwg, cpwg)
	packSBitmap(bitmap, cbitmap)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// NewMonoPwgBandWriter function as declared in fitz/output-pwg.h:108
func NewMonoPwgBandWriter(ctx []Context, out []Output, pwg []PwgOptions) *BandWriter {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cpwg, _ := unpackArgSPwgOptions(pwg)
	__ret := C.fz_new_mono_pwg_band_writer(cctx, cout, cpwg)
	packSPwgOptions(pwg, cpwg)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
	__v := NewBandWriterRef(unsafe.Pointer(__ret))
	return __v
}

// NewPwgBandWriter function as declared in fitz/output-pwg.h:114
func NewPwgBandWriter(ctx []Context, out []Output, pwg []PwgOptions) *BandWriter {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cpwg, _ := unpackArgSPwgOptions(pwg)
	__ret := C.fz_new_pwg_band_writer(cctx, cout, cpwg)
	packSPwgOptions(pwg, cpwg)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
	__v := NewBandWriterRef(unsafe.Pointer(__ret))
	return __v
}

// PclPreset function as declared in fitz/output-pcl.h:57
func PclPreset(ctx []Context, opts []PclOptions, preset string) {
	cctx, _ := unpackArgSContext(ctx)
	copts, _ := unpackArgSPclOptions(opts)
	cpreset, _ := unpackPCharString(preset)
	C.fz_pcl_preset(cctx, copts, cpreset)
	packSPclOptions(opts, copts)
	packSContext(ctx, cctx)
}

// ParsePclOptions function as declared in fitz/output-pcl.h:78
func ParsePclOptions(ctx []Context, opts []PclOptions, args string) *PclOptions {
	cctx, _ := unpackArgSContext(ctx)
	copts, _ := unpackArgSPclOptions(opts)
	cargs, _ := unpackPCharString(args)
	__ret := C.fz_parse_pcl_options(cctx, copts, cargs)
	packSPclOptions(opts, copts)
	packSContext(ctx, cctx)
	__v := NewPclOptionsRef(unsafe.Pointer(__ret))
	return __v
}

// NewMonoPclBandWriter function as declared in fitz/output-pcl.h:80
func NewMonoPclBandWriter(ctx []Context, out []Output, options []PclOptions) *BandWriter {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	coptions, _ := unpackArgSPclOptions(options)
	__ret := C.fz_new_mono_pcl_band_writer(cctx, cout, coptions)
	packSPclOptions(options, coptions)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
	__v := NewBandWriterRef(unsafe.Pointer(__ret))
	return __v
}

// WriteBitmapAsPcl function as declared in fitz/output-pcl.h:81
func WriteBitmapAsPcl(ctx []Context, out []Output, bitmap []Bitmap, pcl []PclOptions) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cbitmap, _ := unpackArgSBitmap(bitmap)
	cpcl, _ := unpackArgSPclOptions(pcl)
	C.fz_write_bitmap_as_pcl(cctx, cout, cbitmap, cpcl)
	packSPclOptions(pcl, cpcl)
	packSBitmap(bitmap, cbitmap)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// SaveBitmapAsPcl function as declared in fitz/output-pcl.h:82
func SaveBitmapAsPcl(ctx []Context, bitmap []Bitmap, filename []byte, append int32, pcl []PclOptions) {
	cctx, _ := unpackArgSContext(ctx)
	cbitmap, _ := unpackArgSBitmap(bitmap)
	cfilename, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&filename)).Data)), cgoAllocsUnknown
	cappend, _ := (C.int)(append), cgoAllocsUnknown
	cpcl, _ := unpackArgSPclOptions(pcl)
	C.fz_save_bitmap_as_pcl(cctx, cbitmap, cfilename, cappend, cpcl)
	packSPclOptions(pcl, cpcl)
	packSBitmap(bitmap, cbitmap)
	packSContext(ctx, cctx)
}

// NewColorPclBandWriter function as declared in fitz/output-pcl.h:84
func NewColorPclBandWriter(ctx []Context, out []Output, options []PclOptions) *BandWriter {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	coptions, _ := unpackArgSPclOptions(options)
	__ret := C.fz_new_color_pcl_band_writer(cctx, cout, coptions)
	packSPclOptions(options, coptions)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
	__v := NewBandWriterRef(unsafe.Pointer(__ret))
	return __v
}

// WritePixmapAsPcl function as declared in fitz/output-pcl.h:85
func WritePixmapAsPcl(ctx []Context, out []Output, pixmap []Pixmap, pcl []PclOptions) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cpixmap, _ := unpackArgSPixmap(pixmap)
	cpcl, _ := unpackArgSPclOptions(pcl)
	C.fz_write_pixmap_as_pcl(cctx, cout, cpixmap, cpcl)
	packSPclOptions(pcl, cpcl)
	packSPixmap(pixmap, cpixmap)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// SavePixmapAsPcl function as declared in fitz/output-pcl.h:86
func SavePixmapAsPcl(ctx []Context, pixmap []Pixmap, filename []byte, append int32, pcl []PclOptions) {
	cctx, _ := unpackArgSContext(ctx)
	cpixmap, _ := unpackArgSPixmap(pixmap)
	cfilename, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&filename)).Data)), cgoAllocsUnknown
	cappend, _ := (C.int)(append), cgoAllocsUnknown
	cpcl, _ := unpackArgSPclOptions(pcl)
	C.fz_save_pixmap_as_pcl(cctx, cpixmap, cfilename, cappend, cpcl)
	packSPclOptions(pcl, cpcl)
	packSPixmap(pixmap, cpixmap)
	packSContext(ctx, cctx)
}

// WritePixmapAsPs function as declared in fitz/output-ps.h:13
func WritePixmapAsPs(ctx []Context, out []Output, pixmap []Pixmap) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cpixmap, _ := unpackArgSPixmap(pixmap)
	C.fz_write_pixmap_as_ps(cctx, cout, cpixmap)
	packSPixmap(pixmap, cpixmap)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// SavePixmapAsPs function as declared in fitz/output-ps.h:15
func SavePixmapAsPs(ctx []Context, pixmap []Pixmap, filename []byte, append int32) {
	cctx, _ := unpackArgSContext(ctx)
	cpixmap, _ := unpackArgSPixmap(pixmap)
	cfilename, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&filename)).Data)), cgoAllocsUnknown
	cappend, _ := (C.int)(append), cgoAllocsUnknown
	C.fz_save_pixmap_as_ps(cctx, cpixmap, cfilename, cappend)
	packSPixmap(pixmap, cpixmap)
	packSContext(ctx, cctx)
}

// WritePsFileHeader function as declared in fitz/output-ps.h:17
func WritePsFileHeader(ctx []Context, out []Output) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	C.fz_write_ps_file_header(cctx, cout)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// NewPsBandWriter function as declared in fitz/output-ps.h:19
func NewPsBandWriter(ctx []Context, out []Output) *BandWriter {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	__ret := C.fz_new_ps_band_writer(cctx, cout)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
	__v := NewBandWriterRef(unsafe.Pointer(__ret))
	return __v
}

// WritePsFileTrailer function as declared in fitz/output-ps.h:21
func WritePsFileTrailer(ctx []Context, out []Output, pages int32) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cpages, _ := (C.int)(pages), cgoAllocsUnknown
	C.fz_write_ps_file_trailer(cctx, cout, cpages)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// SavePixmapAsPsd function as declared in fitz/output-psd.h:17
func SavePixmapAsPsd(ctx []Context, pixmap []Pixmap, filename string) {
	cctx, _ := unpackArgSContext(ctx)
	cpixmap, _ := unpackArgSPixmap(pixmap)
	cfilename, _ := unpackPCharString(filename)
	C.fz_save_pixmap_as_psd(cctx, cpixmap, cfilename)
	packSPixmap(pixmap, cpixmap)
	packSContext(ctx, cctx)
}

// WritePixmapAsPsd function as declared in fitz/output-psd.h:22
func WritePixmapAsPsd(ctx []Context, out []Output, pixmap []Pixmap) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cpixmap, _ := unpackArgSPixmap(pixmap)
	C.fz_write_pixmap_as_psd(cctx, cout, cpixmap)
	packSPixmap(pixmap, cpixmap)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// NewPsdBandWriter function as declared in fitz/output-psd.h:28
func NewPsdBandWriter(ctx []Context, out []Output) *BandWriter {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	__ret := C.fz_new_psd_band_writer(cctx, cout)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
	__v := NewBandWriterRef(unsafe.Pointer(__ret))
	return __v
}

// NewSvgDevice function as declared in fitz/output-svg.h:28
func NewSvgDevice(ctx []Context, out []Output, pageWidth float32, pageHeight float32, textFormat int32, reuseImages int32) *Device {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cpageWidth, _ := (C.float)(pageWidth), cgoAllocsUnknown
	cpageHeight, _ := (C.float)(pageHeight), cgoAllocsUnknown
	ctextFormat, _ := (C.int)(textFormat), cgoAllocsUnknown
	creuseImages, _ := (C.int)(reuseImages), cgoAllocsUnknown
	__ret := C.fz_new_svg_device(cctx, cout, cpageWidth, cpageHeight, ctextFormat, creuseImages)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
	__v := NewDeviceRef(unsafe.Pointer(__ret))
	return __v
}

// SavePixmapAsTga function as declared in fitz/output-tga.h:15
func SavePixmapAsTga(ctx []Context, pixmap []Pixmap, filename string) {
	cctx, _ := unpackArgSContext(ctx)
	cpixmap, _ := unpackArgSPixmap(pixmap)
	cfilename, _ := unpackPCharString(filename)
	C.fz_save_pixmap_as_tga(cctx, cpixmap, cfilename)
	packSPixmap(pixmap, cpixmap)
	packSContext(ctx, cctx)
}

// WritePixmapAsTga function as declared in fitz/output-tga.h:22
func WritePixmapAsTga(ctx []Context, out []Output, pixmap []Pixmap) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cpixmap, _ := unpackArgSPixmap(pixmap)
	C.fz_write_pixmap_as_tga(cctx, cout, cpixmap)
	packSPixmap(pixmap, cpixmap)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// NewTgaBandWriter function as declared in fitz/output-tga.h:34
func NewTgaBandWriter(ctx []Context, out []Output, isBgr int32) *BandWriter {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cisBgr, _ := (C.int)(isBgr), cgoAllocsUnknown
	__ret := C.fz_new_tga_band_writer(cctx, cout, cisBgr)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
	__v := NewBandWriterRef(unsafe.Pointer(__ret))
	return __v
}

// NewNull function as declared in pdf/object.h:14
func NewNull(ctx []Context, doc []Document) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.pdf_new_null(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// NewBool function as declared in pdf/object.h:15
func NewBool(ctx []Context, doc []Document, b int32) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cb, _ := (C.int)(b), cgoAllocsUnknown
	__ret := C.pdf_new_bool(cctx, cdoc, cb)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// NewInt function as declared in pdf/object.h:16
func NewInt(ctx []Context, doc []Document, i int32) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	ci, _ := (C.int)(i), cgoAllocsUnknown
	__ret := C.pdf_new_int(cctx, cdoc, ci)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// NewIntOffset function as declared in pdf/object.h:17
func NewIntOffset(ctx []Context, doc []Document, off Off) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	coff, _ := (C.fz_off_t)(off), cgoAllocsUnknown
	__ret := C.pdf_new_int_offset(cctx, cdoc, coff)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// NewReal function as declared in pdf/object.h:18
func NewReal(ctx []Context, doc []Document, f float32) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cf, _ := (C.float)(f), cgoAllocsUnknown
	__ret := C.pdf_new_real(cctx, cdoc, cf)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// NewName function as declared in pdf/object.h:19
func NewName(ctx []Context, doc []Document, str string) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cstr, _ := unpackPCharString(str)
	__ret := C.pdf_new_name(cctx, cdoc, cstr)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// NewString function as declared in pdf/object.h:20
func NewString(ctx []Context, doc []Document, str string, len uint) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cstr, _ := unpackPCharString(str)
	clen, _ := (C.size_t)(len), cgoAllocsUnknown
	__ret := C.pdf_new_string(cctx, cdoc, cstr, clen)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// NewIndirect function as declared in pdf/object.h:21
func NewIndirect(ctx []Context, doc []Document, num int32, gen int32) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cnum, _ := (C.int)(num), cgoAllocsUnknown
	cgen, _ := (C.int)(gen), cgoAllocsUnknown
	__ret := C.pdf_new_indirect(cctx, cdoc, cnum, cgen)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// NewArray function as declared in pdf/object.h:22
func NewArray(ctx []Context, doc []Document, initialcap int32) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cinitialcap, _ := (C.int)(initialcap), cgoAllocsUnknown
	__ret := C.pdf_new_array(cctx, cdoc, cinitialcap)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// NewDict function as declared in pdf/object.h:23
func NewDict(ctx []Context, doc []Document, initialcap int32) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cinitialcap, _ := (C.int)(initialcap), cgoAllocsUnknown
	__ret := C.pdf_new_dict(cctx, cdoc, cinitialcap)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// NewRect function as declared in pdf/object.h:24
func NewRect(ctx []Context, doc []Document, rect []Rect) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	crect, _ := unpackArgSRect(rect)
	__ret := C.pdf_new_rect(cctx, cdoc, crect)
	packSRect(rect, crect)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// NewMatrix function as declared in pdf/object.h:25
func NewMatrix(ctx []Context, doc []Document, mtx []Matrix) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cmtx, _ := unpackArgSMatrix(mtx)
	__ret := C.pdf_new_matrix(cctx, cdoc, cmtx)
	packSMatrix(mtx, cmtx)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// CopyArray function as declared in pdf/object.h:26
func CopyArray(ctx []Context, array []Obj) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	carray, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&array)).Data)), cgoAllocsUnknown
	__ret := C.pdf_copy_array(cctx, carray)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// CopyDict function as declared in pdf/object.h:27
func CopyDict(ctx []Context, dict []Obj) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdict, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dict)).Data)), cgoAllocsUnknown
	__ret := C.pdf_copy_dict(cctx, cdict)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// DeepCopyObj function as declared in pdf/object.h:28
func DeepCopyObj(ctx []Context, obj []Obj) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_deep_copy_obj(cctx, cobj)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// NewObjFromStr function as declared in pdf/object.h:30
func NewObjFromStr(ctx []Context, doc []Document, src string) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	csrc, _ := unpackPCharString(src)
	__ret := C.pdf_new_obj_from_str(cctx, cdoc, csrc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// KeepObj function as declared in pdf/object.h:32
func KeepObj(ctx []Context, obj []Obj) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_keep_obj(cctx, cobj)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// DropObj function as declared in pdf/object.h:33
func DropObj(ctx []Context, obj []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	C.pdf_drop_obj(cctx, cobj)
	packSContext(ctx, cctx)
}

// IsNull function as declared in pdf/object.h:36
func IsNull(ctx []Context, obj []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_is_null(cctx, cobj)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// IsBool function as declared in pdf/object.h:37
func IsBool(ctx []Context, obj []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_is_bool(cctx, cobj)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// IsInt function as declared in pdf/object.h:38
func IsInt(ctx []Context, obj []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_is_int(cctx, cobj)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// IsReal function as declared in pdf/object.h:39
func IsReal(ctx []Context, obj []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_is_real(cctx, cobj)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// IsNumber function as declared in pdf/object.h:40
func IsNumber(ctx []Context, obj []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_is_number(cctx, cobj)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// IsName function as declared in pdf/object.h:41
func IsName(ctx []Context, obj []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_is_name(cctx, cobj)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// IsString function as declared in pdf/object.h:42
func IsString(ctx []Context, obj []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_is_string(cctx, cobj)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// IsArray function as declared in pdf/object.h:43
func IsArray(ctx []Context, obj []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_is_array(cctx, cobj)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// IsDict function as declared in pdf/object.h:44
func IsDict(ctx []Context, obj []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_is_dict(cctx, cobj)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// IsIndirect function as declared in pdf/object.h:45
func IsIndirect(ctx []Context, obj []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_is_indirect(cctx, cobj)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ObjNumIsStream function as declared in pdf/object.h:46
func ObjNumIsStream(ctx []Context, doc []Document, num int32) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cnum, _ := (C.int)(num), cgoAllocsUnknown
	__ret := C.pdf_obj_num_is_stream(cctx, cdoc, cnum)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// IsStream function as declared in pdf/object.h:47
func IsStream(ctx []Context, obj []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_is_stream(cctx, cobj)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ResolveObj function as declared in pdf/object.h:48
func ResolveObj(ctx []Context, a []Obj) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	ca, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&a)).Data)), cgoAllocsUnknown
	__ret := C.pdf_resolve_obj(cctx, ca)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// Objcmp function as declared in pdf/object.h:49
func Objcmp(ctx []Context, a []Obj, b []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	ca, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&a)).Data)), cgoAllocsUnknown
	cb, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&b)).Data)), cgoAllocsUnknown
	__ret := C.pdf_objcmp(cctx, ca, cb)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ObjcmpResolve function as declared in pdf/object.h:50
func ObjcmpResolve(ctx []Context, a []Obj, b []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	ca, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&a)).Data)), cgoAllocsUnknown
	cb, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&b)).Data)), cgoAllocsUnknown
	__ret := C.pdf_objcmp_resolve(cctx, ca, cb)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// NameEq function as declared in pdf/object.h:52
func NameEq(ctx []Context, a []Obj, b []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	ca, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&a)).Data)), cgoAllocsUnknown
	cb, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&b)).Data)), cgoAllocsUnknown
	__ret := C.pdf_name_eq(cctx, ca, cb)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ObjMarked function as declared in pdf/object.h:62
func ObjMarked(ctx []Context, obj []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_obj_marked(cctx, cobj)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// MarkObj function as declared in pdf/object.h:63
func MarkObj(ctx []Context, obj []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_mark_obj(cctx, cobj)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// UnmarkObj function as declared in pdf/object.h:64
func UnmarkObj(ctx []Context, obj []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	C.pdf_unmark_obj(cctx, cobj)
	packSContext(ctx, cctx)
}

// SetObjMemo function as declared in pdf/object.h:69
func SetObjMemo(ctx []Context, obj []Obj, memo int32) {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	cmemo, _ := (C.int)(memo), cgoAllocsUnknown
	C.pdf_set_obj_memo(cctx, cobj, cmemo)
	packSContext(ctx, cctx)
}

// ObjMemo function as declared in pdf/object.h:70
func ObjMemo(ctx []Context, obj []Obj, memo []int32) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	cmemo, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&memo)).Data)), cgoAllocsUnknown
	__ret := C.pdf_obj_memo(cctx, cobj, cmemo)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ObjIsDirty function as declared in pdf/object.h:73
func ObjIsDirty(ctx []Context, obj []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_obj_is_dirty(cctx, cobj)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// DirtyObj function as declared in pdf/object.h:74
func DirtyObj(ctx []Context, obj []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	C.pdf_dirty_obj(cctx, cobj)
	packSContext(ctx, cctx)
}

// CleanObj function as declared in pdf/object.h:75
func CleanObj(ctx []Context, obj []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	C.pdf_clean_obj(cctx, cobj)
	packSContext(ctx, cctx)
}

// ToBool function as declared in pdf/object.h:78
func ToBool(ctx []Context, obj []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_to_bool(cctx, cobj)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ToInt function as declared in pdf/object.h:79
func ToInt(ctx []Context, obj []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_to_int(cctx, cobj)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ToOffset function as declared in pdf/object.h:80
func ToOffset(ctx []Context, obj []Obj) Off {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_to_offset(cctx, cobj)
	packSContext(ctx, cctx)
	__v := (Off)(__ret)
	return __v
}

// ToReal function as declared in pdf/object.h:81
func ToReal(ctx []Context, obj []Obj) float32 {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_to_real(cctx, cobj)
	packSContext(ctx, cctx)
	__v := (float32)(__ret)
	return __v
}

// ToName function as declared in pdf/object.h:82
func ToName(ctx []Context, obj []Obj) string {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_to_name(cctx, cobj)
	packSContext(ctx, cctx)
	__v := packPCharString(__ret)
	return __v
}

// ToStrBuf function as declared in pdf/object.h:83
func ToStrBuf(ctx []Context, obj []Obj) *byte {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_to_str_buf(cctx, cobj)
	packSContext(ctx, cctx)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// ToStrLen function as declared in pdf/object.h:84
func ToStrLen(ctx []Context, obj []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_to_str_len(cctx, cobj)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ToNum function as declared in pdf/object.h:85
func ToNum(ctx []Context, obj []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_to_num(cctx, cobj)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ToGen function as declared in pdf/object.h:86
func ToGen(ctx []Context, obj []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_to_gen(cctx, cobj)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ArrayLen function as declared in pdf/object.h:88
func ArrayLen(ctx []Context, array []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	carray, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&array)).Data)), cgoAllocsUnknown
	__ret := C.pdf_array_len(cctx, carray)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ArrayGet function as declared in pdf/object.h:89
func ArrayGet(ctx []Context, array []Obj, i int32) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	carray, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&array)).Data)), cgoAllocsUnknown
	ci, _ := (C.int)(i), cgoAllocsUnknown
	__ret := C.pdf_array_get(cctx, carray, ci)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// ArrayPut function as declared in pdf/object.h:90
func ArrayPut(ctx []Context, array []Obj, i int32, obj []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	carray, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&array)).Data)), cgoAllocsUnknown
	ci, _ := (C.int)(i), cgoAllocsUnknown
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	C.pdf_array_put(cctx, carray, ci, cobj)
	packSContext(ctx, cctx)
}

// ArrayPutDrop function as declared in pdf/object.h:91
func ArrayPutDrop(ctx []Context, array []Obj, i int32, obj []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	carray, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&array)).Data)), cgoAllocsUnknown
	ci, _ := (C.int)(i), cgoAllocsUnknown
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	C.pdf_array_put_drop(cctx, carray, ci, cobj)
	packSContext(ctx, cctx)
}

// ArrayPush function as declared in pdf/object.h:92
func ArrayPush(ctx []Context, array []Obj, obj []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	carray, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&array)).Data)), cgoAllocsUnknown
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	C.pdf_array_push(cctx, carray, cobj)
	packSContext(ctx, cctx)
}

// ArrayPushDrop function as declared in pdf/object.h:93
func ArrayPushDrop(ctx []Context, array []Obj, obj []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	carray, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&array)).Data)), cgoAllocsUnknown
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	C.pdf_array_push_drop(cctx, carray, cobj)
	packSContext(ctx, cctx)
}

// ArrayInsert function as declared in pdf/object.h:94
func ArrayInsert(ctx []Context, array []Obj, obj []Obj, index int32) {
	cctx, _ := unpackArgSContext(ctx)
	carray, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&array)).Data)), cgoAllocsUnknown
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	cindex, _ := (C.int)(index), cgoAllocsUnknown
	C.pdf_array_insert(cctx, carray, cobj, cindex)
	packSContext(ctx, cctx)
}

// ArrayInsertDrop function as declared in pdf/object.h:95
func ArrayInsertDrop(ctx []Context, array []Obj, obj []Obj, index int32) {
	cctx, _ := unpackArgSContext(ctx)
	carray, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&array)).Data)), cgoAllocsUnknown
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	cindex, _ := (C.int)(index), cgoAllocsUnknown
	C.pdf_array_insert_drop(cctx, carray, cobj, cindex)
	packSContext(ctx, cctx)
}

// ArrayDelete function as declared in pdf/object.h:96
func ArrayDelete(ctx []Context, array []Obj, index int32) {
	cctx, _ := unpackArgSContext(ctx)
	carray, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&array)).Data)), cgoAllocsUnknown
	cindex, _ := (C.int)(index), cgoAllocsUnknown
	C.pdf_array_delete(cctx, carray, cindex)
	packSContext(ctx, cctx)
}

// ArrayFind function as declared in pdf/object.h:97
func ArrayFind(ctx []Context, array []Obj, obj []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	carray, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&array)).Data)), cgoAllocsUnknown
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_array_find(cctx, carray, cobj)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ArrayContains function as declared in pdf/object.h:98
func ArrayContains(ctx []Context, array []Obj, obj []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	carray, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&array)).Data)), cgoAllocsUnknown
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_array_contains(cctx, carray, cobj)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// DictLen function as declared in pdf/object.h:100
func DictLen(ctx []Context, dict []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdict, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dict)).Data)), cgoAllocsUnknown
	__ret := C.pdf_dict_len(cctx, cdict)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// DictGetKey function as declared in pdf/object.h:101
func DictGetKey(ctx []Context, dict []Obj, idx int32) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdict, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dict)).Data)), cgoAllocsUnknown
	cidx, _ := (C.int)(idx), cgoAllocsUnknown
	__ret := C.pdf_dict_get_key(cctx, cdict, cidx)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// DictGetVal function as declared in pdf/object.h:102
func DictGetVal(ctx []Context, dict []Obj, idx int32) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdict, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dict)).Data)), cgoAllocsUnknown
	cidx, _ := (C.int)(idx), cgoAllocsUnknown
	__ret := C.pdf_dict_get_val(cctx, cdict, cidx)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// DictGet function as declared in pdf/object.h:103
func DictGet(ctx []Context, dict []Obj, key []Obj) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdict, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dict)).Data)), cgoAllocsUnknown
	ckey, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&key)).Data)), cgoAllocsUnknown
	__ret := C.pdf_dict_get(cctx, cdict, ckey)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// DictGetp function as declared in pdf/object.h:104
func DictGetp(ctx []Context, dict []Obj, path string) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdict, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dict)).Data)), cgoAllocsUnknown
	cpath, _ := unpackPCharString(path)
	__ret := C.pdf_dict_getp(cctx, cdict, cpath)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// DictGetl function as declared in pdf/object.h:105
func DictGetl(ctx []Context, dict []Obj) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdict, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dict)).Data)), cgoAllocsUnknown
	__ret := C.pdf_dict_getl(cctx, cdict)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// DictGeta function as declared in pdf/object.h:106
func DictGeta(ctx []Context, dict []Obj, key []Obj, abbrev []Obj) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdict, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dict)).Data)), cgoAllocsUnknown
	ckey, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&key)).Data)), cgoAllocsUnknown
	cabbrev, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&abbrev)).Data)), cgoAllocsUnknown
	__ret := C.pdf_dict_geta(cctx, cdict, ckey, cabbrev)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// DictGets function as declared in pdf/object.h:107
func DictGets(ctx []Context, dict []Obj, key string) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdict, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dict)).Data)), cgoAllocsUnknown
	ckey, _ := unpackPCharString(key)
	__ret := C.pdf_dict_gets(cctx, cdict, ckey)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// DictGetsa function as declared in pdf/object.h:108
func DictGetsa(ctx []Context, dict []Obj, key string, abbrev string) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdict, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dict)).Data)), cgoAllocsUnknown
	ckey, _ := unpackPCharString(key)
	cabbrev, _ := unpackPCharString(abbrev)
	__ret := C.pdf_dict_getsa(cctx, cdict, ckey, cabbrev)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// DictPut function as declared in pdf/object.h:109
func DictPut(ctx []Context, dict []Obj, key []Obj, val []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cdict, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dict)).Data)), cgoAllocsUnknown
	ckey, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&key)).Data)), cgoAllocsUnknown
	cval, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&val)).Data)), cgoAllocsUnknown
	C.pdf_dict_put(cctx, cdict, ckey, cval)
	packSContext(ctx, cctx)
}

// DictPutDrop function as declared in pdf/object.h:110
func DictPutDrop(ctx []Context, dict []Obj, key []Obj, val []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cdict, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dict)).Data)), cgoAllocsUnknown
	ckey, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&key)).Data)), cgoAllocsUnknown
	cval, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&val)).Data)), cgoAllocsUnknown
	C.pdf_dict_put_drop(cctx, cdict, ckey, cval)
	packSContext(ctx, cctx)
}

// DictGetPutDrop function as declared in pdf/object.h:111
func DictGetPutDrop(ctx []Context, dict []Obj, key []Obj, val []Obj, oldVal [][]Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cdict, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dict)).Data)), cgoAllocsUnknown
	ckey, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&key)).Data)), cgoAllocsUnknown
	cval, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&val)).Data)), cgoAllocsUnknown
	coldVal, _ := unpackArgSSObj(oldVal)
	C.pdf_dict_get_put_drop(cctx, cdict, ckey, cval, coldVal)
	packSSObj(oldVal, coldVal)
	packSContext(ctx, cctx)
}

// DictPuts function as declared in pdf/object.h:112
func DictPuts(ctx []Context, dict []Obj, key string, val []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cdict, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dict)).Data)), cgoAllocsUnknown
	ckey, _ := unpackPCharString(key)
	cval, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&val)).Data)), cgoAllocsUnknown
	C.pdf_dict_puts(cctx, cdict, ckey, cval)
	packSContext(ctx, cctx)
}

// DictPutsDrop function as declared in pdf/object.h:113
func DictPutsDrop(ctx []Context, dict []Obj, key string, val []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cdict, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dict)).Data)), cgoAllocsUnknown
	ckey, _ := unpackPCharString(key)
	cval, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&val)).Data)), cgoAllocsUnknown
	C.pdf_dict_puts_drop(cctx, cdict, ckey, cval)
	packSContext(ctx, cctx)
}

// DictPutp function as declared in pdf/object.h:114
func DictPutp(ctx []Context, dict []Obj, path string, val []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cdict, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dict)).Data)), cgoAllocsUnknown
	cpath, _ := unpackPCharString(path)
	cval, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&val)).Data)), cgoAllocsUnknown
	C.pdf_dict_putp(cctx, cdict, cpath, cval)
	packSContext(ctx, cctx)
}

// DictPutpDrop function as declared in pdf/object.h:115
func DictPutpDrop(ctx []Context, dict []Obj, path string, val []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cdict, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dict)).Data)), cgoAllocsUnknown
	cpath, _ := unpackPCharString(path)
	cval, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&val)).Data)), cgoAllocsUnknown
	C.pdf_dict_putp_drop(cctx, cdict, cpath, cval)
	packSContext(ctx, cctx)
}

// DictPutl function as declared in pdf/object.h:116
func DictPutl(ctx []Context, dict []Obj, val []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cdict, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dict)).Data)), cgoAllocsUnknown
	cval, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&val)).Data)), cgoAllocsUnknown
	C.pdf_dict_putl(cctx, cdict, cval)
	packSContext(ctx, cctx)
}

// DictPutlDrop function as declared in pdf/object.h:117
func DictPutlDrop(ctx []Context, dict []Obj, val []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cdict, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dict)).Data)), cgoAllocsUnknown
	cval, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&val)).Data)), cgoAllocsUnknown
	C.pdf_dict_putl_drop(cctx, cdict, cval)
	packSContext(ctx, cctx)
}

// DictDel function as declared in pdf/object.h:118
func DictDel(ctx []Context, dict []Obj, key []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cdict, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dict)).Data)), cgoAllocsUnknown
	ckey, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&key)).Data)), cgoAllocsUnknown
	C.pdf_dict_del(cctx, cdict, ckey)
	packSContext(ctx, cctx)
}

// DictDels function as declared in pdf/object.h:119
func DictDels(ctx []Context, dict []Obj, key string) {
	cctx, _ := unpackArgSContext(ctx)
	cdict, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dict)).Data)), cgoAllocsUnknown
	ckey, _ := unpackPCharString(key)
	C.pdf_dict_dels(cctx, cdict, ckey)
	packSContext(ctx, cctx)
}

// SortDict function as declared in pdf/object.h:120
func SortDict(ctx []Context, dict []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cdict, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dict)).Data)), cgoAllocsUnknown
	C.pdf_sort_dict(cctx, cdict)
	packSContext(ctx, cctx)
}

// SetObjParent function as declared in pdf/object.h:128
func SetObjParent(ctx []Context, obj []Obj, num int32) {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	cnum, _ := (C.int)(num), cgoAllocsUnknown
	C.pdf_set_obj_parent(cctx, cobj, cnum)
	packSContext(ctx, cctx)
}

// ObjRefs function as declared in pdf/object.h:130
func ObjRefs(ctx []Context, ref []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cref, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ref)).Data)), cgoAllocsUnknown
	__ret := C.pdf_obj_refs(cctx, cref)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ObjParentNum function as declared in pdf/object.h:132
func ObjParentNum(ctx []Context, obj []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_obj_parent_num(cctx, cobj)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// SprintObj function as declared in pdf/object.h:134
func SprintObj(ctx []Context, s []byte, n int32, obj []Obj, tight int32) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cs, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&s)).Data)), cgoAllocsUnknown
	cn, _ := (C.int)(n), cgoAllocsUnknown
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	ctight, _ := (C.int)(tight), cgoAllocsUnknown
	__ret := C.pdf_sprint_obj(cctx, cs, cn, cobj, ctight)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// PrintObj function as declared in pdf/object.h:135
func PrintObj(ctx []Context, out []Output, obj []Obj, tight int32) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	ctight, _ := (C.int)(tight), cgoAllocsUnknown
	__ret := C.pdf_print_obj(cctx, cout, cobj, ctight)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ToUtf8 function as declared in pdf/object.h:137
func ToUtf8(ctx []Context, src []Obj) *byte {
	cctx, _ := unpackArgSContext(ctx)
	csrc, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&src)).Data)), cgoAllocsUnknown
	__ret := C.pdf_to_utf8(cctx, csrc)
	packSContext(ctx, cctx)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// LoadStreamAsUtf8 function as declared in pdf/object.h:138
func LoadStreamAsUtf8(ctx []Context, src []Obj) *byte {
	cctx, _ := unpackArgSContext(ctx)
	csrc, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&src)).Data)), cgoAllocsUnknown
	__ret := C.pdf_load_stream_as_utf8(cctx, csrc)
	packSContext(ctx, cctx)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// LoadStreamOrStringAsUtf8 function as declared in pdf/object.h:139
func LoadStreamOrStringAsUtf8(ctx []Context, src []Obj) *byte {
	cctx, _ := unpackArgSContext(ctx)
	csrc, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&src)).Data)), cgoAllocsUnknown
	__ret := C.pdf_load_stream_or_string_as_utf8(cctx, csrc)
	packSContext(ctx, cctx)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// ToUcs2 function as declared in pdf/object.h:140
func ToUcs2(ctx []Context, src []Obj) *uint16 {
	cctx, _ := unpackArgSContext(ctx)
	csrc, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&src)).Data)), cgoAllocsUnknown
	__ret := C.pdf_to_ucs2(cctx, csrc)
	packSContext(ctx, cctx)
	__v := *(**uint16)(unsafe.Pointer(&__ret))
	return __v
}

// ToUtf8Name function as declared in pdf/object.h:141
func ToUtf8Name(ctx []Context, doc []Document, src []Obj) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	csrc, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&src)).Data)), cgoAllocsUnknown
	__ret := C.pdf_to_utf8_name(cctx, cdoc, csrc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// FromUcs2 function as declared in pdf/object.h:142
func FromUcs2(ctx []Context, str []uint16) *byte {
	cctx, _ := unpackArgSContext(ctx)
	cstr, _ := (*C.ushort)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&str)).Data)), cgoAllocsUnknown
	__ret := C.pdf_from_ucs2(cctx, cstr)
	packSContext(ctx, cctx)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// ToUcs2Buf function as declared in pdf/object.h:143
func ToUcs2Buf(ctx []Context, buffer []uint16, src []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cbuffer, _ := (*C.ushort)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buffer)).Data)), cgoAllocsUnknown
	csrc, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&src)).Data)), cgoAllocsUnknown
	C.pdf_to_ucs2_buf(cctx, cbuffer, csrc)
	packSContext(ctx, cctx)
}

// ToRect function as declared in pdf/object.h:145
func ToRect(ctx []Context, array []Obj, rect []Rect) *Rect {
	cctx, _ := unpackArgSContext(ctx)
	carray, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&array)).Data)), cgoAllocsUnknown
	crect, _ := unpackArgSRect(rect)
	__ret := C.pdf_to_rect(cctx, carray, crect)
	packSRect(rect, crect)
	packSContext(ctx, cctx)
	__v := NewRectRef(unsafe.Pointer(__ret))
	return __v
}

// ToMatrix function as declared in pdf/object.h:146
func ToMatrix(ctx []Context, array []Obj, mat []Matrix) *Matrix {
	cctx, _ := unpackArgSContext(ctx)
	carray, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&array)).Data)), cgoAllocsUnknown
	cmat, _ := unpackArgSMatrix(mat)
	__ret := C.pdf_to_matrix(cctx, carray, cmat)
	packSMatrix(mat, cmat)
	packSContext(ctx, cctx)
	__v := NewMatrixRef(unsafe.Pointer(__ret))
	return __v
}

// GetIndirectDocument function as declared in pdf/object.h:148
func GetIndirectDocument(ctx []Context, obj []Obj) *Document {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_get_indirect_document(cctx, cobj)
	packSContext(ctx, cctx)
	__v := NewDocumentRef(unsafe.Pointer(__ret))
	return __v
}

// GetBoundDocument function as declared in pdf/object.h:149
func GetBoundDocument(ctx []Context, obj []Obj) *Document {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_get_bound_document(cctx, cobj)
	packSContext(ctx, cctx)
	__v := NewDocumentRef(unsafe.Pointer(__ret))
	return __v
}

// SetStrLen function as declared in pdf/object.h:150
func SetStrLen(ctx []Context, obj []Obj, newlen int32) {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	cnewlen, _ := (C.int)(newlen), cgoAllocsUnknown
	C.pdf_set_str_len(cctx, cobj, cnewlen)
	packSContext(ctx, cctx)
}

// SetInt function as declared in pdf/object.h:151
func SetInt(ctx []Context, obj []Obj, i int32) {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	ci, _ := (C.int)(i), cgoAllocsUnknown
	C.pdf_set_int(cctx, cobj, ci)
	packSContext(ctx, cctx)
}

// SetIntOffset function as declared in pdf/object.h:152
func SetIntOffset(ctx []Context, obj []Obj, i Off) {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	ci, _ := (C.fz_off_t)(i), cgoAllocsUnknown
	C.pdf_set_int_offset(cctx, cobj, ci)
	packSContext(ctx, cctx)
}

// OpenDocument function as declared in pdf/document.h:75
func OpenDocument(ctx []Context, filename string) *Document {
	cctx, _ := unpackArgSContext(ctx)
	cfilename, _ := unpackPCharString(filename)
	__ret := C.pdf_open_document(cctx, cfilename)
	packSContext(ctx, cctx)
	__v := NewDocumentRef(unsafe.Pointer(__ret))
	return __v
}

// OpenDocumentWithStream function as declared in pdf/document.h:86
func OpenDocumentWithStream(ctx []Context, file []Stream) *Document {
	cctx, _ := unpackArgSContext(ctx)
	cfile, _ := unpackArgSStream(file)
	__ret := C.pdf_open_document_with_stream(cctx, cfile)
	packSStream(file, cfile)
	packSContext(ctx, cctx)
	__v := NewDocumentRef(unsafe.Pointer(__ret))
	return __v
}

// DropDocument function as declared in pdf/document.h:94
func DropDocument(ctx []Context, doc []Document) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	C.pdf_drop_document(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// KeepDocument function as declared in pdf/document.h:99
func KeepDocument(ctx []Context, doc []Document) *Document {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.pdf_keep_document(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewDocumentRef(unsafe.Pointer(__ret))
	return __v
}

// Specifics function as declared in pdf/document.h:105
func Specifics(ctx []Context, doc []Document) *Document {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.pdf_specifics(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewDocumentRef(unsafe.Pointer(__ret))
	return __v
}

// DocumentFrom_Document function as declared in pdf/document.h:114
func DocumentFrom_Document(ctx []Context, ptr []Document) *Document {
	cctx, _ := unpackArgSContext(ctx)
	cptr, _ := unpackArgSDocument(ptr)
	__ret := C.pdf_document_from_fz_document(cctx, cptr)
	packSDocument(ptr, cptr)
	packSContext(ctx, cctx)
	__v := NewDocumentRef(unsafe.Pointer(__ret))
	return __v
}

// PageFrom_Page function as declared in pdf/document.h:115
func PageFrom_Page(ctx []Context, ptr []Page) *Page {
	cctx, _ := unpackArgSContext(ctx)
	cptr, _ := unpackArgSPage(ptr)
	__ret := C.pdf_page_from_fz_page(cctx, cptr)
	packSPage(ptr, cptr)
	packSContext(ctx, cctx)
	__v := NewPageRef(unsafe.Pointer(__ret))
	return __v
}

// AnnotFrom_Annot function as declared in pdf/document.h:116
func AnnotFrom_Annot(ctx []Context, ptr []Annot) *Annot {
	cctx, _ := unpackArgSContext(ctx)
	cptr, _ := unpackArgSAnnot(ptr)
	__ret := C.pdf_annot_from_fz_annot(cctx, cptr)
	packSAnnot(ptr, cptr)
	packSContext(ctx, cctx)
	__v := NewAnnotRef(unsafe.Pointer(__ret))
	return __v
}

// NeedsPassword function as declared in pdf/document.h:118
func NeedsPassword(ctx []Context, doc []Document) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.pdf_needs_password(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// AuthenticatePassword function as declared in pdf/document.h:131
func AuthenticatePassword(ctx []Context, doc []Document, pw string) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cpw, _ := unpackPCharString(pw)
	__ret := C.pdf_authenticate_password(cctx, cdoc, cpw)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// HasPermission function as declared in pdf/document.h:133
func HasPermission(ctx []Context, doc []Document, p Permission) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cp, _ := (C.fz_permission)(p), cgoAllocsUnknown
	__ret := C.pdf_has_permission(cctx, cdoc, cp)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// LookupMetadata function as declared in pdf/document.h:134
func LookupMetadata(ctx []Context, doc []Document, key string, ptr []byte, size int32) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	ckey, _ := unpackPCharString(key)
	cptr, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ptr)).Data)), cgoAllocsUnknown
	csize, _ := (C.int)(size), cgoAllocsUnknown
	__ret := C.pdf_lookup_metadata(cctx, cdoc, ckey, cptr, csize)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// LoadOutline function as declared in pdf/document.h:136
func LoadOutline(ctx []Context, doc []Document) *Outline {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.pdf_load_outline(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewOutlineRef(unsafe.Pointer(__ret))
	return __v
}

// CountLayerConfigs function as declared in pdf/document.h:144
func CountLayerConfigs(ctx []Context, doc []Document) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.pdf_count_layer_configs(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// LayerConfigInfo function as declared in pdf/document.h:165
func LayerConfigInfo(ctx []Context, doc []Document, configNum int32, info []LayerConfig) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cconfigNum, _ := (C.int)(configNum), cgoAllocsUnknown
	cinfo, _ := unpackArgSLayerConfig(info)
	C.pdf_layer_config_info(cctx, cdoc, cconfigNum, cinfo)
	packSLayerConfig(info, cinfo)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// SelectLayerConfig function as declared in pdf/document.h:177
func SelectLayerConfig(ctx []Context, doc []Document, configNum int32) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cconfigNum, _ := (C.int)(configNum), cgoAllocsUnknown
	C.pdf_select_layer_config(cctx, cdoc, cconfigNum)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// CountLayerConfigUi function as declared in pdf/document.h:185
func CountLayerConfigUi(ctx []Context, doc []Document) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.pdf_count_layer_config_ui(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// SelectLayerConfigUi function as declared in pdf/document.h:199
func SelectLayerConfigUi(ctx []Context, doc []Document, ui int32) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cui, _ := (C.int)(ui), cgoAllocsUnknown
	C.pdf_select_layer_config_ui(cctx, cdoc, cui)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// DeselectLayerConfigUi function as declared in pdf/document.h:210
func DeselectLayerConfigUi(ctx []Context, doc []Document, ui int32) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cui, _ := (C.int)(ui), cgoAllocsUnknown
	C.pdf_deselect_layer_config_ui(cctx, cdoc, cui)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// ToggleLayerConfigUi function as declared in pdf/document.h:224
func ToggleLayerConfigUi(ctx []Context, doc []Document, ui int32) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cui, _ := (C.int)(ui), cgoAllocsUnknown
	C.pdf_toggle_layer_config_ui(cctx, cdoc, cui)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// LayerConfigUiInfo function as declared in pdf/document.h:254
func LayerConfigUiInfo(ctx []Context, doc []Document, ui int32, info []LayerConfigUi) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cui, _ := (C.int)(ui), cgoAllocsUnknown
	cinfo, _ := unpackArgSLayerConfigUi(info)
	C.pdf_layer_config_ui_info(cctx, cdoc, cui, cinfo)
	packSLayerConfigUi(info, cinfo)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// SetLayerConfigAsDefault function as declared in pdf/document.h:260
func SetLayerConfigAsDefault(ctx []Context, doc []Document) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	C.pdf_set_layer_config_as_default(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// CountPortfolioSchema function as declared in pdf/document.h:284
func CountPortfolioSchema(ctx []Context, doc []Document) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.pdf_count_portfolio_schema(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// PortfolioSchemaInfo function as declared in pdf/document.h:320
func PortfolioSchemaInfo(ctx []Context, doc []Document, entry int32, info []PortfolioSchema) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	centry, _ := (C.int)(entry), cgoAllocsUnknown
	cinfo, _ := unpackArgSPortfolioSchema(info)
	C.pdf_portfolio_schema_info(cctx, cdoc, centry, cinfo)
	packSPortfolioSchema(info, cinfo)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// ReorderPortfolioSchema function as declared in pdf/document.h:335
func ReorderPortfolioSchema(ctx []Context, doc []Document, entry int32, newPos int32) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	centry, _ := (C.int)(entry), cgoAllocsUnknown
	cnewPos, _ := (C.int)(newPos), cgoAllocsUnknown
	C.pdf_reorder_portfolio_schema(cctx, cdoc, centry, cnewPos)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// RenamePortfolioSchema function as declared in pdf/document.h:349
func RenamePortfolioSchema(ctx []Context, doc []Document, entry int32, name string, nameLen int32) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	centry, _ := (C.int)(entry), cgoAllocsUnknown
	cname, _ := unpackPCharString(name)
	cnameLen, _ := (C.int)(nameLen), cgoAllocsUnknown
	C.pdf_rename_portfolio_schema(cctx, cdoc, centry, cname, cnameLen)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// DeletePortfolioSchema function as declared in pdf/document.h:359
func DeletePortfolioSchema(ctx []Context, doc []Document, entry int32) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	centry, _ := (C.int)(entry), cgoAllocsUnknown
	C.pdf_delete_portfolio_schema(cctx, cdoc, centry)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// AddPortfolioSchema function as declared in pdf/document.h:372
func AddPortfolioSchema(ctx []Context, doc []Document, entry int32, info []PortfolioSchema) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	centry, _ := (C.int)(entry), cgoAllocsUnknown
	cinfo, _ := unpackArgSPortfolioSchema(info)
	C.pdf_add_portfolio_schema(cctx, cdoc, centry, cinfo)
	packSPortfolioSchema(info, cinfo)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// CountPortfolioEntries function as declared in pdf/document.h:380
func CountPortfolioEntries(ctx []Context, doc []Document) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.pdf_count_portfolio_entries(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// PortfolioEntry function as declared in pdf/document.h:394
func PortfolioEntry(ctx []Context, doc []Document, entry int32) *Buffer {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	centry, _ := (C.int)(entry), cgoAllocsUnknown
	__ret := C.pdf_portfolio_entry(cctx, cdoc, centry)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Buffer)(unsafe.Pointer(&__ret))
	return __v
}

// PortfolioEntryObjName function as declared in pdf/document.h:413
func PortfolioEntryObjName(ctx []Context, doc []Document, entry int32, name [][]Obj) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	centry, _ := (C.int)(entry), cgoAllocsUnknown
	cname, _ := unpackArgSSObj(name)
	__ret := C.pdf_portfolio_entry_obj_name(cctx, cdoc, centry, cname)
	packSSObj(name, cname)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// PortfolioEntryObj function as declared in pdf/document.h:428
func PortfolioEntryObj(ctx []Context, doc []Document, entry int32) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	centry, _ := (C.int)(entry), cgoAllocsUnknown
	__ret := C.pdf_portfolio_entry_obj(cctx, cdoc, centry)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// PortfolioEntryName function as declared in pdf/document.h:447
func PortfolioEntryName(ctx []Context, doc []Document, entry int32) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	centry, _ := (C.int)(entry), cgoAllocsUnknown
	__ret := C.pdf_portfolio_entry_name(cctx, cdoc, centry)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// PortfolioEntryInfo function as declared in pdf/document.h:462
func PortfolioEntryInfo(ctx []Context, doc []Document, entry int32, schemaEntry int32) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	centry, _ := (C.int)(entry), cgoAllocsUnknown
	cschemaEntry, _ := (C.int)(schemaEntry), cgoAllocsUnknown
	__ret := C.pdf_portfolio_entry_info(cctx, cdoc, centry, cschemaEntry)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// AddPortfolioEntry function as declared in pdf/document.h:493
func AddPortfolioEntry(ctx []Context, doc []Document, name string, nameLen int32, desc string, descLen int32, filename string, filenameLen int32, unifile string, unifileLen int32, buf []Buffer) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cname, _ := unpackPCharString(name)
	cnameLen, _ := (C.int)(nameLen), cgoAllocsUnknown
	cdesc, _ := unpackPCharString(desc)
	cdescLen, _ := (C.int)(descLen), cgoAllocsUnknown
	cfilename, _ := unpackPCharString(filename)
	cfilenameLen, _ := (C.int)(filenameLen), cgoAllocsUnknown
	cunifile, _ := unpackPCharString(unifile)
	cunifileLen, _ := (C.int)(unifileLen), cgoAllocsUnknown
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	__ret := C.pdf_add_portfolio_entry(cctx, cdoc, cname, cnameLen, cdesc, cdescLen, cfilename, cfilenameLen, cunifile, cunifileLen, cbuf)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// SetPortfolioEntryInfo function as declared in pdf/document.h:515
func SetPortfolioEntryInfo(ctx []Context, doc []Document, entry int32, schemaEntry int32, data []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	centry, _ := (C.int)(entry), cgoAllocsUnknown
	cschemaEntry, _ := (C.int)(schemaEntry), cgoAllocsUnknown
	cdata, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	C.pdf_set_portfolio_entry_info(cctx, cdoc, centry, cschemaEntry, cdata)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// UpdatePage function as declared in pdf/document.h:531
func UpdatePage(ctx []Context, page []Page) {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	C.pdf_update_page(cctx, cpage)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
}

// HasUnsavedChanges function as declared in pdf/document.h:537
func HasUnsavedChanges(ctx []Context, doc []Document) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.pdf_has_unsaved_changes(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// CreateDocument function as declared in pdf/document.h:677
func CreateDocument(ctx []Context) *Document {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.pdf_create_document(cctx)
	packSContext(ctx, cctx)
	__v := NewDocumentRef(unsafe.Pointer(__ret))
	return __v
}

// GraftObject function as declared in pdf/document.h:695
func GraftObject(ctx []Context, dst []Document, obj []Obj) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdst, _ := unpackArgSDocument(dst)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_graft_object(cctx, cdst, cobj)
	packSDocument(dst, cdst)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// NewGraftMap function as declared in pdf/document.h:706
func NewGraftMap(ctx []Context, dst []Document) *GraftMap {
	cctx, _ := unpackArgSContext(ctx)
	cdst, _ := unpackArgSDocument(dst)
	__ret := C.pdf_new_graft_map(cctx, cdst)
	packSDocument(dst, cdst)
	packSContext(ctx, cctx)
	__v := *(**GraftMap)(unsafe.Pointer(&__ret))
	return __v
}

// KeepGraftMap function as declared in pdf/document.h:711
func KeepGraftMap(ctx []Context, _map []GraftMap) *GraftMap {
	cctx, _ := unpackArgSContext(ctx)
	c_map, _ := (*C.pdf_graft_map)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&_map)).Data)), cgoAllocsUnknown
	__ret := C.pdf_keep_graft_map(cctx, c_map)
	packSContext(ctx, cctx)
	__v := *(**GraftMap)(unsafe.Pointer(&__ret))
	return __v
}

// DropGraftMap function as declared in pdf/document.h:716
func DropGraftMap(ctx []Context, _map []GraftMap) {
	cctx, _ := unpackArgSContext(ctx)
	c_map, _ := (*C.pdf_graft_map)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&_map)).Data)), cgoAllocsUnknown
	C.pdf_drop_graft_map(cctx, c_map)
	packSContext(ctx, cctx)
}

// GraftMappedObject function as declared in pdf/document.h:731
func GraftMappedObject(ctx []Context, _map []GraftMap, obj []Obj) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	c_map, _ := (*C.pdf_graft_map)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&_map)).Data)), cgoAllocsUnknown
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_graft_mapped_object(cctx, c_map, cobj)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// PageWrite function as declared in pdf/document.h:750
func PageWrite(ctx []Context, doc []Document, mediabox []Rect, presources [][]Obj, pcontents [][]Buffer) *Device {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cmediabox, _ := unpackArgSRect(mediabox)
	cpresources, _ := unpackArgSSObj(presources)
	cpcontents, _ := unpackArgSSBuffer(pcontents)
	__ret := C.pdf_page_write(cctx, cdoc, cmediabox, cpresources, cpcontents)
	packSSBuffer(pcontents, cpcontents)
	packSSObj(presources, cpresources)
	packSRect(mediabox, cmediabox)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewDeviceRef(unsafe.Pointer(__ret))
	return __v
}

// AddPage function as declared in pdf/document.h:776
func AddPage(ctx []Context, doc []Document, mediabox []Rect, rotate int32, resources []Obj, contents []Buffer) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cmediabox, _ := unpackArgSRect(mediabox)
	crotate, _ := (C.int)(rotate), cgoAllocsUnknown
	cresources, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&resources)).Data)), cgoAllocsUnknown
	ccontents, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&contents)).Data)), cgoAllocsUnknown
	__ret := C.pdf_add_page(cctx, cdoc, cmediabox, crotate, cresources, ccontents)
	packSRect(mediabox, cmediabox)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// InsertPage function as declared in pdf/document.h:790
func InsertPage(ctx []Context, doc []Document, at int32, page []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cat, _ := (C.int)(at), cgoAllocsUnknown
	cpage, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&page)).Data)), cgoAllocsUnknown
	C.pdf_insert_page(cctx, cdoc, cat, cpage)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// DeletePage function as declared in pdf/document.h:801
func DeletePage(ctx []Context, doc []Document, number int32) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cnumber, _ := (C.int)(number), cgoAllocsUnknown
	C.pdf_delete_page(cctx, cdoc, cnumber)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// DeletePageRange function as declared in pdf/document.h:815
func DeletePageRange(ctx []Context, doc []Document, start int32, end int32) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cstart, _ := (C.int)(start), cgoAllocsUnknown
	cend, _ := (C.int)(end), cgoAllocsUnknown
	C.pdf_delete_page_range(cctx, cdoc, cstart, cend)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// FinishEdit function as declared in pdf/document.h:824
func FinishEdit(ctx []Context, doc []Document) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	C.pdf_finish_edit(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// Recognize function as declared in pdf/document.h:826
func Recognize(doc []Context, magic string) int32 {
	cdoc, _ := unpackArgSContext(doc)
	cmagic, _ := unpackPCharString(magic)
	__ret := C.pdf_recognize(cdoc, cmagic)
	packSContext(doc, cdoc)
	__v := (int32)(__ret)
	return __v
}

// ParseWriteOptions function as declared in pdf/document.h:861
func ParseWriteOptions(ctx []Context, opts []WriteOptions, args string) *WriteOptions {
	cctx, _ := unpackArgSContext(ctx)
	copts, _ := unpackArgSWriteOptions(opts)
	cargs, _ := unpackPCharString(args)
	__ret := C.pdf_parse_write_options(cctx, copts, cargs)
	packSWriteOptions(opts, copts)
	packSContext(ctx, cctx)
	__v := NewWriteOptionsRef(unsafe.Pointer(__ret))
	return __v
}

// HasUnsavedSigs function as declared in pdf/document.h:867
func HasUnsavedSigs(ctx []Context, doc []Document) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.pdf_has_unsaved_sigs(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// WriteDocument function as declared in pdf/document.h:874
func WriteDocument(ctx []Context, doc []Document, out []Output, opts []WriteOptions) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cout, _ := unpackArgSOutput(out)
	copts, _ := unpackArgSWriteOptions(opts)
	C.pdf_write_document(cctx, cdoc, cout, copts)
	packSWriteOptions(opts, copts)
	packSOutput(out, cout)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// SaveDocument function as declared in pdf/document.h:879
func SaveDocument(ctx []Context, doc []Document, filename string, opts []WriteOptions) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cfilename, _ := unpackPCharString(filename)
	copts, _ := unpackArgSWriteOptions(opts)
	C.pdf_save_document(cctx, cdoc, cfilename, copts)
	packSWriteOptions(opts, copts)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// CanBeSavedIncrementally function as declared in pdf/document.h:885
func CanBeSavedIncrementally(ctx []Context, doc []Document) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.pdf_can_be_saved_incrementally(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// LexbufInit function as declared in pdf/parse.h:22
func LexbufInit(ctx []Context, lexbuf []Lexbuf, size int32) {
	cctx, _ := unpackArgSContext(ctx)
	clexbuf, _ := unpackArgSLexbuf(lexbuf)
	csize, _ := (C.int)(size), cgoAllocsUnknown
	C.pdf_lexbuf_init(cctx, clexbuf, csize)
	packSLexbuf(lexbuf, clexbuf)
	packSContext(ctx, cctx)
}

// LexbufFin function as declared in pdf/parse.h:23
func LexbufFin(ctx []Context, lexbuf []Lexbuf) {
	cctx, _ := unpackArgSContext(ctx)
	clexbuf, _ := unpackArgSLexbuf(lexbuf)
	C.pdf_lexbuf_fin(cctx, clexbuf)
	packSLexbuf(lexbuf, clexbuf)
	packSContext(ctx, cctx)
}

// LexbufGrow function as declared in pdf/parse.h:24
func LexbufGrow(ctx []Context, lexbuf []Lexbuf) int32 {
	cctx, _ := unpackArgSContext(ctx)
	clexbuf, _ := unpackArgSLexbuf(lexbuf)
	__ret := C.pdf_lexbuf_grow(cctx, clexbuf)
	packSLexbuf(lexbuf, clexbuf)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// Lex function as declared in pdf/parse.h:26
func Lex(ctx []Context, f []Stream, lexbuf []Lexbuf) Token {
	cctx, _ := unpackArgSContext(ctx)
	cf, _ := unpackArgSStream(f)
	clexbuf, _ := unpackArgSLexbuf(lexbuf)
	__ret := C.pdf_lex(cctx, cf, clexbuf)
	packSLexbuf(lexbuf, clexbuf)
	packSStream(f, cf)
	packSContext(ctx, cctx)
	__v := (Token)(__ret)
	return __v
}

// LexNoString function as declared in pdf/parse.h:27
func LexNoString(ctx []Context, f []Stream, lexbuf []Lexbuf) Token {
	cctx, _ := unpackArgSContext(ctx)
	cf, _ := unpackArgSStream(f)
	clexbuf, _ := unpackArgSLexbuf(lexbuf)
	__ret := C.pdf_lex_no_string(cctx, cf, clexbuf)
	packSLexbuf(lexbuf, clexbuf)
	packSStream(f, cf)
	packSContext(ctx, cctx)
	__v := (Token)(__ret)
	return __v
}

// ParseArray function as declared in pdf/parse.h:29
func ParseArray(ctx []Context, doc []Document, f []Stream, buf []Lexbuf) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cf, _ := unpackArgSStream(f)
	cbuf, _ := unpackArgSLexbuf(buf)
	__ret := C.pdf_parse_array(cctx, cdoc, cf, cbuf)
	packSLexbuf(buf, cbuf)
	packSStream(f, cf)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// ParseDict function as declared in pdf/parse.h:30
func ParseDict(ctx []Context, doc []Document, f []Stream, buf []Lexbuf) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cf, _ := unpackArgSStream(f)
	cbuf, _ := unpackArgSLexbuf(buf)
	__ret := C.pdf_parse_dict(cctx, cdoc, cf, cbuf)
	packSLexbuf(buf, cbuf)
	packSStream(f, cf)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// ParseStmObj function as declared in pdf/parse.h:31
func ParseStmObj(ctx []Context, doc []Document, f []Stream, buf []Lexbuf) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cf, _ := unpackArgSStream(f)
	cbuf, _ := unpackArgSLexbuf(buf)
	__ret := C.pdf_parse_stm_obj(cctx, cdoc, cf, cbuf)
	packSLexbuf(buf, cbuf)
	packSStream(f, cf)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// ParseIndObj function as declared in pdf/parse.h:32
func ParseIndObj(ctx []Context, doc []Document, f []Stream, buf []Lexbuf, num []int32, gen []int32, stmOfs []Off, tryRepair []int32) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cf, _ := unpackArgSStream(f)
	cbuf, _ := unpackArgSLexbuf(buf)
	cnum, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&num)).Data)), cgoAllocsUnknown
	cgen, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&gen)).Data)), cgoAllocsUnknown
	cstmOfs, _ := (*C.fz_off_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&stmOfs)).Data)), cgoAllocsUnknown
	ctryRepair, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&tryRepair)).Data)), cgoAllocsUnknown
	__ret := C.pdf_parse_ind_obj(cctx, cdoc, cf, cbuf, cnum, cgen, cstmOfs, ctryRepair)
	packSLexbuf(buf, cbuf)
	packSStream(f, cf)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// AppendToken function as declared in pdf/parse.h:37
func AppendToken(ctx []Context, buf []Buffer, tok int32, lex []Lexbuf) {
	cctx, _ := unpackArgSContext(ctx)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	ctok, _ := (C.int)(tok), cgoAllocsUnknown
	clex, _ := unpackArgSLexbuf(lex)
	C.pdf_append_token(cctx, cbuf, ctok, clex)
	packSLexbuf(lex, clex)
	packSContext(ctx, cctx)
}

// CreateObject function as declared in pdf/xref.h:7
func CreateObject(ctx []Context, doc []Document) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.pdf_create_object(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// DeleteObject function as declared in pdf/xref.h:12
func DeleteObject(ctx []Context, doc []Document, num int32) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cnum, _ := (C.int)(num), cgoAllocsUnknown
	C.pdf_delete_object(cctx, cdoc, cnum)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// UpdateObject function as declared in pdf/xref.h:17
func UpdateObject(ctx []Context, doc []Document, num int32, obj []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cnum, _ := (C.int)(num), cgoAllocsUnknown
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	C.pdf_update_object(cctx, cdoc, cnum, cobj)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// UpdateStream function as declared in pdf/xref.h:26
func UpdateStream(ctx []Context, doc []Document, ref []Obj, buf []Buffer, compressed int32) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cref, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ref)).Data)), cgoAllocsUnknown
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	ccompressed, _ := (C.int)(compressed), cgoAllocsUnknown
	C.pdf_update_stream(cctx, cdoc, cref, cbuf, ccompressed)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// AddObject function as declared in pdf/xref.h:28
func AddObject(ctx []Context, doc []Document, obj []Obj) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_add_object(cctx, cdoc, cobj)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// AddObjectDrop function as declared in pdf/xref.h:29
func AddObjectDrop(ctx []Context, doc []Document, obj []Obj) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_add_object_drop(cctx, cdoc, cobj)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// AddStream function as declared in pdf/xref.h:30
func AddStream(ctx []Context, doc []Document, buf []Buffer, obj []Obj, compressed int32) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	ccompressed, _ := (C.int)(compressed), cgoAllocsUnknown
	__ret := C.pdf_add_stream(cctx, cdoc, cbuf, cobj, ccompressed)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// CacheObject function as declared in pdf/xref.h:76
func CacheObject(ctx []Context, doc []Document, num int32) *XrefEntry {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cnum, _ := (C.int)(num), cgoAllocsUnknown
	__ret := C.pdf_cache_object(cctx, cdoc, cnum)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewXrefEntryRef(unsafe.Pointer(__ret))
	return __v
}

// CountObjects function as declared in pdf/xref.h:78
func CountObjects(ctx []Context, doc []Document) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.pdf_count_objects(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ResolveIndirect function as declared in pdf/xref.h:79
func ResolveIndirect(ctx []Context, ref []Obj) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cref, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ref)).Data)), cgoAllocsUnknown
	__ret := C.pdf_resolve_indirect(cctx, cref)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// ResolveIndirectChain function as declared in pdf/xref.h:80
func ResolveIndirectChain(ctx []Context, ref []Obj) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cref, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ref)).Data)), cgoAllocsUnknown
	__ret := C.pdf_resolve_indirect_chain(cctx, cref)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// LoadObject function as declared in pdf/xref.h:81
func LoadObject(ctx []Context, doc []Document, num int32) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cnum, _ := (C.int)(num), cgoAllocsUnknown
	__ret := C.pdf_load_object(cctx, cdoc, cnum)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// LoadRawStreamNumber function as declared in pdf/xref.h:83
func LoadRawStreamNumber(ctx []Context, doc []Document, num int32) *Buffer {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cnum, _ := (C.int)(num), cgoAllocsUnknown
	__ret := C.pdf_load_raw_stream_number(cctx, cdoc, cnum)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Buffer)(unsafe.Pointer(&__ret))
	return __v
}

// LoadRawStream function as declared in pdf/xref.h:84
func LoadRawStream(ctx []Context, ref []Obj) *Buffer {
	cctx, _ := unpackArgSContext(ctx)
	cref, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ref)).Data)), cgoAllocsUnknown
	__ret := C.pdf_load_raw_stream(cctx, cref)
	packSContext(ctx, cctx)
	__v := *(**Buffer)(unsafe.Pointer(&__ret))
	return __v
}

// LoadStreamNumber function as declared in pdf/xref.h:85
func LoadStreamNumber(ctx []Context, doc []Document, num int32) *Buffer {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cnum, _ := (C.int)(num), cgoAllocsUnknown
	__ret := C.pdf_load_stream_number(cctx, cdoc, cnum)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Buffer)(unsafe.Pointer(&__ret))
	return __v
}

// LoadStream function as declared in pdf/xref.h:86
func LoadStream(ctx []Context, ref []Obj) *Buffer {
	cctx, _ := unpackArgSContext(ctx)
	cref, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ref)).Data)), cgoAllocsUnknown
	__ret := C.pdf_load_stream(cctx, cref)
	packSContext(ctx, cctx)
	__v := *(**Buffer)(unsafe.Pointer(&__ret))
	return __v
}

// OpenRawStreamNumber function as declared in pdf/xref.h:87
func OpenRawStreamNumber(ctx []Context, doc []Document, num int32) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cnum, _ := (C.int)(num), cgoAllocsUnknown
	__ret := C.pdf_open_raw_stream_number(cctx, cdoc, cnum)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenRawStream function as declared in pdf/xref.h:88
func OpenRawStream(ctx []Context, ref []Obj) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cref, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ref)).Data)), cgoAllocsUnknown
	__ret := C.pdf_open_raw_stream(cctx, cref)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenStreamNumber function as declared in pdf/xref.h:89
func OpenStreamNumber(ctx []Context, doc []Document, num int32) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cnum, _ := (C.int)(num), cgoAllocsUnknown
	__ret := C.pdf_open_stream_number(cctx, cdoc, cnum)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenStream function as declared in pdf/xref.h:90
func OpenStream(ctx []Context, ref []Obj) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cref, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ref)).Data)), cgoAllocsUnknown
	__ret := C.pdf_open_stream(cctx, cref)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenInlineStream function as declared in pdf/xref.h:92
func OpenInlineStream(ctx []Context, doc []Document, stmobj []Obj, length int32, chain []Stream, params []CompressionParams) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cstmobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&stmobj)).Data)), cgoAllocsUnknown
	clength, _ := (C.int)(length), cgoAllocsUnknown
	cchain, _ := unpackArgSStream(chain)
	cparams, _ := unpackArgSCompressionParams(params)
	__ret := C.pdf_open_inline_stream(cctx, cdoc, cstmobj, clength, cchain, cparams)
	packSCompressionParams(params, cparams)
	packSStream(chain, cchain)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// LoadCompressedStream function as declared in pdf/xref.h:93
func LoadCompressedStream(ctx []Context, doc []Document, num int32) *CompressedBuffer {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cnum, _ := (C.int)(num), cgoAllocsUnknown
	__ret := C.pdf_load_compressed_stream(cctx, cdoc, cnum)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewCompressedBufferRef(unsafe.Pointer(__ret))
	return __v
}

// LoadCompressedInlineImage function as declared in pdf/xref.h:94
func LoadCompressedInlineImage(ctx []Context, doc []Document, dict []Obj, length int32, cstm []Stream, indexed int32, image []CompressedImage) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cdict, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dict)).Data)), cgoAllocsUnknown
	clength, _ := (C.int)(length), cgoAllocsUnknown
	ccstm, _ := unpackArgSStream(cstm)
	cindexed, _ := (C.int)(indexed), cgoAllocsUnknown
	cimage, _ := (*C.fz_compressed_image)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&image)).Data)), cgoAllocsUnknown
	C.pdf_load_compressed_inline_image(cctx, cdoc, cdict, clength, ccstm, cindexed, cimage)
	packSStream(cstm, ccstm)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// OpenStreamWithOffset function as declared in pdf/xref.h:95
func OpenStreamWithOffset(ctx []Context, doc []Document, num int32, dict []Obj, stmOfs Off) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cnum, _ := (C.int)(num), cgoAllocsUnknown
	cdict, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dict)).Data)), cgoAllocsUnknown
	cstmOfs, _ := (C.fz_off_t)(stmOfs), cgoAllocsUnknown
	__ret := C.pdf_open_stream_with_offset(cctx, cdoc, cnum, cdict, cstmOfs)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenCompressedStream function as declared in pdf/xref.h:96
func OpenCompressedStream(ctx []Context, arg1 []CompressedBuffer) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	carg1, _ := unpackArgSCompressedBuffer(arg1)
	__ret := C.pdf_open_compressed_stream(cctx, carg1)
	packSCompressedBuffer(arg1, carg1)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenContentsStream function as declared in pdf/xref.h:97
func OpenContentsStream(ctx []Context, doc []Document, obj []Obj) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_open_contents_stream(cctx, cdoc, cobj)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// LoadStreamTruncated function as declared in pdf/xref.h:98
func LoadStreamTruncated(ctx []Context, doc []Document, num int32, truncated []int32) *Buffer {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cnum, _ := (C.int)(num), cgoAllocsUnknown
	ctruncated, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&truncated)).Data)), cgoAllocsUnknown
	__ret := C.pdf_load_stream_truncated(cctx, cdoc, cnum, ctruncated)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Buffer)(unsafe.Pointer(&__ret))
	return __v
}

// Trailer function as declared in pdf/xref.h:100
func Trailer(ctx []Context, doc []Document) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.pdf_trailer(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// SetPopulatingXrefTrailer function as declared in pdf/xref.h:101
func SetPopulatingXrefTrailer(ctx []Context, doc []Document, trailer []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	ctrailer, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&trailer)).Data)), cgoAllocsUnknown
	C.pdf_set_populating_xref_trailer(cctx, cdoc, ctrailer)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// XrefLen function as declared in pdf/xref.h:102
func XrefLen(ctx []Context, doc []Document) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.pdf_xref_len(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// GetPopulatingXrefEntry function as declared in pdf/xref.h:103
func GetPopulatingXrefEntry(ctx []Context, doc []Document, i int32) *XrefEntry {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	ci, _ := (C.int)(i), cgoAllocsUnknown
	__ret := C.pdf_get_populating_xref_entry(cctx, cdoc, ci)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewXrefEntryRef(unsafe.Pointer(__ret))
	return __v
}

// GetXrefEntry function as declared in pdf/xref.h:104
func GetXrefEntry(ctx []Context, doc []Document, i int32) *XrefEntry {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	ci, _ := (C.int)(i), cgoAllocsUnknown
	__ret := C.pdf_get_xref_entry(cctx, cdoc, ci)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewXrefEntryRef(unsafe.Pointer(__ret))
	return __v
}

// ReplaceXref function as declared in pdf/xref.h:105
func ReplaceXref(ctx []Context, doc []Document, entries []XrefEntry, n int32) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	centries, _ := unpackArgSXrefEntry(entries)
	cn, _ := (C.int)(n), cgoAllocsUnknown
	C.pdf_replace_xref(cctx, cdoc, centries, cn)
	packSXrefEntry(entries, centries)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// XrefEnsureIncrementalObject function as declared in pdf/xref.h:106
func XrefEnsureIncrementalObject(ctx []Context, doc []Document, num int32) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cnum, _ := (C.int)(num), cgoAllocsUnknown
	C.pdf_xref_ensure_incremental_object(cctx, cdoc, cnum)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// XrefIsIncremental function as declared in pdf/xref.h:107
func XrefIsIncremental(ctx []Context, doc []Document, num int32) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cnum, _ := (C.int)(num), cgoAllocsUnknown
	__ret := C.pdf_xref_is_incremental(cctx, cdoc, cnum)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// XrefStoreUnsavedSignature function as declared in pdf/xref.h:108
func XrefStoreUnsavedSignature(ctx []Context, doc []Document, field []Obj, signer []Signer) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cfield, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&field)).Data)), cgoAllocsUnknown
	csigner, _ := (*C.pdf_signer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&signer)).Data)), cgoAllocsUnknown
	C.pdf_xref_store_unsaved_signature(cctx, cdoc, cfield, csigner)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// XrefObjIsUnsavedSignature function as declared in pdf/xref.h:109
func XrefObjIsUnsavedSignature(doc []Document, obj []Obj) int32 {
	cdoc, _ := unpackArgSDocument(doc)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_xref_obj_is_unsaved_signature(cdoc, cobj)
	packSDocument(doc, cdoc)
	__v := (int32)(__ret)
	return __v
}

// RepairXref function as declared in pdf/xref.h:111
func RepairXref(ctx []Context, doc []Document) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	C.pdf_repair_xref(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// RepairObjStms function as declared in pdf/xref.h:112
func RepairObjStms(ctx []Context, doc []Document) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	C.pdf_repair_obj_stms(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// EnsureSolidXref function as declared in pdf/xref.h:113
func EnsureSolidXref(ctx []Context, doc []Document, num int32) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cnum, _ := (C.int)(num), cgoAllocsUnknown
	C.pdf_ensure_solid_xref(cctx, cdoc, cnum)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// MarkXref function as declared in pdf/xref.h:114
func MarkXref(ctx []Context, doc []Document) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	C.pdf_mark_xref(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// ClearXref function as declared in pdf/xref.h:115
func ClearXref(ctx []Context, doc []Document) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	C.pdf_clear_xref(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// ClearXrefToMark function as declared in pdf/xref.h:116
func ClearXrefToMark(ctx []Context, doc []Document) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	C.pdf_clear_xref_to_mark(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// RepairObj function as declared in pdf/xref.h:118
func RepairObj(ctx []Context, doc []Document, buf []Lexbuf, stmofsp []Off, stmlenp []int32, encrypt [][]Obj, id [][]Obj, page [][]Obj, tmpofs []Off, root [][]Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cbuf, _ := unpackArgSLexbuf(buf)
	cstmofsp, _ := (*C.fz_off_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&stmofsp)).Data)), cgoAllocsUnknown
	cstmlenp, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&stmlenp)).Data)), cgoAllocsUnknown
	cencrypt, _ := unpackArgSSObj(encrypt)
	cid, _ := unpackArgSSObj(id)
	cpage, _ := unpackArgSSObj(page)
	ctmpofs, _ := (*C.fz_off_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&tmpofs)).Data)), cgoAllocsUnknown
	croot, _ := unpackArgSSObj(root)
	__ret := C.pdf_repair_obj(cctx, cdoc, cbuf, cstmofsp, cstmlenp, cencrypt, cid, cpage, ctmpofs, croot)
	packSSObj(root, croot)
	packSSObj(page, cpage)
	packSSObj(id, cid)
	packSSObj(encrypt, cencrypt)
	packSLexbuf(buf, cbuf)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ProgressiveAdvance function as declared in pdf/xref.h:120
func ProgressiveAdvance(ctx []Context, doc []Document, pagenum int32) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cpagenum, _ := (C.int)(pagenum), cgoAllocsUnknown
	__ret := C.pdf_progressive_advance(cctx, cdoc, cpagenum)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// PrintXref function as declared in pdf/xref.h:122
func PrintXref(ctx []Context, arg1 []Document) {
	cctx, _ := unpackArgSContext(ctx)
	carg1, _ := unpackArgSDocument(arg1)
	C.pdf_print_xref(cctx, carg1)
	packSDocument(arg1, carg1)
	packSContext(ctx, cctx)
}

// NewCrypt function as declared in pdf/crypt.h:8
func NewCrypt(ctx []Context, enc []Obj, id []Obj) *Crypt {
	cctx, _ := unpackArgSContext(ctx)
	cenc, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&enc)).Data)), cgoAllocsUnknown
	cid, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&id)).Data)), cgoAllocsUnknown
	__ret := C.pdf_new_crypt(cctx, cenc, cid)
	packSContext(ctx, cctx)
	__v := *(**Crypt)(unsafe.Pointer(&__ret))
	return __v
}

// DropCrypt function as declared in pdf/crypt.h:9
func DropCrypt(ctx []Context, crypt []Crypt) {
	cctx, _ := unpackArgSContext(ctx)
	ccrypt, _ := (*C.pdf_crypt)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&crypt)).Data)), cgoAllocsUnknown
	C.pdf_drop_crypt(cctx, ccrypt)
	packSContext(ctx, cctx)
}

// CryptObj function as declared in pdf/crypt.h:11
func CryptObj(ctx []Context, crypt []Crypt, obj []Obj, num int32, gen int32) {
	cctx, _ := unpackArgSContext(ctx)
	ccrypt, _ := (*C.pdf_crypt)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&crypt)).Data)), cgoAllocsUnknown
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	cnum, _ := (C.int)(num), cgoAllocsUnknown
	cgen, _ := (C.int)(gen), cgoAllocsUnknown
	C.pdf_crypt_obj(cctx, ccrypt, cobj, cnum, cgen)
	packSContext(ctx, cctx)
}

// CryptBuffer function as declared in pdf/crypt.h:12
func CryptBuffer(ctx []Context, crypt []Crypt, buf []Buffer, num int32, gen int32) {
	cctx, _ := unpackArgSContext(ctx)
	ccrypt, _ := (*C.pdf_crypt)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&crypt)).Data)), cgoAllocsUnknown
	cbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	cnum, _ := (C.int)(num), cgoAllocsUnknown
	cgen, _ := (C.int)(gen), cgoAllocsUnknown
	C.pdf_crypt_buffer(cctx, ccrypt, cbuf, cnum, cgen)
	packSContext(ctx, cctx)
}

// OpenCrypt function as declared in pdf/crypt.h:13
func OpenCrypt(ctx []Context, chain []Stream, crypt []Crypt, num int32, gen int32) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cchain, _ := unpackArgSStream(chain)
	ccrypt, _ := (*C.pdf_crypt)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&crypt)).Data)), cgoAllocsUnknown
	cnum, _ := (C.int)(num), cgoAllocsUnknown
	cgen, _ := (C.int)(gen), cgoAllocsUnknown
	__ret := C.pdf_open_crypt(cctx, cchain, ccrypt, cnum, cgen)
	packSStream(chain, cchain)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// OpenCryptWithFilter function as declared in pdf/crypt.h:14
func OpenCryptWithFilter(ctx []Context, chain []Stream, crypt []Crypt, name []Obj, num int32, gen int32) *Stream {
	cctx, _ := unpackArgSContext(ctx)
	cchain, _ := unpackArgSStream(chain)
	ccrypt, _ := (*C.pdf_crypt)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&crypt)).Data)), cgoAllocsUnknown
	cname, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&name)).Data)), cgoAllocsUnknown
	cnum, _ := (C.int)(num), cgoAllocsUnknown
	cgen, _ := (C.int)(gen), cgoAllocsUnknown
	__ret := C.pdf_open_crypt_with_filter(cctx, cchain, ccrypt, cname, cnum, cgen)
	packSStream(chain, cchain)
	packSContext(ctx, cctx)
	__v := NewStreamRef(unsafe.Pointer(__ret))
	return __v
}

// CryptVersion function as declared in pdf/crypt.h:16
func CryptVersion(ctx []Context, doc []Document) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.pdf_crypt_version(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// CryptRevision function as declared in pdf/crypt.h:17
func CryptRevision(ctx []Context, doc []Document) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.pdf_crypt_revision(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// CryptMethod function as declared in pdf/crypt.h:18
func CryptMethod(ctx []Context, doc []Document) *byte {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.pdf_crypt_method(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// CryptLength function as declared in pdf/crypt.h:19
func CryptLength(ctx []Context, doc []Document) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.pdf_crypt_length(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// CryptKey function as declared in pdf/crypt.h:20
func CryptKey(ctx []Context, doc []Document) *byte {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.pdf_crypt_key(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// PrintCrypt function as declared in pdf/crypt.h:22
func PrintCrypt(ctx []Context, out []Output, crypt []Crypt) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	ccrypt, _ := (*C.pdf_crypt)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&crypt)).Data)), cgoAllocsUnknown
	C.pdf_print_crypt(cctx, cout, ccrypt)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// DropDesignatedName function as declared in pdf/crypt.h:34
func DropDesignatedName(ctx []Context, dn []DesignatedName) {
	cctx, _ := unpackArgSContext(ctx)
	cdn, _ := unpackArgSDesignatedName(dn)
	C.pdf_drop_designated_name(cctx, cdn)
	packSDesignatedName(dn, cdn)
	packSContext(ctx, cctx)
}

// ReadPfx function as declared in pdf/crypt.h:36
func ReadPfx(ctx []Context, sigfile string, password string) *Signer {
	cctx, _ := unpackArgSContext(ctx)
	csigfile, _ := unpackPCharString(sigfile)
	cpassword, _ := unpackPCharString(password)
	__ret := C.pdf_read_pfx(cctx, csigfile, cpassword)
	packSContext(ctx, cctx)
	__v := *(**Signer)(unsafe.Pointer(&__ret))
	return __v
}

// KeepSigner function as declared in pdf/crypt.h:37
func KeepSigner(ctx []Context, signer []Signer) *Signer {
	cctx, _ := unpackArgSContext(ctx)
	csigner, _ := (*C.pdf_signer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&signer)).Data)), cgoAllocsUnknown
	__ret := C.pdf_keep_signer(cctx, csigner)
	packSContext(ctx, cctx)
	__v := *(**Signer)(unsafe.Pointer(&__ret))
	return __v
}

// DropSigner function as declared in pdf/crypt.h:38
func DropSigner(ctx []Context, signer []Signer) {
	cctx, _ := unpackArgSContext(ctx)
	csigner, _ := (*C.pdf_signer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&signer)).Data)), cgoAllocsUnknown
	C.pdf_drop_signer(cctx, csigner)
	packSContext(ctx, cctx)
}

// SignerDesignatedName function as declared in pdf/crypt.h:39
func SignerDesignatedName(ctx []Context, signer []Signer) *DesignatedName {
	cctx, _ := unpackArgSContext(ctx)
	csigner, _ := (*C.pdf_signer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&signer)).Data)), cgoAllocsUnknown
	__ret := C.pdf_signer_designated_name(cctx, csigner)
	packSContext(ctx, cctx)
	__v := NewDesignatedNameRef(unsafe.Pointer(__ret))
	return __v
}

// WriteDigest function as declared in pdf/crypt.h:40
func WriteDigest(ctx []Context, doc []Document, filename string, byteRange []Obj, digestOffset int32, digestLength int32, signer []Signer) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cfilename, _ := unpackPCharString(filename)
	cbyteRange, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&byteRange)).Data)), cgoAllocsUnknown
	cdigestOffset, _ := (C.int)(digestOffset), cgoAllocsUnknown
	cdigestLength, _ := (C.int)(digestLength), cgoAllocsUnknown
	csigner, _ := (*C.pdf_signer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&signer)).Data)), cgoAllocsUnknown
	C.pdf_write_digest(cctx, cdoc, cfilename, cbyteRange, cdigestOffset, cdigestLength, csigner)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// SignatureWidgetByteRange function as declared in pdf/crypt.h:45
func SignatureWidgetByteRange(ctx []Context, doc []Document, widget []Widget, byteRange [][2]int32) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cwidget, _ := (*C.pdf_widget)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&widget)).Data)), cgoAllocsUnknown
	cbyteRange, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&byteRange)).Data)), cgoAllocsUnknown
	__ret := C.pdf_signature_widget_byte_range(cctx, cdoc, cwidget, cbyteRange)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// SignatureWidgetContents function as declared in pdf/crypt.h:50
func SignatureWidgetContents(ctx []Context, doc []Document, widget []Widget, contents [][]byte) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cwidget, _ := (*C.pdf_widget)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&widget)).Data)), cgoAllocsUnknown
	ccontents, _ := unpackArgSSByte(contents)
	__ret := C.pdf_signature_widget_contents(cctx, cdoc, cwidget, ccontents)
	packSSByte(contents, ccontents)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// CheckSignature function as declared in pdf/crypt.h:55
func CheckSignature(ctx []Context, doc []Document, widget []Widget, file []byte, ebuf []byte, ebufsize int32) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cwidget, _ := (*C.pdf_widget)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&widget)).Data)), cgoAllocsUnknown
	cfile, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&file)).Data)), cgoAllocsUnknown
	cebuf, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ebuf)).Data)), cgoAllocsUnknown
	cebufsize, _ := (C.int)(ebufsize), cgoAllocsUnknown
	__ret := C.pdf_check_signature(cctx, cdoc, cwidget, cfile, cebuf, cebufsize)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// SignSignature function as declared in pdf/crypt.h:60
func SignSignature(ctx []Context, doc []Document, widget []Widget, sigfile string, password string) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cwidget, _ := (*C.pdf_widget)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&widget)).Data)), cgoAllocsUnknown
	csigfile, _ := unpackPCharString(sigfile)
	cpassword, _ := unpackPCharString(password)
	C.pdf_sign_signature(cctx, cdoc, cwidget, csigfile, cpassword)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// LookupPageNumber function as declared in pdf/page.h:4
func LookupPageNumber(ctx []Context, doc []Document, pageobj []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cpageobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&pageobj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_lookup_page_number(cctx, cdoc, cpageobj)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// CountPages function as declared in pdf/page.h:5
func CountPages(ctx []Context, doc []Document) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.pdf_count_pages(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// LookupPageObj function as declared in pdf/page.h:6
func LookupPageObj(ctx []Context, doc []Document, needle int32) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cneedle, _ := (C.int)(needle), cgoAllocsUnknown
	__ret := C.pdf_lookup_page_obj(cctx, cdoc, cneedle)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// LoadPageTree function as declared in pdf/page.h:7
func LoadPageTree(ctx []Context, doc []Document) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	C.pdf_load_page_tree(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// DropPageTree function as declared in pdf/page.h:8
func DropPageTree(ctx []Context, doc []Document) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	C.pdf_drop_page_tree(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// LookupAnchor function as declared in pdf/page.h:16
func LookupAnchor(ctx []Context, doc []Document, name string, xp []float32, yp []float32) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cname, _ := unpackPCharString(name)
	cxp, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&xp)).Data)), cgoAllocsUnknown
	cyp, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&yp)).Data)), cgoAllocsUnknown
	__ret := C.pdf_lookup_anchor(cctx, cdoc, cname, cxp, cyp)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// FlattenInheritablePageItems function as declared in pdf/page.h:24
func FlattenInheritablePageItems(ctx []Context, page []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&page)).Data)), cgoAllocsUnknown
	C.pdf_flatten_inheritable_page_items(cctx, cpage)
	packSContext(ctx, cctx)
}

// LoadPage function as declared in pdf/page.h:36
func LoadPage(ctx []Context, doc []Document, number int32) *Page {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cnumber, _ := (C.int)(number), cgoAllocsUnknown
	__ret := C.pdf_load_page(cctx, cdoc, cnumber)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewPageRef(unsafe.Pointer(__ret))
	return __v
}

// PageObjTransform function as declared in pdf/page.h:38
func PageObjTransform(ctx []Context, pageobj []Obj, pageMediabox []Rect, pageCtm []Matrix) {
	cctx, _ := unpackArgSContext(ctx)
	cpageobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&pageobj)).Data)), cgoAllocsUnknown
	cpageMediabox, _ := unpackArgSRect(pageMediabox)
	cpageCtm, _ := unpackArgSMatrix(pageCtm)
	C.pdf_page_obj_transform(cctx, cpageobj, cpageMediabox, cpageCtm)
	packSMatrix(pageCtm, cpageCtm)
	packSRect(pageMediabox, cpageMediabox)
	packSContext(ctx, cctx)
}

// PageTransform function as declared in pdf/page.h:39
func PageTransform(ctx []Context, page []Page, mediabox []Rect, ctm []Matrix) {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	cmediabox, _ := unpackArgSRect(mediabox)
	cctm, _ := unpackArgSMatrix(ctm)
	C.pdf_page_transform(cctx, cpage, cmediabox, cctm)
	packSMatrix(ctm, cctm)
	packSRect(mediabox, cmediabox)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
}

// PageResources function as declared in pdf/page.h:40
func PageResources(ctx []Context, page []Page) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	__ret := C.pdf_page_resources(cctx, cpage)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// PageContents function as declared in pdf/page.h:41
func PageContents(ctx []Context, page []Page) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	__ret := C.pdf_page_contents(cctx, cpage)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// PageGroup function as declared in pdf/page.h:42
func PageGroup(ctx []Context, page []Page) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	__ret := C.pdf_page_group(cctx, cpage)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// PageSeparations function as declared in pdf/page.h:47
func PageSeparations(ctx []Context, page []Page) *Separations {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	__ret := C.pdf_page_separations(cctx, cpage)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
	__v := *(**Separations)(unsafe.Pointer(&__ret))
	return __v
}

// LoadLinks function as declared in pdf/page.h:49
func LoadLinks(ctx []Context, page []Page) *Link {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	__ret := C.pdf_load_links(cctx, cpage)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
	__v := NewLinkRef(unsafe.Pointer(__ret))
	return __v
}

// BoundPage function as declared in pdf/page.h:59
func BoundPage(ctx []Context, page []Page, arg2 []Rect) *Rect {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	carg2, _ := unpackArgSRect(arg2)
	__ret := C.pdf_bound_page(cctx, cpage, carg2)
	packSRect(arg2, carg2)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
	__v := NewRectRef(unsafe.Pointer(__ret))
	return __v
}

// RunPage function as declared in pdf/page.h:71
func RunPage(ctx []Context, page []Page, dev []Device, ctm []Matrix, cookie []Cookie) {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	cdev, _ := unpackArgSDevice(dev)
	cctm, _ := unpackArgSMatrix(ctm)
	ccookie, _ := unpackArgSCookie(cookie)
	C.pdf_run_page(cctx, cpage, cdev, cctm, ccookie)
	packSCookie(cookie, ccookie)
	packSMatrix(ctm, cctm)
	packSDevice(dev, cdev)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
}

// RunPageWithUsage function as declared in pdf/page.h:89
func RunPageWithUsage(ctx []Context, doc []Document, page []Page, dev []Device, ctm []Matrix, usage string, cookie []Cookie) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cpage, _ := unpackArgSPage(page)
	cdev, _ := unpackArgSDevice(dev)
	cctm, _ := unpackArgSMatrix(ctm)
	cusage, _ := unpackPCharString(usage)
	ccookie, _ := unpackArgSCookie(cookie)
	C.pdf_run_page_with_usage(cctx, cdoc, cpage, cdev, cctm, cusage, ccookie)
	packSCookie(cookie, ccookie)
	packSMatrix(ctm, cctm)
	packSDevice(dev, cdev)
	packSPage(page, cpage)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// RunPageContents function as declared in pdf/page.h:102
func RunPageContents(ctx []Context, page []Page, dev []Device, ctm []Matrix, cookie []Cookie) {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	cdev, _ := unpackArgSDevice(dev)
	cctm, _ := unpackArgSMatrix(ctm)
	ccookie, _ := unpackArgSCookie(cookie)
	C.pdf_run_page_contents(cctx, cpage, cdev, cctm, ccookie)
	packSCookie(cookie, ccookie)
	packSMatrix(ctm, cctm)
	packSDevice(dev, cdev)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
}

// CleanPageContents function as declared in pdf/page.h:141
func CleanPageContents(ctx []Context, doc []Document, page []Page, cookie []Cookie, proc PageContentsProcessFn, procArg unsafe.Pointer, ascii int32) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cpage, _ := unpackArgSPage(page)
	ccookie, _ := unpackArgSCookie(cookie)
	cproc, _ := proc.PassRef()
	cprocArg, _ := procArg, cgoAllocsUnknown
	cascii, _ := (C.int)(ascii), cgoAllocsUnknown
	C.pdf_clean_page_contents(cctx, cdoc, cpage, ccookie, cproc, cprocArg, cascii)
	packSCookie(cookie, ccookie)
	packSPage(page, cpage)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// CleanAnnotContents function as declared in pdf/page.h:168
func CleanAnnotContents(ctx []Context, doc []Document, annot []Annot, cookie []Cookie, proc PageContentsProcessFn, procArg unsafe.Pointer, ascii int32) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cannot, _ := unpackArgSAnnot(annot)
	ccookie, _ := unpackArgSCookie(cookie)
	cproc, _ := proc.PassRef()
	cprocArg, _ := procArg, cgoAllocsUnknown
	cascii, _ := (C.int)(ascii), cgoAllocsUnknown
	C.pdf_clean_annot_contents(cctx, cdoc, cannot, ccookie, cproc, cprocArg, cascii)
	packSCookie(cookie, ccookie)
	packSAnnot(annot, cannot)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// PagePresentation function as declared in pdf/page.h:174
func PagePresentation(ctx []Context, page []Page, transition []Transition, duration []float32) *Transition {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	ctransition, _ := unpackArgSTransition(transition)
	cduration, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&duration)).Data)), cgoAllocsUnknown
	__ret := C.pdf_page_presentation(cctx, cpage, ctransition, cduration)
	packSTransition(transition, ctransition)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
	__v := NewTransitionRef(unsafe.Pointer(__ret))
	return __v
}

// LoadDefaultColorspaces function as declared in pdf/page.h:179
func LoadDefaultColorspaces(ctx []Context, doc []Document, page []Page) *DefaultColorspaces {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cpage, _ := unpackArgSPage(page)
	__ret := C.pdf_load_default_colorspaces(cctx, cdoc, cpage)
	packSPage(page, cpage)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**DefaultColorspaces)(unsafe.Pointer(&__ret))
	return __v
}

// StoreItem function as declared in pdf/resource.h:7
func StoreItem(ctx []Context, key []Obj, val unsafe.Pointer, itemsize uint) {
	cctx, _ := unpackArgSContext(ctx)
	ckey, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&key)).Data)), cgoAllocsUnknown
	cval, _ := val, cgoAllocsUnknown
	citemsize, _ := (C.size_t)(itemsize), cgoAllocsUnknown
	C.pdf_store_item(cctx, ckey, cval, citemsize)
	packSContext(ctx, cctx)
}

// FindItem function as declared in pdf/resource.h:8
func FindItem(ctx []Context, drop StoreDropFn, key []Obj) unsafe.Pointer {
	cctx, _ := unpackArgSContext(ctx)
	cdrop, _ := drop.PassRef()
	ckey, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&key)).Data)), cgoAllocsUnknown
	__ret := C.pdf_find_item(cctx, cdrop, ckey)
	packSContext(ctx, cctx)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// RemoveItem function as declared in pdf/resource.h:9
func RemoveItem(ctx []Context, drop StoreDropFn, key []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cdrop, _ := drop.PassRef()
	ckey, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&key)).Data)), cgoAllocsUnknown
	C.pdf_remove_item(cctx, cdrop, ckey)
	packSContext(ctx, cctx)
}

// EmptyStore function as declared in pdf/resource.h:10
func EmptyStore(ctx []Context, doc []Document) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	C.pdf_empty_store(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// FindFontResource function as declared in pdf/resource.h:20
func FindFontResource(ctx []Context, doc []Document, item []Buffer, md5 *[16]byte) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	citem, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&item)).Data)), cgoAllocsUnknown
	cmd5, _ := *(**C.uchar)(unsafe.Pointer(&md5)), cgoAllocsUnknown
	__ret := C.pdf_find_font_resource(cctx, cdoc, citem, cmd5)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// InsertFontResource function as declared in pdf/resource.h:21
func InsertFontResource(ctx []Context, doc []Document, md5 *[16]byte, obj []Obj) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cmd5, _ := *(**C.uchar)(unsafe.Pointer(&md5)), cgoAllocsUnknown
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_insert_font_resource(cctx, cdoc, cmd5, cobj)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// FindImageResource function as declared in pdf/resource.h:22
func FindImageResource(ctx []Context, doc []Document, item []Image, md5 *[16]byte) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	citem, _ := unpackArgSImage(item)
	cmd5, _ := *(**C.uchar)(unsafe.Pointer(&md5)), cgoAllocsUnknown
	__ret := C.pdf_find_image_resource(cctx, cdoc, citem, cmd5)
	packSImage(item, citem)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// InsertImageResource function as declared in pdf/resource.h:23
func InsertImageResource(ctx []Context, doc []Document, md5 *[16]byte, obj []Obj) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cmd5, _ := *(**C.uchar)(unsafe.Pointer(&md5)), cgoAllocsUnknown
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_insert_image_resource(cctx, cdoc, cmd5, cobj)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// DropResourceTables function as declared in pdf/resource.h:24
func DropResourceTables(ctx []Context, doc []Document) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	C.pdf_drop_resource_tables(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// EvalFunction function as declared in pdf/resource.h:32
func EvalFunction(ctx []Context, _func []Function, in []float32, inlen int32, out []float32, outlen int32) {
	cctx, _ := unpackArgSContext(ctx)
	c_func, _ := (*C.pdf_function)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&_func)).Data)), cgoAllocsUnknown
	cin, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&in)).Data)), cgoAllocsUnknown
	cinlen, _ := (C.int)(inlen), cgoAllocsUnknown
	cout, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&out)).Data)), cgoAllocsUnknown
	coutlen, _ := (C.int)(outlen), cgoAllocsUnknown
	C.pdf_eval_function(cctx, c_func, cin, cinlen, cout, coutlen)
	packSContext(ctx, cctx)
}

// KeepFunction function as declared in pdf/resource.h:33
func KeepFunction(ctx []Context, _func []Function) *Function {
	cctx, _ := unpackArgSContext(ctx)
	c_func, _ := (*C.pdf_function)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&_func)).Data)), cgoAllocsUnknown
	__ret := C.pdf_keep_function(cctx, c_func)
	packSContext(ctx, cctx)
	__v := *(**Function)(unsafe.Pointer(&__ret))
	return __v
}

// DropFunction function as declared in pdf/resource.h:34
func DropFunction(ctx []Context, _func []Function) {
	cctx, _ := unpackArgSContext(ctx)
	c_func, _ := (*C.pdf_function)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&_func)).Data)), cgoAllocsUnknown
	C.pdf_drop_function(cctx, c_func)
	packSContext(ctx, cctx)
}

// FunctionSize function as declared in pdf/resource.h:35
func FunctionSize(ctx []Context, _func []Function) uint {
	cctx, _ := unpackArgSContext(ctx)
	c_func, _ := (*C.pdf_function)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&_func)).Data)), cgoAllocsUnknown
	__ret := C.pdf_function_size(cctx, c_func)
	packSContext(ctx, cctx)
	__v := (uint)(__ret)
	return __v
}

// LoadFunction function as declared in pdf/resource.h:36
func LoadFunction(ctx []Context, ref []Obj, in int32, out int32) *Function {
	cctx, _ := unpackArgSContext(ctx)
	cref, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ref)).Data)), cgoAllocsUnknown
	cin, _ := (C.int)(in), cgoAllocsUnknown
	cout, _ := (C.int)(out), cgoAllocsUnknown
	__ret := C.pdf_load_function(cctx, cref, cin, cout)
	packSContext(ctx, cctx)
	__v := *(**Function)(unsafe.Pointer(&__ret))
	return __v
}

// DocumentOutputIntent function as declared in pdf/resource.h:38
func DocumentOutputIntent(ctx []Context, doc []Document) *Colorspace {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.pdf_document_output_intent(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Colorspace)(unsafe.Pointer(&__ret))
	return __v
}

// LoadColorspace function as declared in pdf/resource.h:39
func LoadColorspace(ctx []Context, obj []Obj) *Colorspace {
	cctx, _ := unpackArgSContext(ctx)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_load_colorspace(cctx, cobj)
	packSContext(ctx, cctx)
	__v := *(**Colorspace)(unsafe.Pointer(&__ret))
	return __v
}

// IsTintColorspace function as declared in pdf/resource.h:40
func IsTintColorspace(ctx []Context, cs []Colorspace) int32 {
	cctx, _ := unpackArgSContext(ctx)
	ccs, _ := (*C.fz_colorspace)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cs)).Data)), cgoAllocsUnknown
	__ret := C.pdf_is_tint_colorspace(cctx, ccs)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// LoadShading function as declared in pdf/resource.h:42
func LoadShading(ctx []Context, doc []Document, obj []Obj) *Shade {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_load_shading(cctx, cdoc, cobj)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewShadeRef(unsafe.Pointer(__ret))
	return __v
}

// LoadInlineImage function as declared in pdf/resource.h:44
func LoadInlineImage(ctx []Context, doc []Document, rdb []Obj, dict []Obj, file []Stream) *Image {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	crdb, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&rdb)).Data)), cgoAllocsUnknown
	cdict, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dict)).Data)), cgoAllocsUnknown
	cfile, _ := unpackArgSStream(file)
	__ret := C.pdf_load_inline_image(cctx, cdoc, crdb, cdict, cfile)
	packSStream(file, cfile)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewImageRef(unsafe.Pointer(__ret))
	return __v
}

// IsJpxImage function as declared in pdf/resource.h:45
func IsJpxImage(ctx []Context, dict []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdict, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dict)).Data)), cgoAllocsUnknown
	__ret := C.pdf_is_jpx_image(cctx, cdict)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// LoadImage function as declared in pdf/resource.h:47
func LoadImage(ctx []Context, doc []Document, obj []Obj) *Image {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_load_image(cctx, cdoc, cobj)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewImageRef(unsafe.Pointer(__ret))
	return __v
}

// AddImage function as declared in pdf/resource.h:49
func AddImage(ctx []Context, doc []Document, image []Image, mask int32) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cimage, _ := unpackArgSImage(image)
	cmask, _ := (C.int)(mask), cgoAllocsUnknown
	__ret := C.pdf_add_image(cctx, cdoc, cimage, cmask)
	packSImage(image, cimage)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// LoadPattern function as declared in pdf/resource.h:71
func LoadPattern(ctx []Context, doc []Document, obj []Obj) *Pattern {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_load_pattern(cctx, cdoc, cobj)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewPatternRef(unsafe.Pointer(__ret))
	return __v
}

// KeepPattern function as declared in pdf/resource.h:72
func KeepPattern(ctx []Context, pat []Pattern) *Pattern {
	cctx, _ := unpackArgSContext(ctx)
	cpat, _ := unpackArgSPattern(pat)
	__ret := C.pdf_keep_pattern(cctx, cpat)
	packSPattern(pat, cpat)
	packSContext(ctx, cctx)
	__v := NewPatternRef(unsafe.Pointer(__ret))
	return __v
}

// DropPattern function as declared in pdf/resource.h:73
func DropPattern(ctx []Context, pat []Pattern) {
	cctx, _ := unpackArgSContext(ctx)
	cpat, _ := unpackArgSPattern(pat)
	C.pdf_drop_pattern(cctx, cpat)
	packSPattern(pat, cpat)
	packSContext(ctx, cctx)
}

// LoadXobject function as declared in pdf/resource.h:88
func LoadXobject(ctx []Context, doc []Document, obj []Obj) *Xobject {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_load_xobject(cctx, cdoc, cobj)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewXobjectRef(unsafe.Pointer(__ret))
	return __v
}

// NewXobject function as declared in pdf/resource.h:89
func NewXobject(ctx []Context, doc []Document, bbox []Rect, mat []Matrix) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cbbox, _ := unpackArgSRect(bbox)
	cmat, _ := unpackArgSMatrix(mat)
	__ret := C.pdf_new_xobject(cctx, cdoc, cbbox, cmat)
	packSMatrix(mat, cmat)
	packSRect(bbox, cbbox)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// KeepXobject function as declared in pdf/resource.h:90
func KeepXobject(ctx []Context, xobj []Xobject) *Xobject {
	cctx, _ := unpackArgSContext(ctx)
	cxobj, _ := unpackArgSXobject(xobj)
	__ret := C.pdf_keep_xobject(cctx, cxobj)
	packSXobject(xobj, cxobj)
	packSContext(ctx, cctx)
	__v := NewXobjectRef(unsafe.Pointer(__ret))
	return __v
}

// DropXobject function as declared in pdf/resource.h:91
func DropXobject(ctx []Context, xobj []Xobject) {
	cctx, _ := unpackArgSContext(ctx)
	cxobj, _ := unpackArgSXobject(xobj)
	C.pdf_drop_xobject(cctx, cxobj)
	packSXobject(xobj, cxobj)
	packSContext(ctx, cctx)
}

// UpdateXobjectContents function as declared in pdf/resource.h:92
func UpdateXobjectContents(ctx []Context, doc []Document, form []Xobject, buffer []Buffer) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cform, _ := unpackArgSXobject(form)
	cbuffer, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buffer)).Data)), cgoAllocsUnknown
	C.pdf_update_xobject_contents(cctx, cdoc, cform, cbuffer)
	packSXobject(form, cform)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// UpdateAppearance function as declared in pdf/resource.h:94
func UpdateAppearance(ctx []Context, doc []Document, annot []Annot) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cannot, _ := unpackArgSAnnot(annot)
	C.pdf_update_appearance(cctx, cdoc, cannot)
	packSAnnot(annot, cannot)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// XobjectResources function as declared in pdf/resource.h:96
func XobjectResources(ctx []Context, xobj []Xobject) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cxobj, _ := unpackArgSXobject(xobj)
	__ret := C.pdf_xobject_resources(cctx, cxobj)
	packSXobject(xobj, cxobj)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// XobjectBbox function as declared in pdf/resource.h:97
func XobjectBbox(ctx []Context, xobj []Xobject, bbox []Rect) *Rect {
	cctx, _ := unpackArgSContext(ctx)
	cxobj, _ := unpackArgSXobject(xobj)
	cbbox, _ := unpackArgSRect(bbox)
	__ret := C.pdf_xobject_bbox(cctx, cxobj, cbbox)
	packSRect(bbox, cbbox)
	packSXobject(xobj, cxobj)
	packSContext(ctx, cctx)
	__v := NewRectRef(unsafe.Pointer(__ret))
	return __v
}

// XobjectMatrix function as declared in pdf/resource.h:98
func XobjectMatrix(ctx []Context, xobj []Xobject, matrix []Matrix) *Matrix {
	cctx, _ := unpackArgSContext(ctx)
	cxobj, _ := unpackArgSXobject(xobj)
	cmatrix, _ := unpackArgSMatrix(matrix)
	__ret := C.pdf_xobject_matrix(cctx, cxobj, cmatrix)
	packSMatrix(matrix, cmatrix)
	packSXobject(xobj, cxobj)
	packSContext(ctx, cctx)
	__v := NewMatrixRef(unsafe.Pointer(__ret))
	return __v
}

// XobjectIsolated function as declared in pdf/resource.h:99
func XobjectIsolated(ctx []Context, xobj []Xobject) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cxobj, _ := unpackArgSXobject(xobj)
	__ret := C.pdf_xobject_isolated(cctx, cxobj)
	packSXobject(xobj, cxobj)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// XobjectKnockout function as declared in pdf/resource.h:100
func XobjectKnockout(ctx []Context, xobj []Xobject) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cxobj, _ := unpackArgSXobject(xobj)
	__ret := C.pdf_xobject_knockout(cctx, cxobj)
	packSXobject(xobj, cxobj)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// XobjectTransparency function as declared in pdf/resource.h:101
func XobjectTransparency(ctx []Context, xobj []Xobject) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cxobj, _ := unpackArgSXobject(xobj)
	__ret := C.pdf_xobject_transparency(cctx, cxobj)
	packSXobject(xobj, cxobj)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// XobjectColorspace function as declared in pdf/resource.h:102
func XobjectColorspace(ctx []Context, xobj []Xobject) *Colorspace {
	cctx, _ := unpackArgSContext(ctx)
	cxobj, _ := unpackArgSXobject(xobj)
	__ret := C.pdf_xobject_colorspace(cctx, cxobj)
	packSXobject(xobj, cxobj)
	packSContext(ctx, cctx)
	__v := *(**Colorspace)(unsafe.Pointer(&__ret))
	return __v
}

// NewCmap function as declared in pdf/cmap.h:67
func NewCmap(ctx []Context) *Cmap {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.pdf_new_cmap(cctx)
	packSContext(ctx, cctx)
	__v := NewCmapRef(unsafe.Pointer(__ret))
	return __v
}

// KeepCmap function as declared in pdf/cmap.h:68
func KeepCmap(ctx []Context, cmap []Cmap) *Cmap {
	cctx, _ := unpackArgSContext(ctx)
	ccmap, _ := unpackArgSCmap(cmap)
	__ret := C.pdf_keep_cmap(cctx, ccmap)
	packSCmap(cmap, ccmap)
	packSContext(ctx, cctx)
	__v := NewCmapRef(unsafe.Pointer(__ret))
	return __v
}

// DropCmap function as declared in pdf/cmap.h:69
func DropCmap(ctx []Context, cmap []Cmap) {
	cctx, _ := unpackArgSContext(ctx)
	ccmap, _ := unpackArgSCmap(cmap)
	C.pdf_drop_cmap(cctx, ccmap)
	packSCmap(cmap, ccmap)
	packSContext(ctx, cctx)
}

// DropCmapImp function as declared in pdf/cmap.h:70
func DropCmapImp(ctx []Context, cmap []Storable) {
	cctx, _ := unpackArgSContext(ctx)
	ccmap, _ := unpackArgSStorable(cmap)
	C.pdf_drop_cmap_imp(cctx, ccmap)
	packSStorable(cmap, ccmap)
	packSContext(ctx, cctx)
}

// CmapSize function as declared in pdf/cmap.h:71
func CmapSize(ctx []Context, cmap []Cmap) uint {
	cctx, _ := unpackArgSContext(ctx)
	ccmap, _ := unpackArgSCmap(cmap)
	__ret := C.pdf_cmap_size(cctx, ccmap)
	packSCmap(cmap, ccmap)
	packSContext(ctx, cctx)
	__v := (uint)(__ret)
	return __v
}

// CmapWmode function as declared in pdf/cmap.h:73
func CmapWmode(ctx []Context, cmap []Cmap) int32 {
	cctx, _ := unpackArgSContext(ctx)
	ccmap, _ := unpackArgSCmap(cmap)
	__ret := C.pdf_cmap_wmode(cctx, ccmap)
	packSCmap(cmap, ccmap)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// SetCmapWmode function as declared in pdf/cmap.h:74
func SetCmapWmode(ctx []Context, cmap []Cmap, wmode int32) {
	cctx, _ := unpackArgSContext(ctx)
	ccmap, _ := unpackArgSCmap(cmap)
	cwmode, _ := (C.int)(wmode), cgoAllocsUnknown
	C.pdf_set_cmap_wmode(cctx, ccmap, cwmode)
	packSCmap(cmap, ccmap)
	packSContext(ctx, cctx)
}

// SetUsecmap function as declared in pdf/cmap.h:75
func SetUsecmap(ctx []Context, cmap []Cmap, usecmap []Cmap) {
	cctx, _ := unpackArgSContext(ctx)
	ccmap, _ := unpackArgSCmap(cmap)
	cusecmap, _ := unpackArgSCmap(usecmap)
	C.pdf_set_usecmap(cctx, ccmap, cusecmap)
	packSCmap(usecmap, cusecmap)
	packSCmap(cmap, ccmap)
	packSContext(ctx, cctx)
}

// AddCodespace function as declared in pdf/cmap.h:77
func AddCodespace(ctx []Context, cmap []Cmap, low uint32, high uint32, n int32) {
	cctx, _ := unpackArgSContext(ctx)
	ccmap, _ := unpackArgSCmap(cmap)
	clow, _ := (C.uint)(low), cgoAllocsUnknown
	chigh, _ := (C.uint)(high), cgoAllocsUnknown
	cn, _ := (C.int)(n), cgoAllocsUnknown
	C.pdf_add_codespace(cctx, ccmap, clow, chigh, cn)
	packSCmap(cmap, ccmap)
	packSContext(ctx, cctx)
}

// MapRangeToRange function as declared in pdf/cmap.h:78
func MapRangeToRange(ctx []Context, cmap []Cmap, srclo uint32, srchi uint32, dstlo int32) {
	cctx, _ := unpackArgSContext(ctx)
	ccmap, _ := unpackArgSCmap(cmap)
	csrclo, _ := (C.uint)(srclo), cgoAllocsUnknown
	csrchi, _ := (C.uint)(srchi), cgoAllocsUnknown
	cdstlo, _ := (C.int)(dstlo), cgoAllocsUnknown
	C.pdf_map_range_to_range(cctx, ccmap, csrclo, csrchi, cdstlo)
	packSCmap(cmap, ccmap)
	packSContext(ctx, cctx)
}

// MapOneToMany function as declared in pdf/cmap.h:79
func MapOneToMany(ctx []Context, cmap []Cmap, one uint32, many []int32, len int32) {
	cctx, _ := unpackArgSContext(ctx)
	ccmap, _ := unpackArgSCmap(cmap)
	cone, _ := (C.uint)(one), cgoAllocsUnknown
	cmany, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&many)).Data)), cgoAllocsUnknown
	clen, _ := (C.int)(len), cgoAllocsUnknown
	C.pdf_map_one_to_many(cctx, ccmap, cone, cmany, clen)
	packSCmap(cmap, ccmap)
	packSContext(ctx, cctx)
}

// SortCmap function as declared in pdf/cmap.h:80
func SortCmap(ctx []Context, cmap []Cmap) {
	cctx, _ := unpackArgSContext(ctx)
	ccmap, _ := unpackArgSCmap(cmap)
	C.pdf_sort_cmap(cctx, ccmap)
	packSCmap(cmap, ccmap)
	packSContext(ctx, cctx)
}

// LookupCmap function as declared in pdf/cmap.h:82
func LookupCmap(cmap []Cmap, cpt uint32) int32 {
	ccmap, _ := unpackArgSCmap(cmap)
	ccpt, _ := (C.uint)(cpt), cgoAllocsUnknown
	__ret := C.pdf_lookup_cmap(ccmap, ccpt)
	packSCmap(cmap, ccmap)
	__v := (int32)(__ret)
	return __v
}

// LookupCmapFull function as declared in pdf/cmap.h:83
func LookupCmapFull(cmap []Cmap, cpt uint32, out []int32) int32 {
	ccmap, _ := unpackArgSCmap(cmap)
	ccpt, _ := (C.uint)(cpt), cgoAllocsUnknown
	cout, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&out)).Data)), cgoAllocsUnknown
	__ret := C.pdf_lookup_cmap_full(ccmap, ccpt, cout)
	packSCmap(cmap, ccmap)
	__v := (int32)(__ret)
	return __v
}

// DecodeCmap function as declared in pdf/cmap.h:84
func DecodeCmap(cmap []Cmap, s []byte, e []byte, cpt []uint32) int32 {
	ccmap, _ := unpackArgSCmap(cmap)
	cs, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&s)).Data)), cgoAllocsUnknown
	ce, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&e)).Data)), cgoAllocsUnknown
	ccpt, _ := (*C.uint)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cpt)).Data)), cgoAllocsUnknown
	__ret := C.pdf_decode_cmap(ccmap, cs, ce, ccpt)
	packSCmap(cmap, ccmap)
	__v := (int32)(__ret)
	return __v
}

// NewIdentityCmap function as declared in pdf/cmap.h:86
func NewIdentityCmap(ctx []Context, wmode int32, bytes int32) *Cmap {
	cctx, _ := unpackArgSContext(ctx)
	cwmode, _ := (C.int)(wmode), cgoAllocsUnknown
	cbytes, _ := (C.int)(bytes), cgoAllocsUnknown
	__ret := C.pdf_new_identity_cmap(cctx, cwmode, cbytes)
	packSContext(ctx, cctx)
	__v := NewCmapRef(unsafe.Pointer(__ret))
	return __v
}

// LoadCmap function as declared in pdf/cmap.h:87
func LoadCmap(ctx []Context, file []Stream) *Cmap {
	cctx, _ := unpackArgSContext(ctx)
	cfile, _ := unpackArgSStream(file)
	__ret := C.pdf_load_cmap(cctx, cfile)
	packSStream(file, cfile)
	packSContext(ctx, cctx)
	__v := NewCmapRef(unsafe.Pointer(__ret))
	return __v
}

// LoadSystemCmap function as declared in pdf/cmap.h:88
func LoadSystemCmap(ctx []Context, name string) *Cmap {
	cctx, _ := unpackArgSContext(ctx)
	cname, _ := unpackPCharString(name)
	__ret := C.pdf_load_system_cmap(cctx, cname)
	packSContext(ctx, cctx)
	__v := NewCmapRef(unsafe.Pointer(__ret))
	return __v
}

// LoadBuiltinCmap function as declared in pdf/cmap.h:89
func LoadBuiltinCmap(ctx []Context, name string) *Cmap {
	cctx, _ := unpackArgSContext(ctx)
	cname, _ := unpackPCharString(name)
	__ret := C.pdf_load_builtin_cmap(cctx, cname)
	packSContext(ctx, cctx)
	__v := NewCmapRef(unsafe.Pointer(__ret))
	return __v
}

// LoadEmbeddedCmap function as declared in pdf/cmap.h:90
func LoadEmbeddedCmap(ctx []Context, doc []Document, ref []Obj) *Cmap {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cref, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ref)).Data)), cgoAllocsUnknown
	__ret := C.pdf_load_embedded_cmap(cctx, cdoc, cref)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewCmapRef(unsafe.Pointer(__ret))
	return __v
}

// LoadEncoding function as declared in pdf/font.h:21
func LoadEncoding(estrings []string, encoding string) {
	cestrings, _ := unpackArgSString(estrings)
	cencoding, _ := unpackPCharString(encoding)
	C.pdf_load_encoding(cestrings, cencoding)
	packSString(estrings, cestrings)
}

// LookupAgl function as declared in pdf/font.h:22
func LookupAgl(name string) int32 {
	cname, _ := unpackPCharString(name)
	__ret := C.pdf_lookup_agl(cname)
	__v := (int32)(__ret)
	return __v
}

// LookupAglDuplicates function as declared in pdf/font.h:23
func LookupAglDuplicates(ucs int32) *string {
	cucs, _ := (C.int)(ucs), cgoAllocsUnknown
	__ret := C.pdf_lookup_agl_duplicates(cucs)
	__v := packPCharString(__ret)
	return __v
}

// SetFontWmode function as declared in pdf/font.h:92
func SetFontWmode(ctx []Context, font []FontDesc, wmode int32) {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := unpackArgSFontDesc(font)
	cwmode, _ := (C.int)(wmode), cgoAllocsUnknown
	C.pdf_set_font_wmode(cctx, cfont, cwmode)
	packSFontDesc(font, cfont)
	packSContext(ctx, cctx)
}

// SetDefaultHmtx function as declared in pdf/font.h:93
func SetDefaultHmtx(ctx []Context, font []FontDesc, w int32) {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := unpackArgSFontDesc(font)
	cw, _ := (C.int)(w), cgoAllocsUnknown
	C.pdf_set_default_hmtx(cctx, cfont, cw)
	packSFontDesc(font, cfont)
	packSContext(ctx, cctx)
}

// SetDefaultVmtx function as declared in pdf/font.h:94
func SetDefaultVmtx(ctx []Context, font []FontDesc, y int32, w int32) {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := unpackArgSFontDesc(font)
	cy, _ := (C.int)(y), cgoAllocsUnknown
	cw, _ := (C.int)(w), cgoAllocsUnknown
	C.pdf_set_default_vmtx(cctx, cfont, cy, cw)
	packSFontDesc(font, cfont)
	packSContext(ctx, cctx)
}

// AddHmtx function as declared in pdf/font.h:95
func AddHmtx(ctx []Context, font []FontDesc, lo int32, hi int32, w int32) {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := unpackArgSFontDesc(font)
	clo, _ := (C.int)(lo), cgoAllocsUnknown
	chi, _ := (C.int)(hi), cgoAllocsUnknown
	cw, _ := (C.int)(w), cgoAllocsUnknown
	C.pdf_add_hmtx(cctx, cfont, clo, chi, cw)
	packSFontDesc(font, cfont)
	packSContext(ctx, cctx)
}

// AddVmtx function as declared in pdf/font.h:96
func AddVmtx(ctx []Context, font []FontDesc, lo int32, hi int32, x int32, y int32, w int32) {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := unpackArgSFontDesc(font)
	clo, _ := (C.int)(lo), cgoAllocsUnknown
	chi, _ := (C.int)(hi), cgoAllocsUnknown
	cx, _ := (C.int)(x), cgoAllocsUnknown
	cy, _ := (C.int)(y), cgoAllocsUnknown
	cw, _ := (C.int)(w), cgoAllocsUnknown
	C.pdf_add_vmtx(cctx, cfont, clo, chi, cx, cy, cw)
	packSFontDesc(font, cfont)
	packSContext(ctx, cctx)
}

// EndHmtx function as declared in pdf/font.h:97
func EndHmtx(ctx []Context, font []FontDesc) {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := unpackArgSFontDesc(font)
	C.pdf_end_hmtx(cctx, cfont)
	packSFontDesc(font, cfont)
	packSContext(ctx, cctx)
}

// EndVmtx function as declared in pdf/font.h:98
func EndVmtx(ctx []Context, font []FontDesc) {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := unpackArgSFontDesc(font)
	C.pdf_end_vmtx(cctx, cfont)
	packSFontDesc(font, cfont)
	packSContext(ctx, cctx)
}

// LookupHmtx function as declared in pdf/font.h:99
func LookupHmtx(ctx []Context, font []FontDesc, cid int32) Hmtx {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := unpackArgSFontDesc(font)
	ccid, _ := (C.int)(cid), cgoAllocsUnknown
	__ret := C.pdf_lookup_hmtx(cctx, cfont, ccid)
	packSFontDesc(font, cfont)
	packSContext(ctx, cctx)
	__v := *NewHmtxRef(unsafe.Pointer(&__ret))
	return __v
}

// LookupVmtx function as declared in pdf/font.h:100
func LookupVmtx(ctx []Context, font []FontDesc, cid int32) Vmtx {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := unpackArgSFontDesc(font)
	ccid, _ := (C.int)(cid), cgoAllocsUnknown
	__ret := C.pdf_lookup_vmtx(cctx, cfont, ccid)
	packSFontDesc(font, cfont)
	packSContext(ctx, cctx)
	__v := *NewVmtxRef(unsafe.Pointer(&__ret))
	return __v
}

// LoadToUnicode function as declared in pdf/font.h:102
func LoadToUnicode(ctx []Context, doc []Document, font []FontDesc, strings []string, collection []byte, cmapstm []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cfont, _ := unpackArgSFontDesc(font)
	cstrings, _ := unpackArgSString(strings)
	ccollection, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&collection)).Data)), cgoAllocsUnknown
	ccmapstm, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&cmapstm)).Data)), cgoAllocsUnknown
	C.pdf_load_to_unicode(cctx, cdoc, cfont, cstrings, ccollection, ccmapstm)
	packSString(strings, cstrings)
	packSFontDesc(font, cfont)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// FontCidToGid function as declared in pdf/font.h:104
func FontCidToGid(ctx []Context, fontdesc []FontDesc, cid int32) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cfontdesc, _ := unpackArgSFontDesc(fontdesc)
	ccid, _ := (C.int)(cid), cgoAllocsUnknown
	__ret := C.pdf_font_cid_to_gid(cctx, cfontdesc, ccid)
	packSFontDesc(fontdesc, cfontdesc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// LookupSubstituteFont function as declared in pdf/font.h:106
func LookupSubstituteFont(ctx []Context, mono int32, serif int32, bold int32, italic int32, len []int32) string {
	cctx, _ := unpackArgSContext(ctx)
	cmono, _ := (C.int)(mono), cgoAllocsUnknown
	cserif, _ := (C.int)(serif), cgoAllocsUnknown
	cbold, _ := (C.int)(bold), cgoAllocsUnknown
	citalic, _ := (C.int)(italic), cgoAllocsUnknown
	clen, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&len)).Data)), cgoAllocsUnknown
	__ret := C.pdf_lookup_substitute_font(cctx, cmono, cserif, cbold, citalic, clen)
	packSContext(ctx, cctx)
	__v := packPUcharString(__ret)
	return __v
}

// LoadType3Font function as declared in pdf/font.h:108
func LoadType3Font(ctx []Context, doc []Document, rdb []Obj, obj []Obj) *FontDesc {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	crdb, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&rdb)).Data)), cgoAllocsUnknown
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_load_type3_font(cctx, cdoc, crdb, cobj)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewFontDescRef(unsafe.Pointer(__ret))
	return __v
}

// LoadType3Glyphs function as declared in pdf/font.h:109
func LoadType3Glyphs(ctx []Context, doc []Document, fontdesc []FontDesc, nesteddepth int32) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cfontdesc, _ := unpackArgSFontDesc(fontdesc)
	cnesteddepth, _ := (C.int)(nesteddepth), cgoAllocsUnknown
	C.pdf_load_type3_glyphs(cctx, cdoc, cfontdesc, cnesteddepth)
	packSFontDesc(fontdesc, cfontdesc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// LoadFont function as declared in pdf/font.h:110
func LoadFont(ctx []Context, doc []Document, rdb []Obj, obj []Obj, nesteddepth int32) *FontDesc {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	crdb, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&rdb)).Data)), cgoAllocsUnknown
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	cnesteddepth, _ := (C.int)(nesteddepth), cgoAllocsUnknown
	__ret := C.pdf_load_font(cctx, cdoc, crdb, cobj, cnesteddepth)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewFontDescRef(unsafe.Pointer(__ret))
	return __v
}

// LoadHailMaryFont function as declared in pdf/font.h:111
func LoadHailMaryFont(ctx []Context, doc []Document) *FontDesc {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.pdf_load_hail_mary_font(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewFontDescRef(unsafe.Pointer(__ret))
	return __v
}

// NewFontDesc function as declared in pdf/font.h:113
func NewFontDesc(ctx []Context) *FontDesc {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.pdf_new_font_desc(cctx)
	packSContext(ctx, cctx)
	__v := NewFontDescRef(unsafe.Pointer(__ret))
	return __v
}

// KeepFont function as declared in pdf/font.h:114
func KeepFont(ctx []Context, fontdesc []FontDesc) *FontDesc {
	cctx, _ := unpackArgSContext(ctx)
	cfontdesc, _ := unpackArgSFontDesc(fontdesc)
	__ret := C.pdf_keep_font(cctx, cfontdesc)
	packSFontDesc(fontdesc, cfontdesc)
	packSContext(ctx, cctx)
	__v := NewFontDescRef(unsafe.Pointer(__ret))
	return __v
}

// DropFont function as declared in pdf/font.h:115
func DropFont(ctx []Context, font []FontDesc) {
	cctx, _ := unpackArgSContext(ctx)
	cfont, _ := unpackArgSFontDesc(font)
	C.pdf_drop_font(cctx, cfont)
	packSFontDesc(font, cfont)
	packSContext(ctx, cctx)
}

// PrintFont function as declared in pdf/font.h:117
func PrintFont(ctx []Context, out []Output, fontdesc []FontDesc) {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cfontdesc, _ := unpackArgSFontDesc(fontdesc)
	C.pdf_print_font(cctx, cout, cfontdesc)
	packSFontDesc(fontdesc, cfontdesc)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
}

// MeasureText function as declared in pdf/font.h:119
func MeasureText(ctx []Context, fontdesc []FontDesc, buf []byte, len uint, rect []Rect) *Rect {
	cctx, _ := unpackArgSContext(ctx)
	cfontdesc, _ := unpackArgSFontDesc(fontdesc)
	cbuf, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	clen, _ := (C.size_t)(len), cgoAllocsUnknown
	crect, _ := unpackArgSRect(rect)
	__ret := C.pdf_measure_text(cctx, cfontdesc, cbuf, clen, crect)
	packSRect(rect, crect)
	packSFontDesc(fontdesc, cfontdesc)
	packSContext(ctx, cctx)
	__v := NewRectRef(unsafe.Pointer(__ret))
	return __v
}

// TextStride function as declared in pdf/font.h:120
func TextStride(ctx []Context, fontdesc []FontDesc, fontsize float32, buf []byte, len uint, room float32, count []uint) float32 {
	cctx, _ := unpackArgSContext(ctx)
	cfontdesc, _ := unpackArgSFontDesc(fontdesc)
	cfontsize, _ := (C.float)(fontsize), cgoAllocsUnknown
	cbuf, _ := (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	clen, _ := (C.size_t)(len), cgoAllocsUnknown
	croom, _ := (C.float)(room), cgoAllocsUnknown
	ccount, _ := (*C.size_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&count)).Data)), cgoAllocsUnknown
	__ret := C.pdf_text_stride(cctx, cfontdesc, cfontsize, cbuf, clen, croom, ccount)
	packSFontDesc(fontdesc, cfontdesc)
	packSContext(ctx, cctx)
	__v := (float32)(__ret)
	return __v
}

// RunGlyph function as declared in pdf/font.h:122
func RunGlyph(ctx []Context, doc []Document, resources []Obj, contents []Buffer, dev []Device, ctm []Matrix, gstate unsafe.Pointer, nesteddepth int32) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cresources, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&resources)).Data)), cgoAllocsUnknown
	ccontents, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&contents)).Data)), cgoAllocsUnknown
	cdev, _ := unpackArgSDevice(dev)
	cctm, _ := unpackArgSMatrix(ctm)
	cgstate, _ := gstate, cgoAllocsUnknown
	cnesteddepth, _ := (C.int)(nesteddepth), cgoAllocsUnknown
	C.pdf_run_glyph(cctx, cdoc, cresources, ccontents, cdev, cctm, cgstate, cnesteddepth)
	packSMatrix(ctm, cctm)
	packSDevice(dev, cdev)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// AddSimpleFont function as declared in pdf/font.h:124
func AddSimpleFont(ctx []Context, doc []Document, font []Font) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	__ret := C.pdf_add_simple_font(cctx, cdoc, cfont)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// AddCidFont function as declared in pdf/font.h:125
func AddCidFont(ctx []Context, doc []Document, font []Font) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	__ret := C.pdf_add_cid_font(cctx, cdoc, cfont)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// FontWritingSupported function as declared in pdf/font.h:127
func FontWritingSupported(font []Font) int32 {
	cfont, _ := (*C.fz_font)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&font)).Data)), cgoAllocsUnknown
	__ret := C.pdf_font_writing_supported(cfont)
	__v := (int32)(__ret)
	return __v
}

// NewProcessor function as declared in pdf/interpret.h:8
func NewProcessor(ctx []Context, size int32) unsafe.Pointer {
	cctx, _ := unpackArgSContext(ctx)
	csize, _ := (C.int)(size), cgoAllocsUnknown
	__ret := C.pdf_new_processor(cctx, csize)
	packSContext(ctx, cctx)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// CloseProcessor function as declared in pdf/interpret.h:9
func CloseProcessor(ctx []Context, proc []Processor) {
	cctx, _ := unpackArgSContext(ctx)
	cproc, _ := unpackArgSProcessor(proc)
	C.pdf_close_processor(cctx, cproc)
	packSProcessor(proc, cproc)
	packSContext(ctx, cctx)
}

// DropProcessor function as declared in pdf/interpret.h:10
func DropProcessor(ctx []Context, proc []Processor) {
	cctx, _ := unpackArgSContext(ctx)
	cproc, _ := unpackArgSProcessor(proc)
	C.pdf_drop_processor(cctx, cproc)
	packSProcessor(proc, cproc)
	packSContext(ctx, cctx)
}

// NewRunProcessor function as declared in pdf/interpret.h:184
func NewRunProcessor(ctx []Context, dev []Device, ctm []Matrix, usage string, gstate []Gstate, nested int32) *Processor {
	cctx, _ := unpackArgSContext(ctx)
	cdev, _ := unpackArgSDevice(dev)
	cctm, _ := unpackArgSMatrix(ctm)
	cusage, _ := unpackPCharString(usage)
	cgstate, _ := (*C.pdf_gstate)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&gstate)).Data)), cgoAllocsUnknown
	cnested, _ := (C.int)(nested), cgoAllocsUnknown
	__ret := C.pdf_new_run_processor(cctx, cdev, cctm, cusage, cgstate, cnested)
	packSMatrix(ctm, cctm)
	packSDevice(dev, cdev)
	packSContext(ctx, cctx)
	__v := NewProcessorRef(unsafe.Pointer(__ret))
	return __v
}

// NewBufferProcessor function as declared in pdf/interpret.h:196
func NewBufferProcessor(ctx []Context, buffer []Buffer, ahxencode int32) *Processor {
	cctx, _ := unpackArgSContext(ctx)
	cbuffer, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buffer)).Data)), cgoAllocsUnknown
	cahxencode, _ := (C.int)(ahxencode), cgoAllocsUnknown
	__ret := C.pdf_new_buffer_processor(cctx, cbuffer, cahxencode)
	packSContext(ctx, cctx)
	__v := NewProcessorRef(unsafe.Pointer(__ret))
	return __v
}

// NewOutputProcessor function as declared in pdf/interpret.h:207
func NewOutputProcessor(ctx []Context, out []Output, ahxencode int32) *Processor {
	cctx, _ := unpackArgSContext(ctx)
	cout, _ := unpackArgSOutput(out)
	cahxencode, _ := (C.int)(ahxencode), cgoAllocsUnknown
	__ret := C.pdf_new_output_processor(cctx, cout, cahxencode)
	packSOutput(out, cout)
	packSContext(ctx, cctx)
	__v := NewProcessorRef(unsafe.Pointer(__ret))
	return __v
}

// NewFilterProcessor function as declared in pdf/interpret.h:244
func NewFilterProcessor(ctx []Context, chain []Processor, oldRes []Obj, newRes []Obj) *Processor {
	cctx, _ := unpackArgSContext(ctx)
	cchain, _ := unpackArgSProcessor(chain)
	coldRes, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&oldRes)).Data)), cgoAllocsUnknown
	cnewRes, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&newRes)).Data)), cgoAllocsUnknown
	__ret := C.pdf_new_filter_processor(cctx, cchain, coldRes, cnewRes)
	packSProcessor(chain, cchain)
	packSContext(ctx, cctx)
	__v := NewProcessorRef(unsafe.Pointer(__ret))
	return __v
}

// ProcessContents function as declared in pdf/interpret.h:247
func ProcessContents(ctx []Context, proc []Processor, doc []Document, obj []Obj, res []Obj, cookie []Cookie) {
	cctx, _ := unpackArgSContext(ctx)
	cproc, _ := unpackArgSProcessor(proc)
	cdoc, _ := unpackArgSDocument(doc)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	cres, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&res)).Data)), cgoAllocsUnknown
	ccookie, _ := unpackArgSCookie(cookie)
	C.pdf_process_contents(cctx, cproc, cdoc, cobj, cres, ccookie)
	packSCookie(cookie, ccookie)
	packSDocument(doc, cdoc)
	packSProcessor(proc, cproc)
	packSContext(ctx, cctx)
}

// ProcessAnnot function as declared in pdf/interpret.h:248
func ProcessAnnot(ctx []Context, proc []Processor, doc []Document, page []Page, annot []Annot, cookie []Cookie) {
	cctx, _ := unpackArgSContext(ctx)
	cproc, _ := unpackArgSProcessor(proc)
	cdoc, _ := unpackArgSDocument(doc)
	cpage, _ := unpackArgSPage(page)
	cannot, _ := unpackArgSAnnot(annot)
	ccookie, _ := unpackArgSCookie(cookie)
	C.pdf_process_annot(cctx, cproc, cdoc, cpage, cannot, ccookie)
	packSCookie(cookie, ccookie)
	packSAnnot(annot, cannot)
	packSPage(page, cpage)
	packSDocument(doc, cdoc)
	packSProcessor(proc, cproc)
	packSContext(ctx, cctx)
}

// ProcessGlyph function as declared in pdf/interpret.h:249
func ProcessGlyph(ctx []Context, proc []Processor, doc []Document, resources []Obj, contents []Buffer) {
	cctx, _ := unpackArgSContext(ctx)
	cproc, _ := unpackArgSProcessor(proc)
	cdoc, _ := unpackArgSDocument(doc)
	cresources, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&resources)).Data)), cgoAllocsUnknown
	ccontents, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&contents)).Data)), cgoAllocsUnknown
	C.pdf_process_glyph(cctx, cproc, cdoc, cresources, ccontents)
	packSDocument(doc, cdoc)
	packSProcessor(proc, cproc)
	packSContext(ctx, cctx)
}

// StringFromAnnotType function as declared in pdf/annot.h:34
func StringFromAnnotType(ctx []Context, kind AnnotType) string {
	cctx, _ := unpackArgSContext(ctx)
	ckind, _ := (C.fz_annot_type)(kind), cgoAllocsUnknown
	__ret := C.pdf_string_from_annot_type(cctx, ckind)
	packSContext(ctx, cctx)
	__v := packPCharString(__ret)
	return __v
}

// AnnotTypeFromString function as declared in pdf/annot.h:35
func AnnotTypeFromString(ctx []Context, subtype string) int32 {
	cctx, _ := unpackArgSContext(ctx)
	csubtype, _ := unpackPCharString(subtype)
	__ret := C.pdf_annot_type_from_string(cctx, csubtype)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// FirstAnnot function as declared in pdf/annot.h:68
func FirstAnnot(ctx []Context, page []Page) *Annot {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	__ret := C.pdf_first_annot(cctx, cpage)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
	__v := NewAnnotRef(unsafe.Pointer(__ret))
	return __v
}

// NextAnnot function as declared in pdf/annot.h:73
func NextAnnot(ctx []Context, annot []Annot) *Annot {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	__ret := C.pdf_next_annot(cctx, cannot)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
	__v := NewAnnotRef(unsafe.Pointer(__ret))
	return __v
}

// BoundAnnot function as declared in pdf/annot.h:78
func BoundAnnot(ctx []Context, annot []Annot, rect []Rect) *Rect {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	crect, _ := unpackArgSRect(rect)
	__ret := C.pdf_bound_annot(cctx, cannot, crect)
	packSRect(rect, crect)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
	__v := NewRectRef(unsafe.Pointer(__ret))
	return __v
}

// AnnotType function as declared in pdf/annot.h:83
func AnnotType(ctx []Context, annot []Annot) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	__ret := C.pdf_annot_type(cctx, cannot)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// RunAnnot function as declared in pdf/annot.h:97
func RunAnnot(ctx []Context, annot []Annot, dev []Device, ctm []Matrix, cookie []Cookie) {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	cdev, _ := unpackArgSDevice(dev)
	cctm, _ := unpackArgSMatrix(ctm)
	ccookie, _ := unpackArgSCookie(cookie)
	C.pdf_run_annot(cctx, cannot, cdev, cctm, ccookie)
	packSCookie(cookie, ccookie)
	packSMatrix(ctm, cctm)
	packSDevice(dev, cdev)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
}

// ParseFileSpec function as declared in pdf/annot.h:113
func ParseFileSpec(ctx []Context, doc []Document, fileSpec []Obj, dest []Obj) *byte {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cfileSpec, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&fileSpec)).Data)), cgoAllocsUnknown
	cdest, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dest)).Data)), cgoAllocsUnknown
	__ret := C.pdf_parse_file_spec(cctx, cdoc, cfileSpec, cdest)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// ParseLinkDest function as declared in pdf/annot.h:114
func ParseLinkDest(ctx []Context, doc []Document, obj []Obj) *byte {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_parse_link_dest(cctx, cdoc, cobj)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// ParseLinkAction function as declared in pdf/annot.h:115
func ParseLinkAction(ctx []Context, doc []Document, obj []Obj, pagenum int32) *byte {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	cpagenum, _ := (C.int)(pagenum), cgoAllocsUnknown
	__ret := C.pdf_parse_link_action(cctx, cdoc, cobj, cpagenum)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// LookupDest function as declared in pdf/annot.h:116
func LookupDest(ctx []Context, doc []Document, needle []Obj) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cneedle, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&needle)).Data)), cgoAllocsUnknown
	__ret := C.pdf_lookup_dest(cctx, cdoc, cneedle)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// LookupName function as declared in pdf/annot.h:117
func LookupName(ctx []Context, doc []Document, which []Obj, needle []Obj) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cwhich, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&which)).Data)), cgoAllocsUnknown
	cneedle, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&needle)).Data)), cgoAllocsUnknown
	__ret := C.pdf_lookup_name(cctx, cdoc, cwhich, cneedle)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// LoadNameTree function as declared in pdf/annot.h:118
func LoadNameTree(ctx []Context, doc []Document, which []Obj) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cwhich, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&which)).Data)), cgoAllocsUnknown
	__ret := C.pdf_load_name_tree(cctx, cdoc, cwhich)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// ResolveLink function as declared in pdf/annot.h:120
func ResolveLink(ctx []Context, doc []Document, uri string, xp []float32, yp []float32) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	curi, _ := unpackPCharString(uri)
	cxp, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&xp)).Data)), cgoAllocsUnknown
	cyp, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&yp)).Data)), cgoAllocsUnknown
	__ret := C.pdf_resolve_link(cctx, cdoc, curi, cxp, cyp)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// LoadLinkAnnots function as declared in pdf/annot.h:121
func LoadLinkAnnots(ctx []Context, arg1 []Document, annots []Obj, pagenum int32, pageCtm []Matrix) *Link {
	cctx, _ := unpackArgSContext(ctx)
	carg1, _ := unpackArgSDocument(arg1)
	cannots, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&annots)).Data)), cgoAllocsUnknown
	cpagenum, _ := (C.int)(pagenum), cgoAllocsUnknown
	cpageCtm, _ := unpackArgSMatrix(pageCtm)
	__ret := C.pdf_load_link_annots(cctx, carg1, cannots, cpagenum, cpageCtm)
	packSMatrix(pageCtm, cpageCtm)
	packSDocument(arg1, carg1)
	packSContext(ctx, cctx)
	__v := NewLinkRef(unsafe.Pointer(__ret))
	return __v
}

// AnnotTransform function as declared in pdf/annot.h:123
func AnnotTransform(ctx []Context, annot []Annot, annotCtm []Matrix) {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	cannotCtm, _ := unpackArgSMatrix(annotCtm)
	C.pdf_annot_transform(cctx, cannot, cannotCtm)
	packSMatrix(annotCtm, cannotCtm)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
}

// LoadAnnots function as declared in pdf/annot.h:124
func LoadAnnots(ctx []Context, page []Page, annots []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	cannots, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&annots)).Data)), cgoAllocsUnknown
	C.pdf_load_annots(cctx, cpage, cannots)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
}

// UpdateAnnot function as declared in pdf/annot.h:125
func UpdateAnnot(ctx []Context, annot []Annot) {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	C.pdf_update_annot(cctx, cannot)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
}

// DropAnnots function as declared in pdf/annot.h:126
func DropAnnots(ctx []Context, annotList []Annot) {
	cctx, _ := unpackArgSContext(ctx)
	cannotList, _ := unpackArgSAnnot(annotList)
	C.pdf_drop_annots(cctx, cannotList)
	packSAnnot(annotList, cannotList)
	packSContext(ctx, cctx)
}

// CreateAnnot function as declared in pdf/annot.h:133
func CreateAnnot(ctx []Context, page []Page, kind AnnotType) *Annot {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	ckind, _ := (C.fz_annot_type)(kind), cgoAllocsUnknown
	__ret := C.pdf_create_annot(cctx, cpage, ckind)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
	__v := NewAnnotRef(unsafe.Pointer(__ret))
	return __v
}

// DeleteAnnot function as declared in pdf/annot.h:138
func DeleteAnnot(ctx []Context, page []Page, annot []Annot) {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	cannot, _ := unpackArgSAnnot(annot)
	C.pdf_delete_annot(cctx, cpage, cannot)
	packSAnnot(annot, cannot)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
}

// AnnotHasInkList function as declared in pdf/annot.h:140
func AnnotHasInkList(ctx []Context, annot []Annot) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	__ret := C.pdf_annot_has_ink_list(cctx, cannot)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// AnnotHasQuadPoints function as declared in pdf/annot.h:141
func AnnotHasQuadPoints(ctx []Context, annot []Annot) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	__ret := C.pdf_annot_has_quad_points(cctx, cannot)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// AnnotHasVertices function as declared in pdf/annot.h:142
func AnnotHasVertices(ctx []Context, annot []Annot) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	__ret := C.pdf_annot_has_vertices(cctx, cannot)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// AnnotHasInteriorColor function as declared in pdf/annot.h:143
func AnnotHasInteriorColor(ctx []Context, annot []Annot) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	__ret := C.pdf_annot_has_interior_color(cctx, cannot)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// AnnotHasLineEndingStyles function as declared in pdf/annot.h:144
func AnnotHasLineEndingStyles(ctx []Context, annot []Annot) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	__ret := C.pdf_annot_has_line_ending_styles(cctx, cannot)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// AnnotHasIconName function as declared in pdf/annot.h:145
func AnnotHasIconName(ctx []Context, annot []Annot) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	__ret := C.pdf_annot_has_icon_name(cctx, cannot)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// AnnotHasOpen function as declared in pdf/annot.h:146
func AnnotHasOpen(ctx []Context, annot []Annot) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	__ret := C.pdf_annot_has_open(cctx, cannot)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// AnnotFlags function as declared in pdf/annot.h:148
func AnnotFlags(ctx []Context, annot []Annot) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	__ret := C.pdf_annot_flags(cctx, cannot)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// AnnotRect function as declared in pdf/annot.h:149
func AnnotRect(ctx []Context, annot []Annot, rect []Rect) {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	crect, _ := unpackArgSRect(rect)
	C.pdf_annot_rect(cctx, cannot, crect)
	packSRect(rect, crect)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
}

// AnnotBorder function as declared in pdf/annot.h:150
func AnnotBorder(ctx []Context, annot []Annot) float32 {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	__ret := C.pdf_annot_border(cctx, cannot)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
	__v := (float32)(__ret)
	return __v
}

// AnnotColor function as declared in pdf/annot.h:151
func AnnotColor(ctx []Context, annot []Annot, n []int32, color *[4]float32) {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	cn, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&n)).Data)), cgoAllocsUnknown
	ccolor, _ := *(**C.float)(unsafe.Pointer(&color)), cgoAllocsUnknown
	C.pdf_annot_color(cctx, cannot, cn, ccolor)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
}

// AnnotInteriorColor function as declared in pdf/annot.h:152
func AnnotInteriorColor(ctx []Context, annot []Annot, n []int32, color *[4]float32) {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	cn, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&n)).Data)), cgoAllocsUnknown
	ccolor, _ := *(**C.float)(unsafe.Pointer(&color)), cgoAllocsUnknown
	C.pdf_annot_interior_color(cctx, cannot, cn, ccolor)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
}

// AnnotQuadPointCount function as declared in pdf/annot.h:154
func AnnotQuadPointCount(ctx []Context, annot []Annot) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	__ret := C.pdf_annot_quad_point_count(cctx, cannot)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// AnnotQuadPoint function as declared in pdf/annot.h:155
func AnnotQuadPoint(ctx []Context, annot []Annot, i int32, qp *[8]float32) {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	ci, _ := (C.int)(i), cgoAllocsUnknown
	cqp, _ := *(**C.float)(unsafe.Pointer(&qp)), cgoAllocsUnknown
	C.pdf_annot_quad_point(cctx, cannot, ci, cqp)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
}

// AnnotInkListCount function as declared in pdf/annot.h:157
func AnnotInkListCount(ctx []Context, annot []Annot) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	__ret := C.pdf_annot_ink_list_count(cctx, cannot)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// AnnotInkListStrokeCount function as declared in pdf/annot.h:158
func AnnotInkListStrokeCount(ctx []Context, annot []Annot, i int32) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	ci, _ := (C.int)(i), cgoAllocsUnknown
	__ret := C.pdf_annot_ink_list_stroke_count(cctx, cannot, ci)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// AnnotInkListStrokeVertex function as declared in pdf/annot.h:159
func AnnotInkListStrokeVertex(ctx []Context, annot []Annot, i int32, k int32, v *[2]float32) {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	ci, _ := (C.int)(i), cgoAllocsUnknown
	ck, _ := (C.int)(k), cgoAllocsUnknown
	cv, _ := *(**C.float)(unsafe.Pointer(&v)), cgoAllocsUnknown
	C.pdf_annot_ink_list_stroke_vertex(cctx, cannot, ci, ck, cv)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
}

// SetAnnotFlags function as declared in pdf/annot.h:161
func SetAnnotFlags(ctx []Context, annot []Annot, flags int32) {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	cflags, _ := (C.int)(flags), cgoAllocsUnknown
	C.pdf_set_annot_flags(cctx, cannot, cflags)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
}

// SetAnnotRect function as declared in pdf/annot.h:162
func SetAnnotRect(ctx []Context, annot []Annot, rect []Rect) {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	crect, _ := unpackArgSRect(rect)
	C.pdf_set_annot_rect(cctx, cannot, crect)
	packSRect(rect, crect)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
}

// SetAnnotBorder function as declared in pdf/annot.h:163
func SetAnnotBorder(ctx []Context, annot []Annot, width float32) {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	cwidth, _ := (C.float)(width), cgoAllocsUnknown
	C.pdf_set_annot_border(cctx, cannot, cwidth)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
}

// SetAnnotColor function as declared in pdf/annot.h:164
func SetAnnotColor(ctx []Context, annot []Annot, n int32, color *[4]float32) {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	cn, _ := (C.int)(n), cgoAllocsUnknown
	ccolor, _ := *(**C.float)(unsafe.Pointer(&color)), cgoAllocsUnknown
	C.pdf_set_annot_color(cctx, cannot, cn, ccolor)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
}

// SetAnnotInteriorColor function as declared in pdf/annot.h:165
func SetAnnotInteriorColor(ctx []Context, annot []Annot, n int32, color *[4]float32) {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	cn, _ := (C.int)(n), cgoAllocsUnknown
	ccolor, _ := *(**C.float)(unsafe.Pointer(&color)), cgoAllocsUnknown
	C.pdf_set_annot_interior_color(cctx, cannot, cn, ccolor)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
}

// SetAnnotQuadPoints function as declared in pdf/annot.h:166
func SetAnnotQuadPoints(ctx []Context, annot []Annot, n int32, v []float32) {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	cn, _ := (C.int)(n), cgoAllocsUnknown
	cv, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&v)).Data)), cgoAllocsUnknown
	C.pdf_set_annot_quad_points(cctx, cannot, cn, cv)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
}

// SetAnnotInkList function as declared in pdf/annot.h:167
func SetAnnotInkList(ctx []Context, annot []Annot, n int32, count []int32, v []float32) {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	cn, _ := (C.int)(n), cgoAllocsUnknown
	ccount, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&count)).Data)), cgoAllocsUnknown
	cv, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&v)).Data)), cgoAllocsUnknown
	C.pdf_set_annot_ink_list(cctx, cannot, cn, ccount, cv)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
}

// SetAnnotLineEndingStyles function as declared in pdf/annot.h:169
func SetAnnotLineEndingStyles(ctx []Context, annot []Annot, startStyle int32, endStyle int32) {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	cstartStyle, _ := (C.int)(startStyle), cgoAllocsUnknown
	cendStyle, _ := (C.int)(endStyle), cgoAllocsUnknown
	C.pdf_set_annot_line_ending_styles(cctx, cannot, cstartStyle, cendStyle)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
}

// SetAnnotVertices function as declared in pdf/annot.h:170
func SetAnnotVertices(ctx []Context, annot []Annot, n int32, v []float32) {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	cn, _ := (C.int)(n), cgoAllocsUnknown
	cv, _ := (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&v)).Data)), cgoAllocsUnknown
	C.pdf_set_annot_vertices(cctx, cannot, cn, cv)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
}

// SetAnnotIconName function as declared in pdf/annot.h:171
func SetAnnotIconName(ctx []Context, annot []Annot, name string) {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	cname, _ := unpackPCharString(name)
	C.pdf_set_annot_icon_name(cctx, cannot, cname)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
}

// SetAnnotIsOpen function as declared in pdf/annot.h:172
func SetAnnotIsOpen(ctx []Context, annot []Annot, isOpen int32) {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	cisOpen, _ := (C.int)(isOpen), cgoAllocsUnknown
	C.pdf_set_annot_is_open(cctx, cannot, cisOpen)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
}

// AnnotLineEndingStyles function as declared in pdf/annot.h:174
func AnnotLineEndingStyles(ctx []Context, annot []Annot, startStyle []int32, endStyle []int32) {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	cstartStyle, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&startStyle)).Data)), cgoAllocsUnknown
	cendStyle, _ := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&endStyle)).Data)), cgoAllocsUnknown
	C.pdf_annot_line_ending_styles(cctx, cannot, cstartStyle, cendStyle)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
}

// AnnotIconName function as declared in pdf/annot.h:175
func AnnotIconName(ctx []Context, annot []Annot) string {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	__ret := C.pdf_annot_icon_name(cctx, cannot)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
	__v := packPCharString(__ret)
	return __v
}

// AnnotIsOpen function as declared in pdf/annot.h:176
func AnnotIsOpen(ctx []Context, annot []Annot) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	__ret := C.pdf_annot_is_open(cctx, cannot)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// AnnotVertexCount function as declared in pdf/annot.h:178
func AnnotVertexCount(ctx []Context, annot []Annot) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	__ret := C.pdf_annot_vertex_count(cctx, cannot)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// AnnotVertex function as declared in pdf/annot.h:179
func AnnotVertex(ctx []Context, annot []Annot, i int32, v *[2]float32) {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	ci, _ := (C.int)(i), cgoAllocsUnknown
	cv, _ := *(**C.float)(unsafe.Pointer(&v)), cgoAllocsUnknown
	C.pdf_annot_vertex(cctx, cannot, ci, cv)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
}

// SetTextAnnotPosition function as declared in pdf/annot.h:184
func SetTextAnnotPosition(ctx []Context, annot []Annot, pt Point) {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	cpt, _ := pt.PassValue()
	C.pdf_set_text_annot_position(cctx, cannot, cpt)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
}

// SetAnnotContents function as declared in pdf/annot.h:189
func SetAnnotContents(ctx []Context, annot []Annot, text string) {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	ctext, _ := unpackPCharString(text)
	C.pdf_set_annot_contents(cctx, cannot, ctext)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
}

// AnnotContents function as declared in pdf/annot.h:194
func AnnotContents(ctx []Context, annot []Annot) string {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	__ret := C.pdf_annot_contents(cctx, cannot)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
	__v := packPCharString(__ret)
	return __v
}

// AnnotAuthor function as declared in pdf/annot.h:199
func AnnotAuthor(ctx []Context, annot []Annot) string {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	__ret := C.pdf_annot_author(cctx, cannot)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
	__v := packPCharString(__ret)
	return __v
}

// AnnotDate function as declared in pdf/annot.h:206
func AnnotDate(ctx []Context, annot []Annot) string {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	__ret := C.pdf_annot_date(cctx, cannot)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
	__v := packPCharString(__ret)
	return __v
}

// AnnotIrt function as declared in pdf/annot.h:211
func AnnotIrt(ctx []Context, annot []Annot) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	__ret := C.pdf_annot_irt(cctx, cannot)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// SetFreeTextDetails function as declared in pdf/annot.h:217
func SetFreeTextDetails(ctx []Context, annot []Annot, pos []Point, text []byte, fontName []byte, fontSize float32, color *[3]float32) {
	cctx, _ := unpackArgSContext(ctx)
	cannot, _ := unpackArgSAnnot(annot)
	cpos, _ := unpackArgSPoint(pos)
	ctext, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&text)).Data)), cgoAllocsUnknown
	cfontName, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&fontName)).Data)), cgoAllocsUnknown
	cfontSize, _ := (C.float)(fontSize), cgoAllocsUnknown
	ccolor, _ := *(**C.float)(unsafe.Pointer(&color)), cgoAllocsUnknown
	C.pdf_set_free_text_details(cctx, cannot, cpos, ctext, cfontName, cfontSize, ccolor)
	packSPoint(pos, cpos)
	packSAnnot(annot, cannot)
	packSContext(ctx, cctx)
}

// NewAnnot function as declared in pdf/annot.h:222
func NewAnnot(ctx []Context, page []Page) *Annot {
	cctx, _ := unpackArgSContext(ctx)
	cpage, _ := unpackArgSPage(page)
	__ret := C.pdf_new_annot(cctx, cpage)
	packSPage(page, cpage)
	packSContext(ctx, cctx)
	__v := NewAnnotRef(unsafe.Pointer(__ret))
	return __v
}

// GetStringOrStream function as declared in pdf/field.h:36
func GetStringOrStream(ctx []Context, doc []Document, obj []Obj) *byte {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_get_string_or_stream(cctx, cdoc, cobj)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// GetInheritable function as declared in pdf/field.h:37
func GetInheritable(ctx []Context, doc []Document, obj []Obj, key []Obj) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	ckey, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&key)).Data)), cgoAllocsUnknown
	__ret := C.pdf_get_inheritable(cctx, cdoc, cobj, ckey)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// GetFieldFlags function as declared in pdf/field.h:38
func GetFieldFlags(ctx []Context, doc []Document, obj []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	__ret := C.pdf_get_field_flags(cctx, cdoc, cobj)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// FieldType function as declared in pdf/field.h:39
func FieldType(ctx []Context, doc []Document, field []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cfield, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&field)).Data)), cgoAllocsUnknown
	__ret := C.pdf_field_type(cctx, cdoc, cfield)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// SetFieldType function as declared in pdf/field.h:40
func SetFieldType(ctx []Context, doc []Document, obj []Obj, kind int32) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	ckind, _ := (C.int)(kind), cgoAllocsUnknown
	C.pdf_set_field_type(cctx, cdoc, cobj, ckind)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// FieldValue function as declared in pdf/field.h:41
func FieldValue(ctx []Context, doc []Document, field []Obj) *byte {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cfield, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&field)).Data)), cgoAllocsUnknown
	__ret := C.pdf_field_value(cctx, cdoc, cfield)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// FieldSetValue function as declared in pdf/field.h:42
func FieldSetValue(ctx []Context, doc []Document, field []Obj, text string) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cfield, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&field)).Data)), cgoAllocsUnknown
	ctext, _ := unpackPCharString(text)
	__ret := C.pdf_field_set_value(cctx, cdoc, cfield, ctext)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// FieldBorderStyle function as declared in pdf/field.h:43
func FieldBorderStyle(ctx []Context, doc []Document, field []Obj) *byte {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cfield, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&field)).Data)), cgoAllocsUnknown
	__ret := C.pdf_field_border_style(cctx, cdoc, cfield)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// FieldSetBorderStyle function as declared in pdf/field.h:44
func FieldSetBorderStyle(ctx []Context, doc []Document, field []Obj, text string) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cfield, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&field)).Data)), cgoAllocsUnknown
	ctext, _ := unpackPCharString(text)
	C.pdf_field_set_border_style(cctx, cdoc, cfield, ctext)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// FieldSetButtonCaption function as declared in pdf/field.h:45
func FieldSetButtonCaption(ctx []Context, doc []Document, field []Obj, text string) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cfield, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&field)).Data)), cgoAllocsUnknown
	ctext, _ := unpackPCharString(text)
	C.pdf_field_set_button_caption(cctx, cdoc, cfield, ctext)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// FieldSetFillColor function as declared in pdf/field.h:46
func FieldSetFillColor(ctx []Context, doc []Document, field []Obj, col []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cfield, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&field)).Data)), cgoAllocsUnknown
	ccol, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&col)).Data)), cgoAllocsUnknown
	C.pdf_field_set_fill_color(cctx, cdoc, cfield, ccol)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// FieldSetTextColor function as declared in pdf/field.h:47
func FieldSetTextColor(ctx []Context, doc []Document, field []Obj, col []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cfield, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&field)).Data)), cgoAllocsUnknown
	ccol, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&col)).Data)), cgoAllocsUnknown
	C.pdf_field_set_text_color(cctx, cdoc, cfield, ccol)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// SignatureSetValue function as declared in pdf/field.h:48
func SignatureSetValue(ctx []Context, doc []Document, field []Obj, signer []Signer) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cfield, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&field)).Data)), cgoAllocsUnknown
	csigner, _ := (*C.pdf_signer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&signer)).Data)), cgoAllocsUnknown
	C.pdf_signature_set_value(cctx, cdoc, cfield, csigner)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// FieldDisplay function as declared in pdf/field.h:49
func FieldDisplay(ctx []Context, doc []Document, field []Obj) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cfield, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&field)).Data)), cgoAllocsUnknown
	__ret := C.pdf_field_display(cctx, cdoc, cfield)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// FieldName function as declared in pdf/field.h:50
func FieldName(ctx []Context, doc []Document, field []Obj) *byte {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cfield, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&field)).Data)), cgoAllocsUnknown
	__ret := C.pdf_field_name(cctx, cdoc, cfield)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// FieldSetDisplay function as declared in pdf/field.h:51
func FieldSetDisplay(ctx []Context, doc []Document, field []Obj, d int32) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cfield, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&field)).Data)), cgoAllocsUnknown
	cd, _ := (C.int)(d), cgoAllocsUnknown
	C.pdf_field_set_display(cctx, cdoc, cfield, cd)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// LookupField function as declared in pdf/field.h:52
func LookupField(ctx []Context, form []Obj, name []byte) *Obj {
	cctx, _ := unpackArgSContext(ctx)
	cform, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&form)).Data)), cgoAllocsUnknown
	cname, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&name)).Data)), cgoAllocsUnknown
	__ret := C.pdf_lookup_field(cctx, cform, cname)
	packSContext(ctx, cctx)
	__v := *(**Obj)(unsafe.Pointer(&__ret))
	return __v
}

// FieldReset function as declared in pdf/field.h:53
func FieldReset(ctx []Context, doc []Document, field []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cfield, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&field)).Data)), cgoAllocsUnknown
	C.pdf_field_reset(cctx, cdoc, cfield)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// SignaturesSupported function as declared in pdf/field.h:54
func SignaturesSupported(ctx []Context) int32 {
	cctx, _ := unpackArgSContext(ctx)
	__ret := C.pdf_signatures_supported(cctx)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// FocusedWidget function as declared in pdf/widget.h:40
func FocusedWidget(ctx []Context, doc []Document) *Widget {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.pdf_focused_widget(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Widget)(unsafe.Pointer(&__ret))
	return __v
}

// FirstWidget function as declared in pdf/widget.h:45
func FirstWidget(ctx []Context, doc []Document, page []Page) *Widget {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cpage, _ := unpackArgSPage(page)
	__ret := C.pdf_first_widget(cctx, cdoc, cpage)
	packSPage(page, cpage)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Widget)(unsafe.Pointer(&__ret))
	return __v
}

// NextWidget function as declared in pdf/widget.h:50
func NextWidget(ctx []Context, previous []Widget) *Widget {
	cctx, _ := unpackArgSContext(ctx)
	cprevious, _ := (*C.pdf_widget)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&previous)).Data)), cgoAllocsUnknown
	__ret := C.pdf_next_widget(cctx, cprevious)
	packSContext(ctx, cctx)
	__v := *(**Widget)(unsafe.Pointer(&__ret))
	return __v
}

// CreateWidget function as declared in pdf/widget.h:55
func CreateWidget(ctx []Context, doc []Document, page []Page, kind int32, fieldname []byte) *Widget {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cpage, _ := unpackArgSPage(page)
	ckind, _ := (C.int)(kind), cgoAllocsUnknown
	cfieldname, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&fieldname)).Data)), cgoAllocsUnknown
	__ret := C.pdf_create_widget(cctx, cdoc, cpage, ckind, cfieldname)
	packSPage(page, cpage)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**Widget)(unsafe.Pointer(&__ret))
	return __v
}

// WidgetType function as declared in pdf/widget.h:63
func WidgetType(ctx []Context, widget []Widget) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cwidget, _ := (*C.pdf_widget)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&widget)).Data)), cgoAllocsUnknown
	__ret := C.pdf_widget_type(cctx, cwidget)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// BoundWidget function as declared in pdf/widget.h:68
func BoundWidget(ctx []Context, widget []Widget, arg2 []Rect) *Rect {
	cctx, _ := unpackArgSContext(ctx)
	cwidget, _ := (*C.pdf_widget)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&widget)).Data)), cgoAllocsUnknown
	carg2, _ := unpackArgSRect(arg2)
	__ret := C.pdf_bound_widget(cctx, cwidget, carg2)
	packSRect(arg2, carg2)
	packSContext(ctx, cctx)
	__v := NewRectRef(unsafe.Pointer(__ret))
	return __v
}

// TextWidgetText function as declared in pdf/widget.h:74
func TextWidgetText(ctx []Context, doc []Document, tw []Widget) *byte {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	ctw, _ := (*C.pdf_widget)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&tw)).Data)), cgoAllocsUnknown
	__ret := C.pdf_text_widget_text(cctx, cdoc, ctw)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// TextWidgetMaxLen function as declared in pdf/widget.h:80
func TextWidgetMaxLen(ctx []Context, doc []Document, tw []Widget) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	ctw, _ := (*C.pdf_widget)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&tw)).Data)), cgoAllocsUnknown
	__ret := C.pdf_text_widget_max_len(cctx, cdoc, ctw)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// TextWidgetContentType function as declared in pdf/widget.h:86
func TextWidgetContentType(ctx []Context, doc []Document, tw []Widget) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	ctw, _ := (*C.pdf_widget)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&tw)).Data)), cgoAllocsUnknown
	__ret := C.pdf_text_widget_content_type(cctx, cdoc, ctw)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// TextWidgetSetText function as declared in pdf/widget.h:93
func TextWidgetSetText(ctx []Context, doc []Document, tw []Widget, text []byte) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	ctw, _ := (*C.pdf_widget)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&tw)).Data)), cgoAllocsUnknown
	ctext, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&text)).Data)), cgoAllocsUnknown
	__ret := C.pdf_text_widget_set_text(cctx, cdoc, ctw, ctext)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ChoiceWidgetOptions function as declared in pdf/widget.h:103
func ChoiceWidgetOptions(ctx []Context, doc []Document, tw []Widget, exportval int32, opts [][]byte) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	ctw, _ := (*C.pdf_widget)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&tw)).Data)), cgoAllocsUnknown
	cexportval, _ := (C.int)(exportval), cgoAllocsUnknown
	copts, _ := unpackArgSSByte(opts)
	__ret := C.pdf_choice_widget_options(cctx, cdoc, ctw, cexportval, copts)
	packSSByte(opts, copts)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ChoiceWidgetIsMultiselect function as declared in pdf/widget.h:109
func ChoiceWidgetIsMultiselect(ctx []Context, doc []Document, tw []Widget) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	ctw, _ := (*C.pdf_widget)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&tw)).Data)), cgoAllocsUnknown
	__ret := C.pdf_choice_widget_is_multiselect(cctx, cdoc, ctw)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ChoiceWidgetValue function as declared in pdf/widget.h:118
func ChoiceWidgetValue(ctx []Context, doc []Document, tw []Widget, opts [][]byte) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	ctw, _ := (*C.pdf_widget)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&tw)).Data)), cgoAllocsUnknown
	copts, _ := unpackArgSSByte(opts)
	__ret := C.pdf_choice_widget_value(cctx, cdoc, ctw, copts)
	packSSByte(opts, copts)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// ChoiceWidgetSetValue function as declared in pdf/widget.h:125
func ChoiceWidgetSetValue(ctx []Context, doc []Document, tw []Widget, n int32, opts [][]byte) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	ctw, _ := (*C.pdf_widget)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&tw)).Data)), cgoAllocsUnknown
	cn, _ := (C.int)(n), cgoAllocsUnknown
	copts, _ := unpackArgSSByte(opts)
	C.pdf_choice_widget_set_value(cctx, cdoc, ctw, cn, copts)
	packSSByte(opts, copts)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// DaInfoFin function as declared in pdf/appearance.h:12
func DaInfoFin(ctx []Context, di []DaInfo) {
	cctx, _ := unpackArgSContext(ctx)
	cdi, _ := unpackArgSDaInfo(di)
	C.pdf_da_info_fin(cctx, cdi)
	packSDaInfo(di, cdi)
	packSContext(ctx, cctx)
}

// ParseDa function as declared in pdf/appearance.h:13
func ParseDa(ctx []Context, da []byte, di []DaInfo) {
	cctx, _ := unpackArgSContext(ctx)
	cda, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&da)).Data)), cgoAllocsUnknown
	cdi, _ := unpackArgSDaInfo(di)
	C.pdf_parse_da(cctx, cda, cdi)
	packSDaInfo(di, cdi)
	packSContext(ctx, cctx)
}

// FzbufPrintDa function as declared in pdf/appearance.h:14
func FzbufPrintDa(ctx []Context, fzbuf []Buffer, di []DaInfo) {
	cctx, _ := unpackArgSContext(ctx)
	cfzbuf, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&fzbuf)).Data)), cgoAllocsUnknown
	cdi, _ := unpackArgSDaInfo(di)
	C.pdf_fzbuf_print_da(cctx, cfzbuf, cdi)
	packSDaInfo(di, cdi)
	packSContext(ctx, cctx)
}

// UpdateTextAppearance function as declared in pdf/appearance.h:16
func UpdateTextAppearance(ctx []Context, doc []Document, obj []Obj, eventvalue []byte) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	ceventvalue, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&eventvalue)).Data)), cgoAllocsUnknown
	C.pdf_update_text_appearance(cctx, cdoc, cobj, ceventvalue)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// UpdateComboboxAppearance function as declared in pdf/appearance.h:17
func UpdateComboboxAppearance(ctx []Context, doc []Document, obj []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	C.pdf_update_combobox_appearance(cctx, cdoc, cobj)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// UpdateListboxAppearance function as declared in pdf/appearance.h:18
func UpdateListboxAppearance(ctx []Context, doc []Document, obj []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	C.pdf_update_listbox_appearance(cctx, cdoc, cobj)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// UpdatePushbuttonAppearance function as declared in pdf/appearance.h:19
func UpdatePushbuttonAppearance(ctx []Context, doc []Document, obj []Obj) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cobj, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&obj)).Data)), cgoAllocsUnknown
	C.pdf_update_pushbutton_appearance(cctx, cdoc, cobj)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// UpdateTextMarkupAppearance function as declared in pdf/appearance.h:20
func UpdateTextMarkupAppearance(ctx []Context, doc []Document, annot []Annot, kind AnnotType) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cannot, _ := unpackArgSAnnot(annot)
	ckind, _ := (C.fz_annot_type)(kind), cgoAllocsUnknown
	C.pdf_update_text_markup_appearance(cctx, cdoc, cannot, ckind)
	packSAnnot(annot, cannot)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// UpdateInkAppearance function as declared in pdf/appearance.h:21
func UpdateInkAppearance(ctx []Context, doc []Document, annot []Annot) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cannot, _ := unpackArgSAnnot(annot)
	C.pdf_update_ink_appearance(cctx, cdoc, cannot)
	packSAnnot(annot, cannot)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// UpdateTextAnnotAppearance function as declared in pdf/appearance.h:22
func UpdateTextAnnotAppearance(ctx []Context, doc []Document, annot []Annot) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cannot, _ := unpackArgSAnnot(annot)
	C.pdf_update_text_annot_appearance(cctx, cdoc, cannot)
	packSAnnot(annot, cannot)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// UpdateFreeTextAnnotAppearance function as declared in pdf/appearance.h:27
func UpdateFreeTextAnnotAppearance(ctx []Context, doc []Document, annot []Annot) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cannot, _ := unpackArgSAnnot(annot)
	C.pdf_update_free_text_annot_appearance(cctx, cdoc, cannot)
	packSAnnot(annot, cannot)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// SetAnnotAppearance function as declared in pdf/appearance.h:33
func SetAnnotAppearance(ctx []Context, doc []Document, annot []Annot, rect []Rect, dispList []DisplayList) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cannot, _ := unpackArgSAnnot(annot)
	crect, _ := unpackArgSRect(rect)
	cdispList, _ := (*C.fz_display_list)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&dispList)).Data)), cgoAllocsUnknown
	C.pdf_set_annot_appearance(cctx, cdoc, cannot, crect, cdispList)
	packSRect(rect, crect)
	packSAnnot(annot, cannot)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// SetMarkupAppearance function as declared in pdf/appearance.h:39
func SetMarkupAppearance(ctx []Context, doc []Document, annot []Annot, color *[3]float32, alpha float32, lineThickness float32, lineHeight float32) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cannot, _ := unpackArgSAnnot(annot)
	ccolor, _ := *(**C.float)(unsafe.Pointer(&color)), cgoAllocsUnknown
	calpha, _ := (C.float)(alpha), cgoAllocsUnknown
	clineThickness, _ := (C.float)(lineThickness), cgoAllocsUnknown
	clineHeight, _ := (C.float)(lineHeight), cgoAllocsUnknown
	C.pdf_set_markup_appearance(cctx, cdoc, cannot, ccolor, calpha, clineThickness, clineHeight)
	packSAnnot(annot, cannot)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// SetSignatureAppearance function as declared in pdf/appearance.h:41
func SetSignatureAppearance(ctx []Context, doc []Document, annot []Annot, name []byte, dn string, date []byte) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cannot, _ := unpackArgSAnnot(annot)
	cname, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&name)).Data)), cgoAllocsUnknown
	cdn, _ := unpackPCharString(dn)
	cdate, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&date)).Data)), cgoAllocsUnknown
	C.pdf_set_signature_appearance(cctx, cdoc, cannot, cname, cdn, cdate)
	packSAnnot(annot, cannot)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// InitUiPointerEvent function as declared in pdf/event.h:42
func InitUiPointerEvent(event []UiEvent, kind int32, x float32, y float32) {
	cevent, _ := unpackArgSUiEvent(event)
	ckind, _ := (C.int)(kind), cgoAllocsUnknown
	cx, _ := (C.float)(x), cgoAllocsUnknown
	cy, _ := (C.float)(y), cgoAllocsUnknown
	C.pdf_init_ui_pointer_event(cevent, ckind, cx, cy)
	packSUiEvent(event, cevent)
}

// PassEvent function as declared in pdf/event.h:60
func PassEvent(ctx []Context, doc []Document, page []Page, uiEvent []UiEvent) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cpage, _ := unpackArgSPage(page)
	cuiEvent, _ := unpackArgSUiEvent(uiEvent)
	__ret := C.pdf_pass_event(cctx, cdoc, cpage, cuiEvent)
	packSUiEvent(uiEvent, cuiEvent)
	packSPage(page, cpage)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// SetDocEventCallback function as declared in pdf/event.h:82
func SetDocEventCallback(ctx []Context, doc []Document, eventCb DocEventCb, data unsafe.Pointer) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	ceventCb, _ := eventCb.PassRef()
	cdata, _ := data, cgoAllocsUnknown
	C.pdf_set_doc_event_callback(cctx, cdoc, ceventCb, cdata)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// AccessAlertEvent function as declared in pdf/event.h:144
func AccessAlertEvent(ctx []Context, event []DocEvent) *AlertEvent {
	cctx, _ := unpackArgSContext(ctx)
	cevent, _ := unpackArgSDocEvent(event)
	__ret := C.pdf_access_alert_event(cctx, cevent)
	packSDocEvent(event, cevent)
	packSContext(ctx, cctx)
	__v := NewAlertEventRef(unsafe.Pointer(__ret))
	return __v
}

// AccessExecMenuItemEvent function as declared in pdf/event.h:150
func AccessExecMenuItemEvent(ctx []Context, event []DocEvent) string {
	cctx, _ := unpackArgSContext(ctx)
	cevent, _ := unpackArgSDocEvent(event)
	__ret := C.pdf_access_exec_menu_item_event(cctx, cevent)
	packSDocEvent(event, cevent)
	packSContext(ctx, cctx)
	__v := packPCharString(__ret)
	return __v
}

// AccessSubmitEvent function as declared in pdf/event.h:170
func AccessSubmitEvent(ctx []Context, event []DocEvent) *SubmitEvent {
	cctx, _ := unpackArgSContext(ctx)
	cevent, _ := unpackArgSDocEvent(event)
	__ret := C.pdf_access_submit_event(cctx, cevent)
	packSDocEvent(event, cevent)
	packSContext(ctx, cctx)
	__v := NewSubmitEventRef(unsafe.Pointer(__ret))
	return __v
}

// AccessLaunchUrlEvent function as declared in pdf/event.h:187
func AccessLaunchUrlEvent(ctx []Context, event []DocEvent) *LaunchUrlEvent {
	cctx, _ := unpackArgSContext(ctx)
	cevent, _ := unpackArgSDocEvent(event)
	__ret := C.pdf_access_launch_url_event(cctx, cevent)
	packSDocEvent(event, cevent)
	packSContext(ctx, cctx)
	__v := NewLaunchUrlEventRef(unsafe.Pointer(__ret))
	return __v
}

// AccessMailDocEvent function as declared in pdf/event.h:207
func AccessMailDocEvent(ctx []Context, event []DocEvent) *MailDocEvent {
	cctx, _ := unpackArgSContext(ctx)
	cevent, _ := unpackArgSDocEvent(event)
	__ret := C.pdf_access_mail_doc_event(cctx, cevent)
	packSDocEvent(event, cevent)
	packSContext(ctx, cctx)
	__v := NewMailDocEventRef(unsafe.Pointer(__ret))
	return __v
}

// EventIssueAlert function as declared in pdf/event.h:209
func EventIssueAlert(ctx []Context, doc []Document, event []AlertEvent) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cevent, _ := unpackArgSAlertEvent(event)
	C.pdf_event_issue_alert(cctx, cdoc, cevent)
	packSAlertEvent(event, cevent)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// EventIssuePrint function as declared in pdf/event.h:210
func EventIssuePrint(ctx []Context, doc []Document) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	C.pdf_event_issue_print(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// EventIssueExecMenuItem function as declared in pdf/event.h:211
func EventIssueExecMenuItem(ctx []Context, doc []Document, item string) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	citem, _ := unpackPCharString(item)
	C.pdf_event_issue_exec_menu_item(cctx, cdoc, citem)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// EventIssueExecDialog function as declared in pdf/event.h:212
func EventIssueExecDialog(ctx []Context, doc []Document) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	C.pdf_event_issue_exec_dialog(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// EventIssueLaunchUrl function as declared in pdf/event.h:213
func EventIssueLaunchUrl(ctx []Context, doc []Document, url string, newFrame int32) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	curl, _ := unpackPCharString(url)
	cnewFrame, _ := (C.int)(newFrame), cgoAllocsUnknown
	C.pdf_event_issue_launch_url(cctx, cdoc, curl, cnewFrame)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// EventIssueMailDoc function as declared in pdf/event.h:214
func EventIssueMailDoc(ctx []Context, doc []Document, event []MailDocEvent) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	cevent, _ := unpackArgSMailDocEvent(event)
	C.pdf_event_issue_mail_doc(cctx, cdoc, cevent)
	packSMailDocEvent(event, cevent)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// EnableJs function as declared in pdf/javascript.h:11
func EnableJs(ctx []Context, doc []Document) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	C.pdf_enable_js(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// DisableJs function as declared in pdf/javascript.h:12
func DisableJs(ctx []Context, doc []Document) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	C.pdf_disable_js(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// JsSupported function as declared in pdf/javascript.h:13
func JsSupported(ctx []Context, doc []Document) int32 {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	__ret := C.pdf_js_supported(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := (int32)(__ret)
	return __v
}

// DropJs function as declared in pdf/javascript.h:14
func DropJs(ctx []Context, js []Js) {
	cctx, _ := unpackArgSContext(ctx)
	cjs, _ := (*C.pdf_js)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&js)).Data)), cgoAllocsUnknown
	C.pdf_drop_js(cctx, cjs)
	packSContext(ctx, cctx)
}

// JsSetupEvent function as declared in pdf/javascript.h:16
func JsSetupEvent(js []Js, e []JsEvent) {
	cjs, _ := (*C.pdf_js)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&js)).Data)), cgoAllocsUnknown
	ce, _ := unpackArgSJsEvent(e)
	C.pdf_js_setup_event(cjs, ce)
	packSJsEvent(e, ce)
}

// JsGetEvent function as declared in pdf/javascript.h:17
func JsGetEvent(js []Js) *JsEvent {
	cjs, _ := (*C.pdf_js)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&js)).Data)), cgoAllocsUnknown
	__ret := C.pdf_js_get_event(cjs)
	__v := NewJsEventRef(unsafe.Pointer(__ret))
	return __v
}

// JsExecute function as declared in pdf/javascript.h:18
func JsExecute(js []Js, code []byte) {
	cjs, _ := (*C.pdf_js)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&js)).Data)), cgoAllocsUnknown
	ccode, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&code)).Data)), cgoAllocsUnknown
	C.pdf_js_execute(cjs, ccode)
}

// New_Device function as declared in pdf/output-pdf.h:13
func New_Device(ctx []Context, doc []Document, topctm []Matrix, mediabox []Rect, resources []Obj, contents []Buffer) *Device {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	ctopctm, _ := unpackArgSMatrix(topctm)
	cmediabox, _ := unpackArgSRect(mediabox)
	cresources, _ := (*C.pdf_obj)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&resources)).Data)), cgoAllocsUnknown
	ccontents, _ := (*C.fz_buffer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&contents)).Data)), cgoAllocsUnknown
	__ret := C.pdf_new_pdf_device(cctx, cdoc, ctopctm, cmediabox, cresources, ccontents)
	packSRect(mediabox, cmediabox)
	packSMatrix(topctm, ctopctm)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
	__v := NewDeviceRef(unsafe.Pointer(__ret))
	return __v
}

// LocalisePageResources function as declared in pdf/output-pdf.h:16
func LocalisePageResources(ctx []Context, doc []Document) {
	cctx, _ := unpackArgSContext(ctx)
	cdoc, _ := unpackArgSDocument(doc)
	C.pdf_localise_page_resources(cctx, cdoc)
	packSDocument(doc, cdoc)
	packSContext(ctx, cctx)
}

// CleanFile function as declared in pdf/clean.h:5
func CleanFile(ctx []Context, infile []byte, outfile []byte, password []byte, opts []WriteOptions, retainlist [][]byte, retainlen int32) {
	cctx, _ := unpackArgSContext(ctx)
	cinfile, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&infile)).Data)), cgoAllocsUnknown
	coutfile, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&outfile)).Data)), cgoAllocsUnknown
	cpassword, _ := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&password)).Data)), cgoAllocsUnknown
	copts, _ := unpackArgSWriteOptions(opts)
	cretainlist, _ := unpackArgSSByte(retainlist)
	cretainlen, _ := (C.int)(retainlen), cgoAllocsUnknown
	C.pdf_clean_file(cctx, cinfile, coutfile, cpassword, copts, cretainlist, cretainlen)
	packSSByte(retainlist, cretainlist)
	packSWriteOptions(opts, copts)
	packSContext(ctx, cctx)
}
